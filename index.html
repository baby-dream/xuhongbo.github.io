<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2016/11/12/深入理解javascript/51深入理解J avaScript 系列（结局篇）/"><span>深入理解J avaScript 系列（结局篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/11/12/深入理解javascript/51深入理解J avaScript 系列（结局篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-11-12T04:02:02.000Z">
          2016-11-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>最近几个月忙得实在是不可开交，终于把《深入理解 JavaScript 系列》的最后两篇“补全”了，所谓的全是不准确的，因为很多内容都没有写呢，比如高性能、Ajax 安全、DOM 详解、JavaScript 架构等等。但因为经历所限，加上大叔希望接下来写点其它东西，所以此篇文字就暂且当前完结篇的总结吧，以后有时间的话，可以继续加上一些未涉及的专题内容。</p>
<h2 id="网络文章来源"><a href="#网络文章来源" class="headerlink" title="网络文章来源"></a>网络文章来源</h2><p>本系列文章参考了大量的互联网网站，在此向各位网站拥有者、博主、提到的以及未提到的作者们说一声：多谢感谢了。</p>
<p>本系列文章主要参考了如下站点：</p>
<p>五大原则：<a href="http://freshbrewedcode.com/derekgreer" target="_blank" rel="external">http://freshbrewedcode.com/derekgreer</a></p>
<p>ECMAScript262 系列：<a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">http://dmitrysoshnikov.com/</a></p>
<p>DOM 系列文章：<a href="http://net.tutsplus.com/" target="_blank" rel="external">http://net.tutsplus.com</a></p>
<p>设计模式系列文章参考如下三个网站：</p>
<p><a href="http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/" target="_blank" rel="external">http://www.addyosmani.com/resources/essentialjsdesignpatterns/book/</a></p>
<p><a href="http://shichuan.github.com/javascript-patterns/" target="_blank" rel="external">http://shichuan.github.com/javascript-patterns/</a></p>
<p><a href="https://github.com/tcorral/Design-Patterns-in-Javascript/" target="_blank" rel="external">https://github.com/tcorral/Design-Patterns-in-Javascript/</a></p>
<p>其它文章，总结自自己的收藏、心得，结合了互联网上的各位大牛的博客总结整理而成，因为参考地址太多，无法一一列出，如果忘记了各位各种的版权声明，请及时告知，以便及时处理，多谢！</p>
<h2 id="参考书籍"><a href="#参考书籍" class="headerlink" title="参考书籍"></a>参考书籍</h2><p>这里列出的书籍是大叔曾经读过的，也是在整理博文的时候经常参考的书籍，推荐给大家阅读。</p>
<h3 id="初级读物"><a href="#初级读物" class="headerlink" title="初级读物"></a>初级读物</h3><p>《JavaScript 高级程序设计》：一本非常完整的经典入门书籍，被誉为 JavaScript 圣经之一，详解的非常详细，最新版第三版已经发布了，建议购买。</p>
<h3 id="中级读物"><a href="#中级读物" class="headerlink" title="中级读物"></a>中级读物</h3><p>《JavaScript 权威指南》：另外一本 JavaScript 圣经，讲解的也非常详细，属于中级读物，建议购买。</p>
<p>《JavaScript.The.Good.Parts》：Yahoo 大牛，JavaScript 精神领袖 Douglas Crockford 的大作，虽然才 100 多页，但是字字珠玑啊！强烈建议阅读。</p>
<p>《高性能 JavaScript》：《JavaScript 高级程序设计》作者 Nicholas C. Zakas 的又一大作。</p>
<p>《Eloquent JavaScript》：这本书才 200 多页，非常短小，但是改变了我写作的习惯，本书通过几个非常经典的例子（艾米丽姨妈的猫、悲惨的隐士、模拟生态圈、推箱子游戏等等）来介绍 JavaScript 方方面面的知识和应用方法，非常值得一读，同时这本书的中文版也是大叔翻译的，点击屏幕右上角可以订购，希望大家多多支持。</p>
<h3 id="高级读物"><a href="#高级读物" class="headerlink" title="高级读物"></a>高级读物</h3><p>《JavaScript Patterns 》：书中介绍到了各种经典的模式，如构造函数、单例、工厂等等，值得学习。</p>
<p>《Pro.JavaScript.Design.Patterns》：Apress 出版社讲解 JavaScript 设计模式的书，非常不错。</p>
<p>《Developing JavaScript Web Applications》：构建富应用的好书，针对 MVC 模式有较为深入的讲解，同时也对一些流程的库进行了讲解。</p>
<p>《Developing Large Web Applications》：将这本书归结在这里，貌似有点不妥，因为这里不仅有 JavaScript 方面的介绍，还有 CSS、HTML 方面的介绍，但是介绍的内容却都非常不错，真正考虑到了一个大型的 Web 程序下，如何进行 JavaScript 架构设计，值得一读。</p>
<h3 id="其它参考书籍"><a href="#其它参考书籍" class="headerlink" title="其它参考书籍"></a>其它参考书籍</h3><p>《大话设计模式》：博文里关于设计模式的文章，有些总结性的文字来自于此。</p>
<p>《设计模式——可复用面向对象软件的基础》：博文里关于设计模式的文章，有些介绍性和总结性的文章来自于此。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在写此系列文章期间，大叔也学到了很多很多内容。同时为了不误人子弟，大叔参考了很多很多文章，同时也阅读了那么多书籍，但博客里的文章，可能依然有很多错误，希望各位如果发现错误的话，请及时告知，以便及时修正而不再继续误导其它人。</p>
<p>同时，大家在阅读过程中，有任何问题都可以在相应的文章里留言，大叔将在不耽误工作的情况下尽力回复。</p>
<h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/10/08/eslint配置/"><span>eslint配置</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/10/08/eslint配置/" rel="bookmark">
        <time class="entry-date published" datetime="2016-10-08T07:02:02.000Z">
          2016-10-08
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>我们在全局安装<code>npm install eslint -g</code></p>
<p>然后再初始化eslint<code>eslint --init</code></p>
<p>然后我们配置的时候<br>第一种初始化方式<br><img src="images/eslint-1.png" alt="img"><br><img src="images/eslint-1.png" alt="img"><br><img src="images/eslint-1.png" alt="img"></p>
<p><img src="images/eslint-4.png" alt="img"></p>
<p>第二种初始化方式<br><img src="images/eslint-5.png" alt="img"></p>
<p>然后就可以了  重启我们的vscode就可以进行代码风格检查了</p>
<ul>
<li>文档 &lt;<a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="external">http://eslint.cn/docs/user-guide/configuring</a><a href="http://eslint.cn/docs/user-guide/configuring" target="_blank" rel="external">http://eslint.cn/docs/user-guide/configuring</a>ESLint的2种配置:<strong>Configuration Comments</strong> - 使用 JavaScript 注释把配置信息直接嵌入到一个文件。<strong>Configuration Files</strong> - 使用 JavaScript、JSON 或者 YAML 文件为整个目录和它的子目录指定配置信息。可以用 .eslintrc.* 文件或者在 package.json 文件里的 eslintConfig 字段这两种方式进行配置，ESLint 会查找和自动读取它们，再者，你可以在命令行指定一个配置文件。</li>
</ul>
<blockquote>
<blockquote>
<p>有很多配置信息:</p>
<ul>
<li><strong>Environments</strong> -指定脚本的运行环境 每种环境都有一组特定的预定义全局变量</li>
<li><strong>Globals</strong> -脚本在执行期间访问的额外全局变量</li>
<li><strong>Rules</strong> -启用的规则及各自的错误级别</li>
</ul>
</blockquote>
</blockquote>
<h3 id="Configuring-Rules-配置规则"><a href="#Configuring-Rules-配置规则" class="headerlink" title="Configuring Rules 配置规则"></a>Configuring Rules 配置规则</h3><p>ESLint 附带有大量的规则。你可以使用注释或配置文件修改你项目中要使用哪些规则。改变一个规则设置，你必须设置规则 ID 等于这些值之一：</p>
<ul>
<li>“off”或0 -关闭规则</li>
<li>“warn” 或1 - 开启规则, 使用警告 程序不会退出</li>
<li>“error”或2 - 开启规则, 使用错误 程序退出</li>
</ul>
<p>为了在文件注释里配置规则，使用以下格式的注释：</p>
<p><code>/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */</code><br>在这个例子里，eqeqeq 规则被关闭，curly 规则被打开，定义为错误级别。你也可以使用对应的数字定义规则严重程度：</p>
<p><code>/* eslint eqeqeq: 0, curly: 2 */</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;rules&quot;: &#123;</div><div class="line">    &quot;eqeqeq&quot;: &quot;off&quot;,</div><div class="line">    &quot;curly&quot;: &quot;error&quot;,</div><div class="line">    &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;],</div><div class="line">    &quot;plugin1/rule1&quot;: &quot;error&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="临时禁止规则出现警告"><a href="#临时禁止规则出现警告" class="headerlink" title="临时禁止规则出现警告"></a>临时禁止规则出现警告</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* eslint-disable */</span></div><div class="line">alert(<span class="string">'foo'</span>);</div><div class="line"><span class="comment">/* eslint-enable */</span></div></pre></td></tr></table></figure>
<h3 id="rule解释"><a href="#rule解释" class="headerlink" title="rule解释"></a>rule解释</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line"><span class="string">"no-alert"</span>: <span class="number">0</span>,<span class="comment">//禁止使用alert confirm prompt</span></div><div class="line"><span class="string">"no-array-constructor"</span>: <span class="number">2</span>,<span class="comment">//禁止使用数组构造器</span></div><div class="line"><span class="string">"no-bitwise"</span>: <span class="number">0</span>,<span class="comment">//禁止使用按位运算符</span></div><div class="line"><span class="string">"no-caller"</span>: <span class="number">1</span>,<span class="comment">//禁止使用arguments.caller或arguments.callee</span></div><div class="line"><span class="string">"no-catch-shadow"</span>: <span class="number">2</span>,<span class="comment">//禁止catch子句参数与外部作用域变量同名</span></div><div class="line"><span class="string">"no-class-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给类赋值</span></div><div class="line"><span class="string">"no-cond-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件表达式中使用赋值语句</span></div><div class="line"><span class="string">"no-console"</span>: <span class="number">2</span>,<span class="comment">//禁止使用console</span></div><div class="line"><span class="string">"no-const-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止修改const声明的变量</span></div><div class="line"><span class="string">"no-constant-condition"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件中使用常量表达式 if(true) if(1)</span></div><div class="line"><span class="string">"no-continue"</span>: <span class="number">0</span>,<span class="comment">//禁止使用continue</span></div><div class="line"><span class="string">"no-control-regex"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式中使用控制字符</span></div><div class="line"><span class="string">"no-debugger"</span>: <span class="number">2</span>,<span class="comment">//禁止使用debugger</span></div><div class="line"><span class="string">"no-delete-var"</span>: <span class="number">2</span>,<span class="comment">//不能对var声明的变量使用delete操作符</span></div><div class="line"><span class="string">"no-div-regex"</span>: <span class="number">1</span>,<span class="comment">//不能使用看起来像除法的正则表达式/=foo/</span></div><div class="line"><span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,<span class="comment">//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span></div><div class="line"><span class="string">"no-dupe-args"</span>: <span class="number">2</span>,<span class="comment">//函数参数不能重复</span></div><div class="line"><span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,<span class="comment">//switch中的case标签不能重复</span></div><div class="line"><span class="string">"no-else-return"</span>: <span class="number">2</span>,<span class="comment">//如果if语句里面有return,后面不能跟else语句</span></div><div class="line"><span class="string">"no-empty"</span>: <span class="number">2</span>,<span class="comment">//块语句中的内容不能为空</span></div><div class="line"><span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,<span class="comment">//正则表达式中的[]内容不能为空</span></div><div class="line"><span class="string">"no-empty-label"</span>: <span class="number">2</span>,<span class="comment">//禁止使用空label</span></div><div class="line"><span class="string">"no-eq-null"</span>: <span class="number">2</span>,<span class="comment">//禁止对null使用==或!=运算符</span></div><div class="line"><span class="string">"no-eval"</span>: <span class="number">1</span>,<span class="comment">//禁止使用eval</span></div><div class="line"><span class="string">"no-ex-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给catch语句中的异常参数赋值</span></div><div class="line"><span class="string">"no-extend-native"</span>: <span class="number">2</span>,<span class="comment">//禁止扩展native对象</span></div><div class="line"><span class="string">"no-extra-bind"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的函数绑定</span></div><div class="line"><span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的bool转换</span></div><div class="line"><span class="string">"no-extra-parens"</span>: <span class="number">2</span>,<span class="comment">//禁止非必要的括号</span></div><div class="line"><span class="string">"no-extra-semi"</span>: <span class="number">2</span>,<span class="comment">//禁止多余的冒号</span></div><div class="line"><span class="string">"no-fallthrough"</span>: <span class="number">1</span>,<span class="comment">//禁止switch穿透</span></div><div class="line"><span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,<span class="comment">//禁止省略浮点数中的0 .5 3.</span></div><div class="line"><span class="string">"no-func-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止重复的函数声明</span></div><div class="line"><span class="string">"no-implicit-coercion"</span>: <span class="number">1</span>,<span class="comment">//禁止隐式转换</span></div><div class="line"><span class="string">"no-implied-eval"</span>: <span class="number">2</span>,<span class="comment">//禁止使用隐式eval</span></div><div class="line"><span class="string">"no-inline-comments"</span>: <span class="number">0</span>,<span class="comment">//禁止行内备注</span></div><div class="line"><span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],<span class="comment">//禁止在块语句中使用声明（变量或函数）</span></div><div class="line"><span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的正则表达式</span></div><div class="line"><span class="string">"no-invalid-this"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的this，只能用在构造器，类，对象字面量</span></div><div class="line"><span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,<span class="comment">//不能有不规则的空格</span></div><div class="line"><span class="string">"no-iterator"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__iterator__ 属性</span></div><div class="line"><span class="string">"no-label-var"</span>: <span class="number">2</span>,<span class="comment">//label名不能与var声明的变量名相同</span></div><div class="line"><span class="string">"no-labels"</span>: <span class="number">2</span>,<span class="comment">//禁止标签声明</span></div><div class="line"><span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套块</span></div><div class="line"><span class="string">"no-lonely-if"</span>: <span class="number">2</span>,<span class="comment">//禁止else语句内只有if语句</span></div><div class="line"><span class="string">"no-loop-func"</span>: <span class="number">1</span>,<span class="comment">//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span></div><div class="line"><span class="string">"no-mixed-requires"</span>: [<span class="number">0</span>, <span class="literal">false</span>],<span class="comment">//声明时不能混用声明类型</span></div><div class="line"><span class="string">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>],<span class="comment">//禁止混用tab和空格</span></div><div class="line"><span class="string">"linebreak-style"</span>: [<span class="number">0</span>, <span class="string">"windows"</span>],<span class="comment">//换行风格</span></div><div class="line"><span class="string">"no-multi-spaces"</span>: <span class="number">0</span>,<span class="comment">//不能用多余的空格</span></div><div class="line"><span class="string">"no-multi-str"</span>: <span class="number">2</span>,<span class="comment">//字符串不能用\换行</span></div><div class="line"><span class="string">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123;<span class="string">"max"</span>: <span class="number">3</span>&#125;],<span class="comment">//空行最多不能超过2行</span></div><div class="line"><span class="string">"no-native-reassign"</span>: <span class="number">2</span>,<span class="comment">//不能重写native对象</span></div><div class="line"><span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,<span class="comment">//in 操作符的左边不能有!</span></div><div class="line"><span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用嵌套的三目运算</span></div><div class="line"><span class="string">"no-new"</span>: <span class="number">1</span>,<span class="comment">//禁止在使用new构造一个实例后不赋值</span></div><div class="line"><span class="string">"no-new-func"</span>: <span class="number">1</span>,<span class="comment">//禁止使用new Function</span></div><div class="line"><span class="string">"no-new-object"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new Object()</span></div><div class="line"><span class="string">"no-new-require"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new require</span></div><div class="line"><span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new创建包装实例，new String new Boolean new Number</span></div><div class="line"><span class="string">"no-obj-calls"</span>: <span class="number">2</span>,<span class="comment">//不能调用内置的全局对象，比如Math() JSON()</span></div><div class="line"><span class="string">"no-octal"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制数字</span></div><div class="line"><span class="string">"no-octal-escape"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制转义序列</span></div><div class="line"><span class="string">"no-param-reassign"</span>: <span class="number">2</span>,<span class="comment">//禁止给参数重新赋值</span></div><div class="line"><span class="string">"no-path-concat"</span>: <span class="number">0</span>,<span class="comment">//node中不能使用__dirname或__filename做路径拼接</span></div><div class="line"><span class="string">"no-plusplus"</span>: <span class="number">0</span>,<span class="comment">//禁止使用++，--</span></div><div class="line"><span class="string">"no-process-env"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.env</span></div><div class="line"><span class="string">"no-process-exit"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.exit()</span></div><div class="line"><span class="string">"no-proto"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__proto__属性</span></div><div class="line"><span class="string">"no-redeclare"</span>: <span class="number">2</span>,<span class="comment">//禁止重复声明变量</span></div><div class="line"><span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式字面量中使用多个空格 /foo bar/</span></div><div class="line"><span class="string">"no-restricted-modules"</span>: <span class="number">0</span>,<span class="comment">//如果禁用了指定模块，使用就会报错</span></div><div class="line"><span class="string">"no-return-assign"</span>: <span class="number">1</span>,<span class="comment">//return 语句中不能有赋值表达式</span></div><div class="line"><span class="string">"no-script-url"</span>: <span class="number">0</span>,<span class="comment">//禁止使用javascript:void(0)</span></div><div class="line"><span class="string">"no-self-compare"</span>: <span class="number">2</span>,<span class="comment">//不能比较自身</span></div><div class="line"><span class="string">"no-sequences"</span>: <span class="number">0</span>,<span class="comment">//禁止使用逗号运算符</span></div><div class="line"><span class="string">"no-shadow"</span>: <span class="number">2</span>,<span class="comment">//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span></div><div class="line"><span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,<span class="comment">//严格模式中规定的限制标识符不能作为声明时的变量名使用</span></div><div class="line"><span class="string">"no-spaced-func"</span>: <span class="number">2</span>,<span class="comment">//函数调用时 函数名与()之间不能有空格</span></div><div class="line"><span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,<span class="comment">//禁止稀疏数组， [1,,2]</span></div><div class="line"><span class="string">"no-sync"</span>: <span class="number">0</span>,<span class="comment">//nodejs 禁止同步方法</span></div><div class="line"><span class="string">"no-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用三目运算符</span></div><div class="line"><span class="string">"no-trailing-spaces"</span>: <span class="number">1</span>,<span class="comment">//一行结束后面不要有空格</span></div><div class="line"><span class="string">"no-this-before-super"</span>: <span class="number">0</span>,<span class="comment">//在调用super()之前不能使用this或super</span></div><div class="line"><span class="string">"no-throw-literal"</span>: <span class="number">2</span>,<span class="comment">//禁止抛出字面量错误 throw "error";</span></div><div class="line"><span class="string">"no-undef"</span>: <span class="number">2</span>,<span class="comment">//不能有未定义的变量</span></div><div class="line"><span class="string">"no-undef-init"</span>: <span class="number">2</span>,<span class="comment">//变量初始化时不能直接给它赋值为undefined</span></div><div class="line"><span class="string">"no-undefined"</span>: <span class="number">2</span>,<span class="comment">//不能使用undefined</span></div><div class="line"><span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,<span class="comment">//避免多行表达式</span></div><div class="line"><span class="string">"no-underscore-dangle"</span>: <span class="number">1</span>,<span class="comment">//标识符不能以_开头或结尾</span></div><div class="line"><span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></div><div class="line"><span class="string">"no-unreachable"</span>: <span class="number">2</span>,<span class="comment">//不能有无法执行的代码</span></div><div class="line"><span class="string">"no-unused-expressions"</span>: <span class="number">2</span>,<span class="comment">//禁止无用的表达式</span></div><div class="line"><span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123;<span class="string">"vars"</span>: <span class="string">"all"</span>, <span class="string">"args"</span>: <span class="string">"after-used"</span>&#125;],<span class="comment">//不能有声明后未被使用的变量或参数</span></div><div class="line"><span class="string">"no-use-before-define"</span>: <span class="number">2</span>,<span class="comment">//未定义前不能使用</span></div><div class="line"><span class="string">"no-useless-call"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的call和apply</span></div><div class="line"><span class="string">"no-void"</span>: <span class="number">2</span>,<span class="comment">//禁用void操作符</span></div><div class="line"><span class="string">"no-var"</span>: <span class="number">0</span>,<span class="comment">//禁用var，用let和const代替</span></div><div class="line"><span class="string">"no-warning-comments"</span>: [<span class="number">1</span>, &#123; <span class="string">"terms"</span>: [<span class="string">"todo"</span>, <span class="string">"fixme"</span>, <span class="string">"xxx"</span>], <span class="string">"location"</span>: <span class="string">"start"</span> &#125;],<span class="comment">//不能有警告备注</span></div><div class="line"><span class="string">"no-with"</span>: <span class="number">2</span>,<span class="comment">//禁用with</span></div><div class="line"></div><div class="line"><span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//是否允许非空数组里面有多余的空格</span></div><div class="line"><span class="string">"arrow-parens"</span>: <span class="number">0</span>,<span class="comment">//箭头函数用小括号括起来</span></div><div class="line"><span class="string">"arrow-spacing"</span>: <span class="number">0</span>,<span class="comment">//=&gt;的前/后括号</span></div><div class="line"><span class="string">"accessor-pairs"</span>: <span class="number">0</span>,<span class="comment">//在对象中使用getter/setter</span></div><div class="line"><span class="string">"block-scoped-var"</span>: <span class="number">0</span>,<span class="comment">//块语句中使用var</span></div><div class="line"><span class="string">"brace-style"</span>: [<span class="number">1</span>, <span class="string">"1tbs"</span>],<span class="comment">//大括号风格</span></div><div class="line"><span class="string">"callback-return"</span>: <span class="number">1</span>,<span class="comment">//避免多次调用回调什么的</span></div><div class="line"><span class="string">"camelcase"</span>: <span class="number">2</span>,<span class="comment">//强制驼峰法命名</span></div><div class="line"><span class="string">"comma-dangle"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//对象字面量项尾不能有逗号</span></div><div class="line"><span class="string">"comma-spacing"</span>: <span class="number">0</span>,<span class="comment">//逗号前后的空格</span></div><div class="line"><span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],<span class="comment">//逗号风格，换行时在行首还是行尾</span></div><div class="line"><span class="string">"complexity"</span>: [<span class="number">0</span>, <span class="number">11</span>],<span class="comment">//循环复杂度</span></div><div class="line"><span class="string">"computed-property-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//是否允许计算后的键名什么的</span></div><div class="line"><span class="string">"consistent-return"</span>: <span class="number">0</span>,<span class="comment">//return 后面是否允许省略</span></div><div class="line"><span class="string">"consistent-this"</span>: [<span class="number">2</span>, <span class="string">"that"</span>],<span class="comment">//this别名</span></div><div class="line"><span class="string">"constructor-super"</span>: <span class="number">0</span>,<span class="comment">//非派生类不能调用super，派生类必须调用super</span></div><div class="line"><span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],<span class="comment">//必须使用 if()&#123;&#125; 中的&#123;&#125;</span></div><div class="line"><span class="string">"default-case"</span>: <span class="number">2</span>,<span class="comment">//switch语句最后必须有default</span></div><div class="line"><span class="string">"dot-location"</span>: <span class="number">0</span>,<span class="comment">//对象访问符的位置，换行的时候在行首还是行尾</span></div><div class="line"><span class="string">"dot-notation"</span>: [<span class="number">0</span>, &#123; <span class="string">"allowKeywords"</span>: <span class="literal">true</span> &#125;],<span class="comment">//避免不必要的方括号</span></div><div class="line"><span class="string">"eol-last"</span>: <span class="number">0</span>,<span class="comment">//文件以单一的换行符结束</span></div><div class="line"><span class="string">"eqeqeq"</span>: <span class="number">0</span>,<span class="comment">//必须使用全等</span></div><div class="line"><span class="string">"func-names"</span>: <span class="number">0</span>,<span class="comment">//函数表达式必须有名字</span></div><div class="line"><span class="string">"func-style"</span>: [<span class="number">0</span>, <span class="string">"declaration"</span>],<span class="comment">//函数风格，规定只能使用函数声明/函数表达式</span></div><div class="line"><span class="string">"generator-star-spacing"</span>: <span class="number">0</span>,<span class="comment">//生成器函数*的前后空格</span></div><div class="line"><span class="string">"guard-for-in"</span>: <span class="number">0</span>,<span class="comment">//for in循环要用if语句过滤</span></div><div class="line"><span class="string">"handle-callback-err"</span>: <span class="number">0</span>,<span class="comment">//nodejs 处理错误</span></div><div class="line"><span class="string">"id-length"</span>: <span class="number">0</span>,<span class="comment">//变量名长度</span></div><div class="line"><span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">2</span>],<span class="comment">//缩进风格</span></div><div class="line"><span class="string">"init-declarations"</span>: <span class="number">0</span>,<span class="comment">//声明时必须赋初值</span></div><div class="line"><span class="string">"key-spacing"</span>: [<span class="number">0</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span>, <span class="string">"afterColon"</span>: <span class="literal">true</span> &#125;],<span class="comment">//对象字面量中冒号的前后空格</span></div><div class="line"><span class="string">"lines-around-comment"</span>: <span class="number">0</span>,<span class="comment">//行前/行后备注</span></div><div class="line"><span class="string">"max-depth"</span>: [<span class="number">0</span>, <span class="number">4</span>],<span class="comment">//嵌套块深度</span></div><div class="line"><span class="string">"max-len"</span>: [<span class="number">0</span>, <span class="number">80</span>, <span class="number">4</span>],<span class="comment">//字符串最大长度</span></div><div class="line"><span class="string">"max-nested-callbacks"</span>: [<span class="number">0</span>, <span class="number">2</span>],<span class="comment">//回调嵌套深度</span></div><div class="line"><span class="string">"max-params"</span>: [<span class="number">0</span>, <span class="number">3</span>],<span class="comment">//函数最多只能有3个参数</span></div><div class="line"><span class="string">"max-statements"</span>: [<span class="number">0</span>, <span class="number">10</span>],<span class="comment">//函数内最多有几个声明</span></div><div class="line"><span class="string">"new-cap"</span>: <span class="number">2</span>,<span class="comment">//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span></div><div class="line"><span class="string">"new-parens"</span>: <span class="number">2</span>,<span class="comment">//new时必须加小括号</span></div><div class="line"><span class="string">"newline-after-var"</span>: <span class="number">2</span>,<span class="comment">//变量声明后是否需要空一行</span></div><div class="line"><span class="string">"object-curly-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//大括号内是否允许不必要的空格</span></div><div class="line"><span class="string">"object-shorthand"</span>: <span class="number">0</span>,<span class="comment">//强制对象字面量缩写语法</span></div><div class="line"><span class="string">"one-var"</span>: <span class="number">1</span>,<span class="comment">//连续声明</span></div><div class="line"><span class="string">"operator-assignment"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//赋值运算符 += -=什么的</span></div><div class="line"><span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>],<span class="comment">//换行时运算符在行尾还是行首</span></div><div class="line"><span class="string">"padded-blocks"</span>: <span class="number">0</span>,<span class="comment">//块语句内行首行尾是否要空行</span></div><div class="line"><span class="string">"prefer-const"</span>: <span class="number">0</span>,<span class="comment">//首选const</span></div><div class="line"><span class="string">"prefer-spread"</span>: <span class="number">0</span>,<span class="comment">//首选展开运算</span></div><div class="line"><span class="string">"prefer-reflect"</span>: <span class="number">0</span>,<span class="comment">//首选Reflect的方法</span></div><div class="line"><span class="string">"quotes"</span>: [<span class="number">1</span>, <span class="string">"single"</span>],<span class="comment">//引号类型 `` "" ''</span></div><div class="line"><span class="string">"quote-props"</span>:[<span class="number">2</span>, <span class="string">"always"</span>],<span class="comment">//对象字面量中的属性名是否强制双引号</span></div><div class="line"><span class="string">"radix"</span>: <span class="number">2</span>,<span class="comment">//parseInt必须指定第二个参数</span></div><div class="line"><span class="string">"id-match"</span>: <span class="number">0</span>,<span class="comment">//命名检测</span></div><div class="line"><span class="string">"require-yield"</span>: <span class="number">0</span>,<span class="comment">//生成器函数必须有yield</span></div><div class="line"><span class="string">"semi"</span>: [<span class="number">2</span>, <span class="string">"always"</span>],<span class="comment">//语句强制分号结尾</span></div><div class="line"><span class="string">"semi-spacing"</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">true</span>&#125;],<span class="comment">//分号前后空格</span></div><div class="line"><span class="string">"sort-vars"</span>: <span class="number">0</span>,<span class="comment">//变量声明时排序</span></div><div class="line"><span class="string">"space-after-keywords"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//关键字后面是否要空一格</span></div><div class="line"><span class="string">"space-before-blocks"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//不以新行开始的块&#123;前面要不要有空格</span></div><div class="line"><span class="string">"space-before-function-paren"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//函数定义时括号前面要不要有空格</span></div><div class="line"><span class="string">"space-in-parens"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//小括号里面要不要有空格</span></div><div class="line"><span class="string">"space-infix-ops"</span>: <span class="number">0</span>,<span class="comment">//中缀操作符周围要不要有空格</span></div><div class="line"><span class="string">"space-return-throw-case"</span>: <span class="number">2</span>,<span class="comment">//return throw case后面要不要加空格</span></div><div class="line"><span class="string">"space-unary-ops"</span>: [<span class="number">0</span>, &#123; <span class="string">"words"</span>: <span class="literal">true</span>, <span class="string">"nonwords"</span>: <span class="literal">false</span> &#125;],<span class="comment">//一元运算符的前/后要不要加空格</span></div><div class="line"><span class="string">"spaced-comment"</span>: <span class="number">0</span>,<span class="comment">//注释风格要不要有空格什么的</span></div><div class="line"><span class="string">"strict"</span>: <span class="number">2</span>,<span class="comment">//使用严格模式</span></div><div class="line"><span class="string">"use-isnan"</span>: <span class="number">2</span>,<span class="comment">//禁止比较时使用NaN，只能用isNaN()</span></div><div class="line"><span class="string">"valid-jsdoc"</span>: <span class="number">0</span>,<span class="comment">//jsdoc规则</span></div><div class="line"><span class="string">"valid-typeof"</span>: <span class="number">2</span>,<span class="comment">//必须使用合法的typeof的值</span></div><div class="line"><span class="string">"vars-on-top"</span>: <span class="number">2</span>,<span class="comment">//var必须放在作用域顶部</span></div><div class="line"><span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"inside"</span>],<span class="comment">//立即执行函数表达式的小括号风格</span></div><div class="line"><span class="string">"wrap-regex"</span>: <span class="number">0</span>,<span class="comment">//正则表达式字面量用小括号包起来</span></div><div class="line"><span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>]<span class="comment">//禁止尤达条件</span></div></pre></td></tr></table></figure>
<p>vue 2.0 自定义规则如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">parser</span>: <span class="string">'babel-eslint'</span>,</div><div class="line">  <span class="attr">parserOptions</span>: &#123;</div><div class="line">    <span class="attr">sourceType</span>: <span class="string">'module'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="comment">// required to lint *.vue files</span></div><div class="line">  plugins: [</div><div class="line">    <span class="string">'html'</span></div><div class="line">  ],</div><div class="line">  <span class="comment">// add your custom rules here</span></div><div class="line">  <span class="string">'rules'</span>: &#123;</div><div class="line">    <span class="comment">// allow debugger during development</span></div><div class="line">    <span class="string">'no-debugger'</span>: process.env.NODE_ENV === <span class="string">'production'</span> ? <span class="number">2</span> : <span class="number">0</span>,</div><div class="line">    <span class="string">"no-alert"</span>: <span class="number">0</span>,<span class="comment">//禁止使用alert confirm prompt</span></div><div class="line">    <span class="string">"no-array-constructor"</span>: <span class="number">2</span>,<span class="comment">//禁止使用数组构造器</span></div><div class="line">    <span class="string">"no-bitwise"</span>: <span class="number">0</span>,<span class="comment">//禁止使用按位运算符</span></div><div class="line">    <span class="string">"no-caller"</span>: <span class="number">1</span>,<span class="comment">//禁止使用arguments.caller或arguments.callee</span></div><div class="line">    <span class="string">"no-catch-shadow"</span>: <span class="number">2</span>,<span class="comment">//禁止catch子句参数与外部作用域变量同名</span></div><div class="line">    <span class="string">"no-class-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给类赋值</span></div><div class="line">    <span class="string">"no-cond-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件表达式中使用赋值语句</span></div><div class="line">    <span class="string">"no-console"</span>: <span class="number">2</span>,<span class="comment">//禁止使用console</span></div><div class="line">    <span class="string">"no-const-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止修改const声明的变量</span></div><div class="line">    <span class="string">"no-constant-condition"</span>: <span class="number">2</span>,<span class="comment">//禁止在条件中使用常量表达式 if(true) if(1)</span></div><div class="line">    <span class="string">"no-continue"</span>: <span class="number">0</span>,<span class="comment">//禁止使用continue</span></div><div class="line">    <span class="string">"no-control-regex"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式中使用控制字符</span></div><div class="line">    <span class="string">"no-debugger"</span>: <span class="number">2</span>,<span class="comment">//禁止使用debugger</span></div><div class="line">    <span class="string">"no-delete-var"</span>: <span class="number">2</span>,<span class="comment">//不能对var声明的变量使用delete操作符</span></div><div class="line">    <span class="string">"no-div-regex"</span>: <span class="number">1</span>,<span class="comment">//不能使用看起来像除法的正则表达式/=foo/</span></div><div class="line">    <span class="string">"no-dupe-keys"</span>: <span class="number">2</span>,<span class="comment">//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span></div><div class="line">    <span class="string">"no-dupe-args"</span>: <span class="number">2</span>,<span class="comment">//函数参数不能重复</span></div><div class="line">    <span class="string">"no-duplicate-case"</span>: <span class="number">2</span>,<span class="comment">//switch中的case标签不能重复</span></div><div class="line">    <span class="string">"no-else-return"</span>: <span class="number">2</span>,<span class="comment">//如果if语句里面有return,后面不能跟else语句</span></div><div class="line">    <span class="string">"no-empty"</span>: <span class="number">0</span>,<span class="comment">//块语句中的内容不能为空</span></div><div class="line">    <span class="string">"no-empty-character-class"</span>: <span class="number">2</span>,<span class="comment">//正则表达式中的[]内容不能为空</span></div><div class="line">    <span class="string">"no-eq-null"</span>: <span class="number">2</span>,<span class="comment">//禁止对null使用==或!=运算符</span></div><div class="line">    <span class="string">"no-eval"</span>: <span class="number">1</span>,<span class="comment">//禁止使用eval</span></div><div class="line">    <span class="string">"no-ex-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止给catch语句中的异常参数赋值</span></div><div class="line">    <span class="string">"no-extend-native"</span>: <span class="number">2</span>,<span class="comment">//禁止扩展native对象</span></div><div class="line">    <span class="string">"no-extra-bind"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的函数绑定</span></div><div class="line">    <span class="string">"no-extra-boolean-cast"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的bool转换</span></div><div class="line">    <span class="string">"no-extra-parens"</span>: <span class="number">2</span>,<span class="comment">//禁止非必要的括号</span></div><div class="line">    <span class="string">"no-extra-semi"</span>: <span class="number">2</span>,<span class="comment">//禁止多余的冒号</span></div><div class="line">    <span class="string">"no-fallthrough"</span>: <span class="number">1</span>,<span class="comment">//禁止switch穿透</span></div><div class="line">    <span class="string">"no-floating-decimal"</span>: <span class="number">2</span>,<span class="comment">//禁止省略浮点数中的0 .5 3.</span></div><div class="line">    <span class="string">"no-func-assign"</span>: <span class="number">2</span>,<span class="comment">//禁止重复的函数声明</span></div><div class="line">    <span class="string">"no-implicit-coercion"</span>: <span class="number">1</span>,<span class="comment">//禁止隐式转换</span></div><div class="line">    <span class="string">"no-implied-eval"</span>: <span class="number">2</span>,<span class="comment">//禁止使用隐式eval</span></div><div class="line">    <span class="string">"no-inline-comments"</span>: <span class="number">0</span>,<span class="comment">//禁止行内备注</span></div><div class="line">    <span class="string">"no-inner-declarations"</span>: [<span class="number">2</span>, <span class="string">"functions"</span>],<span class="comment">//禁止在块语句中使用声明（变量或函数）</span></div><div class="line">    <span class="string">"no-invalid-regexp"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的正则表达式</span></div><div class="line">    <span class="string">"no-invalid-this"</span>: <span class="number">2</span>,<span class="comment">//禁止无效的this，只能用在构造器，类，对象字面量</span></div><div class="line">    <span class="string">"no-irregular-whitespace"</span>: <span class="number">2</span>,<span class="comment">//不能有不规则的空格</span></div><div class="line">    <span class="string">"no-iterator"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__iterator__ 属性</span></div><div class="line">    <span class="string">"no-label-var"</span>: <span class="number">2</span>,<span class="comment">//label名不能与var声明的变量名相同</span></div><div class="line">    <span class="string">"no-labels"</span>: <span class="number">0</span>,<span class="comment">//禁止标签声明</span></div><div class="line">    <span class="string">"no-lone-blocks"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套块</span></div><div class="line">    <span class="string">"no-lonely-if"</span>: <span class="number">2</span>,<span class="comment">//禁止else语句内只有if语句</span></div><div class="line">    <span class="string">"no-loop-func"</span>: <span class="number">1</span>,<span class="comment">//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span></div><div class="line">    <span class="string">"no-mixed-requires"</span>: [<span class="number">0</span>, <span class="literal">false</span>],<span class="comment">//声明时不能混用声明类型</span></div><div class="line">    <span class="string">"no-mixed-spaces-and-tabs"</span>: [<span class="number">2</span>, <span class="literal">false</span>],<span class="comment">//禁止混用tab和空格</span></div><div class="line">    <span class="string">"linebreak-style"</span>: [<span class="number">0</span>, <span class="string">"windows"</span>],<span class="comment">//换行风格</span></div><div class="line">    <span class="string">"no-multi-spaces"</span>: <span class="number">0</span>,<span class="comment">//不能用多余的空格</span></div><div class="line">    <span class="string">"no-multi-str"</span>: <span class="number">2</span>,<span class="comment">//字符串不能用\换行</span></div><div class="line">    <span class="string">"no-multiple-empty-lines"</span>: [<span class="number">1</span>, &#123;<span class="string">"max"</span>: <span class="number">3</span>&#125;],<span class="comment">//空行最多不能超过2行</span></div><div class="line">    <span class="string">"no-native-reassign"</span>: <span class="number">2</span>,<span class="comment">//不能重写native对象</span></div><div class="line">    <span class="string">"no-negated-in-lhs"</span>: <span class="number">2</span>,<span class="comment">//in 操作符的左边不能有!</span></div><div class="line">    <span class="string">"no-nested-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用嵌套的三目运算</span></div><div class="line">    <span class="string">"no-new"</span>: <span class="number">1</span>,<span class="comment">//禁止在使用new构造一个实例后不赋值</span></div><div class="line">    <span class="string">"no-new-func"</span>: <span class="number">1</span>,<span class="comment">//禁止使用new Function</span></div><div class="line">    <span class="string">"no-new-object"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new Object()</span></div><div class="line">    <span class="string">"no-new-require"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new require</span></div><div class="line">    <span class="string">"no-new-wrappers"</span>: <span class="number">2</span>,<span class="comment">//禁止使用new创建包装实例，new String new Boolean new Number</span></div><div class="line">    <span class="string">"no-obj-calls"</span>: <span class="number">2</span>,<span class="comment">//不能调用内置的全局对象，比如Math() JSON()</span></div><div class="line">    <span class="string">"no-octal"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制数字</span></div><div class="line">    <span class="string">"no-octal-escape"</span>: <span class="number">2</span>,<span class="comment">//禁止使用八进制转义序列</span></div><div class="line">    <span class="string">"no-param-reassign"</span>: <span class="number">2</span>,<span class="comment">//禁止给参数重新赋值</span></div><div class="line">    <span class="string">"no-path-concat"</span>: <span class="number">0</span>,<span class="comment">//node中不能使用__dirname或__filename做路径拼接</span></div><div class="line">    <span class="string">"no-plusplus"</span>: <span class="number">0</span>,<span class="comment">//禁止使用++，--</span></div><div class="line">    <span class="string">"no-process-env"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.env</span></div><div class="line">    <span class="string">"no-process-exit"</span>: <span class="number">0</span>,<span class="comment">//禁止使用process.exit()</span></div><div class="line">    <span class="string">"no-proto"</span>: <span class="number">2</span>,<span class="comment">//禁止使用__proto__属性</span></div><div class="line">    <span class="string">"no-redeclare"</span>: <span class="number">2</span>,<span class="comment">//禁止重复声明变量</span></div><div class="line">    <span class="string">"no-regex-spaces"</span>: <span class="number">2</span>,<span class="comment">//禁止在正则表达式字面量中使用多个空格 /foo bar/</span></div><div class="line">    <span class="string">"no-restricted-modules"</span>: <span class="number">0</span>,<span class="comment">//如果禁用了指定模块，使用就会报错</span></div><div class="line">    <span class="string">"no-return-assign"</span>: <span class="number">1</span>,<span class="comment">//return 语句中不能有赋值表达式</span></div><div class="line">    <span class="string">"no-script-url"</span>: <span class="number">0</span>,<span class="comment">//禁止使用javascript:void(0)</span></div><div class="line">    <span class="string">"no-self-compare"</span>: <span class="number">2</span>,<span class="comment">//不能比较自身</span></div><div class="line">    <span class="string">"no-sequences"</span>: <span class="number">0</span>,<span class="comment">//禁止使用逗号运算符</span></div><div class="line">    <span class="string">"no-shadow"</span>: <span class="number">2</span>,<span class="comment">//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span></div><div class="line">    <span class="string">"no-shadow-restricted-names"</span>: <span class="number">2</span>,<span class="comment">//严格模式中规定的限制标识符不能作为声明时的变量名使用</span></div><div class="line">    <span class="string">"no-spaced-func"</span>: <span class="number">2</span>,<span class="comment">//函数调用时 函数名与()之间不能有空格</span></div><div class="line">    <span class="string">"no-sparse-arrays"</span>: <span class="number">2</span>,<span class="comment">//禁止稀疏数组， [1,,2]</span></div><div class="line">    <span class="string">"no-sync"</span>: <span class="number">0</span>,<span class="comment">//nodejs 禁止同步方法</span></div><div class="line">    <span class="string">"no-ternary"</span>: <span class="number">0</span>,<span class="comment">//禁止使用三目运算符</span></div><div class="line">    <span class="string">"no-trailing-spaces"</span>: <span class="number">1</span>,<span class="comment">//一行结束后面不要有空格</span></div><div class="line">    <span class="string">"no-this-before-super"</span>: <span class="number">0</span>,<span class="comment">//在调用super()之前不能使用this或super</span></div><div class="line">    <span class="string">"no-throw-literal"</span>: <span class="number">2</span>,<span class="comment">//禁止抛出字面量错误 throw "error";</span></div><div class="line">    <span class="string">"no-undef"</span>: <span class="number">2</span>,<span class="comment">//不能有未定义的变量</span></div><div class="line">    <span class="string">"no-undef-init"</span>: <span class="number">2</span>,<span class="comment">//变量初始化时不能直接给它赋值为undefined</span></div><div class="line">    <span class="string">"no-undefined"</span>: <span class="number">2</span>,<span class="comment">//不能使用undefined</span></div><div class="line">    <span class="string">"no-unexpected-multiline"</span>: <span class="number">2</span>,<span class="comment">//避免多行表达式</span></div><div class="line">    <span class="string">"no-underscore-dangle"</span>: <span class="number">1</span>,<span class="comment">//标识符不能以_开头或结尾</span></div><div class="line">    <span class="string">"no-unneeded-ternary"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span></div><div class="line">    <span class="string">"no-unreachable"</span>: <span class="number">2</span>,<span class="comment">//不能有无法执行的代码</span></div><div class="line">    <span class="string">"no-unused-expressions"</span>: <span class="number">2</span>,<span class="comment">//禁止无用的表达式</span></div><div class="line">    <span class="string">"no-unused-vars"</span>: [<span class="number">2</span>, &#123;<span class="string">"vars"</span>: <span class="string">"all"</span>, <span class="string">"args"</span>: <span class="string">"after-used"</span>&#125;],<span class="comment">//不能有声明后未被使用的变量或参数</span></div><div class="line">    <span class="string">"no-use-before-define"</span>: <span class="number">2</span>,<span class="comment">//未定义前不能使用</span></div><div class="line">    <span class="string">"no-useless-call"</span>: <span class="number">2</span>,<span class="comment">//禁止不必要的call和apply</span></div><div class="line">    <span class="string">"no-void"</span>: <span class="number">2</span>,<span class="comment">//禁用void操作符</span></div><div class="line">    <span class="string">"no-var"</span>: <span class="number">0</span>,<span class="comment">//禁用var，用let和const代替</span></div><div class="line">    <span class="string">"no-warning-comments"</span>: [<span class="number">1</span>, &#123; <span class="string">"terms"</span>: [<span class="string">"todo"</span>, <span class="string">"fixme"</span>, <span class="string">"xxx"</span>], <span class="string">"location"</span>: <span class="string">"start"</span> &#125;],<span class="comment">//不能有警告备注</span></div><div class="line">    <span class="string">"no-with"</span>: <span class="number">2</span>,<span class="comment">//禁用with</span></div><div class="line"></div><div class="line">    <span class="string">"array-bracket-spacing"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//是否允许非空数组里面有多余的空格</span></div><div class="line">    <span class="string">"arrow-parens"</span>: <span class="number">0</span>,<span class="comment">//箭头函数用小括号括起来</span></div><div class="line">    <span class="string">"arrow-spacing"</span>: <span class="number">0</span>,<span class="comment">//=&gt;的前/后括号</span></div><div class="line">    <span class="string">"accessor-pairs"</span>: <span class="number">0</span>,<span class="comment">//在对象中使用getter/setter</span></div><div class="line">    <span class="string">"block-scoped-var"</span>: <span class="number">0</span>,<span class="comment">//块语句中使用var</span></div><div class="line">    <span class="string">"brace-style"</span>: [<span class="number">1</span>, <span class="string">"1tbs"</span>],<span class="comment">//大括号风格</span></div><div class="line">    <span class="string">"callback-return"</span>: <span class="number">1</span>,<span class="comment">//避免多次调用回调什么的</span></div><div class="line">    <span class="string">"camelcase"</span>: <span class="number">2</span>,<span class="comment">//强制驼峰法命名</span></div><div class="line">    <span class="string">"comma-dangle"</span>: [<span class="number">2</span>, <span class="string">"never"</span>],<span class="comment">//对象字面量项尾不能有逗号</span></div><div class="line">    <span class="string">"comma-spacing"</span>: <span class="number">0</span>,<span class="comment">//逗号前后的空格</span></div><div class="line">    <span class="string">"comma-style"</span>: [<span class="number">2</span>, <span class="string">"last"</span>],<span class="comment">//逗号风格，换行时在行首还是行尾</span></div><div class="line">    <span class="string">"complexity"</span>: [<span class="number">0</span>, <span class="number">11</span>],<span class="comment">//循环复杂度</span></div><div class="line">    <span class="string">"computed-property-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//是否允许计算后的键名什么的</span></div><div class="line">    <span class="string">"consistent-return"</span>: <span class="number">0</span>,<span class="comment">//return 后面是否允许省略</span></div><div class="line">    <span class="string">"consistent-this"</span>: [<span class="number">2</span>, <span class="string">"that"</span>],<span class="comment">//this别名</span></div><div class="line">    <span class="string">"constructor-super"</span>: <span class="number">0</span>,<span class="comment">//非派生类不能调用super，派生类必须调用super</span></div><div class="line">    <span class="string">"curly"</span>: [<span class="number">2</span>, <span class="string">"all"</span>],<span class="comment">//必须使用 if()&#123;&#125; 中的&#123;&#125;</span></div><div class="line">    <span class="string">"default-case"</span>: <span class="number">2</span>,<span class="comment">//switch语句最后必须有default</span></div><div class="line">    <span class="string">"dot-location"</span>: <span class="number">0</span>,<span class="comment">//对象访问符的位置，换行的时候在行首还是行尾</span></div><div class="line">    <span class="string">"dot-notation"</span>: [<span class="number">0</span>, &#123; <span class="string">"allowKeywords"</span>: <span class="literal">true</span> &#125;],<span class="comment">//避免不必要的方括号</span></div><div class="line">    <span class="string">"eol-last"</span>: <span class="number">0</span>,<span class="comment">//文件以单一的换行符结束</span></div><div class="line">    <span class="string">"eqeqeq"</span>: <span class="number">0</span>,<span class="comment">//必须使用全等</span></div><div class="line">    <span class="string">"func-names"</span>: <span class="number">0</span>,<span class="comment">//函数表达式必须有名字</span></div><div class="line">    <span class="string">"func-style"</span>: [<span class="number">0</span>, <span class="string">"declaration"</span>],<span class="comment">//函数风格，规定只能使用函数声明/函数表达式</span></div><div class="line">    <span class="string">"generator-star-spacing"</span>: <span class="number">0</span>,<span class="comment">//生成器函数*的前后空格</span></div><div class="line">    <span class="string">"guard-for-in"</span>: <span class="number">0</span>,<span class="comment">//for in循环要用if语句过滤</span></div><div class="line">    <span class="string">"handle-callback-err"</span>: <span class="number">0</span>,<span class="comment">//nodejs 处理错误</span></div><div class="line">    <span class="string">"id-length"</span>: <span class="number">0</span>,<span class="comment">//变量名长度</span></div><div class="line">    <span class="string">"indent"</span>: [<span class="number">2</span>, <span class="number">2</span>],<span class="comment">//缩进风格</span></div><div class="line">    <span class="string">"init-declarations"</span>: <span class="number">0</span>,<span class="comment">//声明时必须赋初值</span></div><div class="line">    <span class="string">"key-spacing"</span>: [<span class="number">0</span>, &#123; <span class="string">"beforeColon"</span>: <span class="literal">false</span>, <span class="string">"afterColon"</span>: <span class="literal">true</span> &#125;],<span class="comment">//对象字面量中冒号的前后空格</span></div><div class="line">    <span class="string">"lines-around-comment"</span>: <span class="number">0</span>,<span class="comment">//行前/行后备注</span></div><div class="line">    <span class="string">"max-depth"</span>: [<span class="number">0</span>, <span class="number">4</span>],<span class="comment">//嵌套块深度</span></div><div class="line">    <span class="string">"max-len"</span>: [<span class="number">0</span>, <span class="number">80</span>, <span class="number">4</span>],<span class="comment">//字符串最大长度</span></div><div class="line">    <span class="string">"max-nested-callbacks"</span>: [<span class="number">0</span>, <span class="number">2</span>],<span class="comment">//回调嵌套深度</span></div><div class="line">    <span class="string">"max-params"</span>: [<span class="number">0</span>, <span class="number">3</span>],<span class="comment">//函数最多只能有3个参数</span></div><div class="line">    <span class="string">"max-statements"</span>: [<span class="number">0</span>, <span class="number">10</span>],<span class="comment">//函数内最多有几个声明</span></div><div class="line">    <span class="string">"new-cap"</span>: <span class="number">2</span>,<span class="comment">//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span></div><div class="line">    <span class="string">"new-parens"</span>: <span class="number">2</span>,<span class="comment">//new时必须加小括号</span></div><div class="line">    <span class="string">"newline-after-var"</span>: <span class="number">2</span>,<span class="comment">//变量声明后是否需要空一行</span></div><div class="line">    <span class="string">"object-curly-spacing"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//大括号内是否允许不必要的空格</span></div><div class="line">    <span class="string">"object-shorthand"</span>: <span class="number">0</span>,<span class="comment">//强制对象字面量缩写语法</span></div><div class="line">    <span class="string">"one-var"</span>: <span class="number">1</span>,<span class="comment">//连续声明</span></div><div class="line">    <span class="string">"operator-assignment"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//赋值运算符 += -=什么的</span></div><div class="line">    <span class="string">"operator-linebreak"</span>: [<span class="number">2</span>, <span class="string">"after"</span>],<span class="comment">//换行时运算符在行尾还是行首</span></div><div class="line">    <span class="string">"padded-blocks"</span>: <span class="number">0</span>,<span class="comment">//块语句内行首行尾是否要空行</span></div><div class="line">    <span class="string">"prefer-const"</span>: <span class="number">0</span>,<span class="comment">//首选const</span></div><div class="line">    <span class="string">"prefer-spread"</span>: <span class="number">0</span>,<span class="comment">//首选展开运算</span></div><div class="line">    <span class="string">"prefer-reflect"</span>: <span class="number">0</span>,<span class="comment">//首选Reflect的方法</span></div><div class="line">    <span class="string">"quotes"</span>: [<span class="number">0</span>, <span class="string">"single"</span>],<span class="comment">//引号类型 `` "" ''</span></div><div class="line">    <span class="string">"quote-props"</span>:[<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//对象字面量中的属性名是否强制双引号</span></div><div class="line">    <span class="string">"radix"</span>: <span class="number">2</span>,<span class="comment">//parseInt必须指定第二个参数</span></div><div class="line">    <span class="string">"id-match"</span>: <span class="number">0</span>,<span class="comment">//命名检测</span></div><div class="line">    <span class="string">"require-yield"</span>: <span class="number">0</span>,<span class="comment">//生成器函数必须有yield</span></div><div class="line">    <span class="string">"semi"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//语句强制分号结尾</span></div><div class="line">    <span class="string">"semi-spacing"</span>: [<span class="number">0</span>, &#123;<span class="string">"before"</span>: <span class="literal">false</span>, <span class="string">"after"</span>: <span class="literal">false</span>&#125;],<span class="comment">//分号前后空格</span></div><div class="line">    <span class="string">"sort-vars"</span>: <span class="number">0</span>,<span class="comment">//变量声明时排序</span></div><div class="line">    <span class="string">"space-after-keywords"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//关键字后面是否要空一格</span></div><div class="line">    <span class="string">"space-before-blocks"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//不以新行开始的块&#123;前面要不要有空格</span></div><div class="line">    <span class="string">"space-before-function-paren"</span>: [<span class="number">0</span>, <span class="string">"always"</span>],<span class="comment">//函数定义时括号前面要不要有空格</span></div><div class="line">    <span class="string">"space-in-parens"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],<span class="comment">//小括号里面要不要有空格</span></div><div class="line">    <span class="string">"space-infix-ops"</span>: <span class="number">0</span>,<span class="comment">//中缀操作符周围要不要有空格</span></div><div class="line">    <span class="string">"space-unary-ops"</span>: [<span class="number">0</span>, &#123; <span class="string">"words"</span>: <span class="literal">true</span>, <span class="string">"nonwords"</span>: <span class="literal">false</span> &#125;],<span class="comment">//一元运算符的前/后要不要加空格</span></div><div class="line">    <span class="string">"spaced-comment"</span>: <span class="number">0</span>,<span class="comment">//注释风格要不要有空格什么的</span></div><div class="line">    <span class="string">"strict"</span>: <span class="number">2</span>,<span class="comment">//使用严格模式</span></div><div class="line">    <span class="string">"use-isnan"</span>: <span class="number">2</span>,<span class="comment">//禁止比较时使用NaN，只能用isNaN()</span></div><div class="line">    <span class="string">"valid-jsdoc"</span>: <span class="number">0</span>,<span class="comment">//jsdoc规则</span></div><div class="line">    <span class="string">"valid-typeof"</span>: <span class="number">2</span>,<span class="comment">//必须使用合法的typeof的值</span></div><div class="line">    <span class="string">"vars-on-top"</span>: <span class="number">2</span>,<span class="comment">//var必须放在作用域顶部</span></div><div class="line">    <span class="string">"wrap-iife"</span>: [<span class="number">2</span>, <span class="string">"inside"</span>],<span class="comment">//立即执行函数表达式的小括号风格</span></div><div class="line">    <span class="string">"wrap-regex"</span>: <span class="number">0</span>,<span class="comment">//正则表达式字面量用小括号包起来</span></div><div class="line">    <span class="string">"yoda"</span>: [<span class="number">2</span>, <span class="string">"never"</span>]<span class="comment">//禁止尤达条件</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/09/17/深入理解javascript/48对象创建模式（下篇）/"><span>揭秘命名函数表达式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/17/深入理解javascript/48对象创建模式（下篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-17T15:02:02.000Z">
          2016-09-17
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本篇主要是介绍创建对象方面的模式的下篇，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。</p>
<h2 id="模式-6：函数语法糖"><a href="#模式-6：函数语法糖" class="headerlink" title="模式 6：函数语法糖"></a>模式 6：函数语法糖</h2><p>函数语法糖是为一个对象快速添加方法（函数）的扩展，这个主要是利用 prototype 的特性，代码比较简单，我们先来看一下实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (typeof Function.prototype.method !== &quot;function&quot;) &#123;</div><div class="line">    Function.prototype.method = function (name, implementation) &#123;</div><div class="line">        this.prototype[name] = implementation;</div><div class="line">        return this;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>扩展对象的时候，可以这么用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Person = function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">&#125;</div><div class="line">.method(&apos;getName&apos;,</div><div class="line">            function () &#123;</div><div class="line">                return this.name;</div><div class="line">            &#125;)</div><div class="line">.method(&apos;setName&apos;, function (name) &#123;</div><div class="line">    this.name = name;</div><div class="line">    return this;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这样就给 Person 函数添加了 getName 和 setName 这 2 个方法，接下来我们来验证一下结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = new Person(&apos;Adam&apos;);</div><div class="line">console.log(a.getName()); // &apos;Adam&apos;</div><div class="line">console.log(a.setName(&apos;Eve&apos;).getName()); // &apos;Eve&apos;</div></pre></td></tr></table></figure>
<h2 id="模式-7：对象常量"><a href="#模式-7：对象常量" class="headerlink" title="模式 7：对象常量"></a>模式 7：对象常量</h2><p>对象常量是在一个对象提供 set，get，ifDefined 各种方法的体现，而且对于 set 的方法只会保留最先设置的对象，后期再设置都是无效的，已达到别人无法重载的目的。实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">var constant = (function () &#123;</div><div class="line">    var constants = &#123;&#125;,</div><div class="line">        ownProp = Object.prototype.hasOwnProperty,</div><div class="line">    // 只允许设置这三种类型的值</div><div class="line">        allowed = &#123;</div><div class="line">            string: 1,</div><div class="line">            number: 1,</div><div class="line">            boolean: 1</div><div class="line">        &#125;,</div><div class="line">        prefix = (Math.random() + &quot;_&quot;).slice(2);  </div><div class="line">    return &#123;</div><div class="line">        // 设置名称为name的属性</div><div class="line">        set: function (name, value) &#123;</div><div class="line">            if (this.isDefined(name)) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            if (!ownProp.call(allowed, typeof value)) &#123;</div><div class="line">                return false;</div><div class="line">            &#125;</div><div class="line">            constants[prefix + name] = value;</div><div class="line">            return true;</div><div class="line">        &#125;,</div><div class="line">        // 判断是否存在名称为name的属性</div><div class="line">        isDefined: function (name) &#123;</div><div class="line">            return ownProp.call(constants, prefix + name);</div><div class="line">        &#125;,</div><div class="line">        // 获取名称为name的属性</div><div class="line">        get: function (name) &#123;</div><div class="line">            if (this.isDefined(name)) &#123;</div><div class="line">                return constants[prefix + name];</div><div class="line">            &#125;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p>验证代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 检查是否存在</div><div class="line">console.log(constant.isDefined(&quot;maxwidth&quot;)); // false  </div><div class="line">// 定义</div><div class="line">console.log(constant.set(&quot;maxwidth&quot;, 480)); // true  </div><div class="line">// 重新检测</div><div class="line">console.log(constant.isDefined(&quot;maxwidth&quot;)); // true  </div><div class="line">// 尝试重新定义</div><div class="line">console.log(constant.set(&quot;maxwidth&quot;, 320)); // false  </div><div class="line">// 判断原先的定义是否还存在</div><div class="line">console.log(constant.get(&quot;maxwidth&quot;)); // 480</div></pre></td></tr></table></figure>
<h2 id="模式-8：沙盒模式"><a href="#模式-8：沙盒模式" class="headerlink" title="模式 8：沙盒模式"></a>模式 8：沙盒模式</h2><p>沙盒（Sandbox）模式即时为一个或多个模块提供单独的上下文环境，而不会影响其他模块的上下文环境，比如有个 Sandbox 里有 3 个方法event，dom，ajax，在调用其中 2 个组成一个环境的话，和调用三个组成的环境完全没有干扰。Sandbox 实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">function Sandbox() &#123;</div><div class="line">    // 将参数转为数组</div><div class="line">    var args = Array.prototype.slice.call(arguments),</div><div class="line">    // 最后一个参数为callback</div><div class="line">        callback = args.pop(),</div><div class="line">        // 除最后一个参数外，其它均为要选择的模块</div><div class="line">        modules = (args[0] &amp;&amp; typeof args[0] === &quot;string&quot;) ? args : args[0],</div><div class="line">        i;  </div><div class="line">    // 强制使用new操作符</div><div class="line">    if (!(this instanceof Sandbox)) &#123;</div><div class="line">        return new Sandbox(modules, callback);</div><div class="line">    &#125;  </div><div class="line">    // 添加属性</div><div class="line">    this.a = 1;</div><div class="line">    this.b = 2;  </div><div class="line">    // 向this对象上需想添加模块</div><div class="line">    // 如果没有模块或传入的参数为 &quot;*&quot; ，则以为着传入所有模块</div><div class="line">    if (!modules || modules == &apos;*&apos;) &#123;</div><div class="line">        modules = [];</div><div class="line">        for (i in Sandbox.modules) &#123;</div><div class="line">            if (Sandbox.modules.hasOwnProperty(i)) &#123;</div><div class="line">                modules.push(i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;  </div><div class="line">    // 初始化需要的模块</div><div class="line">    for (i = 0; i &lt; modules.length; i += 1) &#123;</div><div class="line">        Sandbox.modules[modules[i]](this);</div><div class="line">    &#125;</div><div class="line">    // 调用 callback</div><div class="line">    callback(this);</div><div class="line">&#125;  </div><div class="line">// 默认添加原型对象</div><div class="line">Sandbox.prototype = &#123;</div><div class="line">    name: &quot;My Application&quot;,</div><div class="line">    version: &quot;1.0&quot;,</div><div class="line">    getName: function () &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后我们再定义默认的初始模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Sandbox.modules = &#123;&#125;;  </div><div class="line">Sandbox.modules.dom = function (box) &#123;</div><div class="line">    box.getElement = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    box.getStyle = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    box.foo = &quot;bar&quot;;</div><div class="line">&#125;;  </div><div class="line">Sandbox.modules.event = function (box) &#123;</div><div class="line">    // access to the Sandbox prototype if needed:</div><div class="line">    // box.constructor.prototype.m = &quot;mmm&quot;;</div><div class="line">    box.attachEvent = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    box.detachEvent = function () &#123;</div><div class="line">    &#125;;</div><div class="line">&#125;;  </div><div class="line">Sandbox.modules.ajax = function (box) &#123;</div><div class="line">    box.makeRequest = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    box.getResponse = function () &#123;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>调用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 调用方式</div><div class="line">Sandbox([&apos;ajax&apos;, &apos;event&apos;], function (box) &#123;</div><div class="line">    console.log(typeof (box.foo));</div><div class="line">    // 没有选择dom，所以box.foo不存在</div><div class="line">&#125;);  </div><div class="line">Sandbox(&apos;ajax&apos;, &apos;dom&apos;, function (box) &#123;</div><div class="line">    console.log(typeof (box.attachEvent));</div><div class="line">    // 没有选择event,所以event里定义的attachEvent也不存在</div><div class="line">&#125;);  </div><div class="line">Sandbox(&apos;*&apos;, function (box) &#123;</div><div class="line">    console.log(box); // 上面定义的所有方法都可访问</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>通过三个不同的调用方式，我们可以看到，三种方式的上下文环境都是不同的，第一种里没有 foo；而第二种则没有 attachEvent，因为只加载了 ajax 和 dom，而没有加载 event；第三种则加载了全部。</p>
<h2 id="模式-9：静态成员"><a href="#模式-9：静态成员" class="headerlink" title="模式 9：静态成员"></a>模式 9：静态成员</h2><p>静态成员（Static Members）只是一个函数或对象提供的静态属性，可分为私有的和公有的，就像 C#或 Java 里的 public static 和 private static 一样。</p>
<p>我们先来看一下公有成员，公有成员非常简单，我们平时声明的方法，函数都是公有的，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 构造函数</div><div class="line">var Gadget = function () &#123;</div><div class="line">&#125;;  </div><div class="line">// 公有静态方法</div><div class="line">Gadget.isShiny = function () &#123;</div><div class="line">    return &quot;you bet&quot;;</div><div class="line">&#125;;  </div><div class="line">// 原型上添加的正常方法</div><div class="line">Gadget.prototype.setPrice = function (price) &#123;</div><div class="line">    this.price = price;</div><div class="line">&#125;;  </div><div class="line">// 调用静态方法</div><div class="line">console.log(Gadget.isShiny()); // &quot;you bet&quot;  </div><div class="line">// 创建实例，然后调用方法</div><div class="line">var iphone = new Gadget();</div><div class="line">iphone.setPrice(500);  </div><div class="line">console.log(typeof Gadget.setPrice); // &quot;undefined&quot;</div><div class="line">console.log(typeof iphone.isShiny); // &quot;undefined&quot;</div><div class="line">Gadget.prototype.isShiny = Gadget.isShiny;</div><div class="line">console.log(iphone.isShiny()); // &quot;you bet&quot;</div></pre></td></tr></table></figure>
<p>而私有静态成员，我们可以利用其闭包特性去实现，以下是两种实现方式。</p>
<h3 id="第一种实现方式："><a href="#第一种实现方式：" class="headerlink" title="第一种实现方式："></a>第一种实现方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Gadget = (function () &#123;</div><div class="line">    // 静态变量/属性</div><div class="line">    var counter = 0;  </div><div class="line">    // 闭包返回构造函数的新实现</div><div class="line">    return function () &#123;</div><div class="line">        console.log(counter += 1);</div><div class="line">    &#125;;</div><div class="line">&#125; ()); // 立即执行  </div><div class="line">var g1 = new Gadget(); // logs 1</div><div class="line">var g2 = new Gadget(); // logs 2</div><div class="line">var g3 = new Gadget(); // logs 3</div></pre></td></tr></table></figure>
<p>可以看出，虽然每次都是 new 的对象，但数字依然是递增的，达到了静态成员的目的。</p>
<h3 id="第二种方式："><a href="#第二种方式：" class="headerlink" title="第二种方式："></a>第二种方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var Gadget = (function () &#123;</div><div class="line">    // 静态变量/属性</div><div class="line">    var counter = 0,</div><div class="line">        NewGadget;  </div><div class="line">    //新构造函数实现</div><div class="line">    NewGadget = function () &#123;</div><div class="line">        counter += 1;</div><div class="line">   &#125;;  </div><div class="line">    // 授权可以访问的方法</div><div class="line">    NewGadget.prototype.getLastId = function () &#123;</div><div class="line">        return counter;</div><div class="line">    &#125;;  </div><div class="line">    // 覆盖构造函数</div><div class="line">    return NewGadget;</div><div class="line">&#125; ()); // 立即执行  </div><div class="line">var iphone = new Gadget();</div><div class="line">iphone.getLastId(); // 1</div><div class="line">var ipod = new Gadget();</div><div class="line">ipod.getLastId(); // 2</div><div class="line">var ipad = new Gadget();</div><div class="line">ipad.getLastId(); // 3</div></pre></td></tr></table></figure>
<p>数字也是递增了，这是利用其内部授权方法的闭包特性实现的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是对象创建模式的下篇，两篇一起总共9种模式，是我们在日常 JavaScript 编程中经常使用的对象创建模式，不同的场景起到了不同的作用，希望大家根据各自的需求选择适用的模式。</p>
<h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/09/11/深入理解javascript/47对象创建模式（上篇）/"><span>对象创建模式（上篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/09/11/深入理解javascript/47对象创建模式（上篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-09-11T03:02:02.000Z">
          2016-09-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本篇主要是介绍创建对象方面的模式，利用各种技巧可以极大地避免了错误或者可以编写出非常精简的代码。</p>
<h2 id="模式-1：命名空间（namespace）"><a href="#模式-1：命名空间（namespace）" class="headerlink" title="模式 1：命名空间（namespace）"></a>模式 1：命名空间（namespace）</h2><p>命名空间可以减少全局命名所需的数量，避免命名冲突或过度。一般我们在进行对象层级定义的时候，经常是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var app = app || &#123;&#125;;</div><div class="line">app.moduleA = app.moduleA || &#123;&#125;;</div><div class="line">app.moduleA.subModule = app.moduleA.subModule || &#123;&#125;;</div><div class="line">app.moduleA.subModule.MethodA = function () &#123;</div><div class="line">    console.log(&quot;print A&quot;);</div><div class="line">&#125;;</div><div class="line">app.moduleA.subModule.MethodB = function () &#123;</div><div class="line">    console.log(&quot;print B&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果层级很多的话，那就要一直这样继续下去，很是混乱。namespace 模式就是为了解决这个问题而存在的，我们看代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// 不安全，可能会覆盖已有的MYAPP对象</div><div class="line">var MYAPP = &#123;&#125;;</div><div class="line">// 还好</div><div class="line">if (typeof MYAPP === &quot;undefined&quot;) &#123;</div><div class="line">    var MYAPP = &#123;&#125;;</div><div class="line">&#125;</div><div class="line">// 更简洁的方式</div><div class="line">var MYAPP = MYAPP || &#123;&#125;;  </div><div class="line">//定义通用方法</div><div class="line">MYAPP.namespace = function (ns_string) &#123;</div><div class="line">    var parts = ns_string.split(&apos;.&apos;),</div><div class="line">        parent = MYAPP,</div><div class="line">        i;  </div><div class="line">    // 默认如果第一个节点是MYAPP的话，就忽略掉，比如MYAPP.ModuleA</div><div class="line">    if (parts[0] === &quot;MYAPP&quot;) &#123;</div><div class="line">        parts = parts.slice(1);</div><div class="line">    &#125;  </div><div class="line">    for (i = 0; i &lt; parts.length; i += 1) &#123;</div><div class="line">        // 如果属性不存在，就创建</div><div class="line">        if (typeof parent[parts[i]] === &quot;undefined&quot;) &#123;</div><div class="line">            parent[parts[i]] = &#123;&#125;;</div><div class="line">        &#125;</div><div class="line">        parent = parent[parts[i]];</div><div class="line">    &#125;</div><div class="line">    return parent;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>调用代码，非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 通过namespace以后，可以将返回值赋给一个局部变量</div><div class="line">var module2 = MYAPP.namespace(&apos;MYAPP.modules.module2&apos;);</div><div class="line">console.log(module2 === MYAPP.modules.module2); // true  </div><div class="line">// 跳过MYAPP</div><div class="line">MYAPP.namespace(&apos;modules.module51&apos;);  </div><div class="line">// 非常长的名字</div><div class="line">MYAPP.namespace(&apos;once.upon.a.time.there.was.this.long.nested.property&apos;);</div></pre></td></tr></table></figure>
<h2 id="模式-2：定义依赖"><a href="#模式-2：定义依赖" class="headerlink" title="模式 2：定义依赖"></a>模式 2：定义依赖</h2><p>有时候你的一个模块或者函数可能要引用第三方的一些模块或者工具，这时候最好将这些依赖模块在刚开始的时候就定义好，以便以后可以很方便地替换掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var myFunction = function () &#123;</div><div class="line">    // 依赖模块</div><div class="line">    var event = YAHOO.util.Event,</div><div class="line">        dom = YAHOO.util.dom;  </div><div class="line">    // 其它函数后面的代码里使用局部变量event和dom</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="模式-3：私有属性和私有方法"><a href="#模式-3：私有属性和私有方法" class="headerlink" title="模式 3：私有属性和私有方法"></a>模式 3：私有属性和私有方法</h2><p>JavaScript 本书不提供特定的语法来支持私有属性和私有方法，但是我们可以通过闭包来实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function Gadget() &#123;</div><div class="line">    // 私有对象</div><div class="line">    var name = &apos;iPod&apos;;</div><div class="line">    // 公有函数</div><div class="line">    this.getName = function () &#123;</div><div class="line">        return name;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var toy = new Gadget();  </div><div class="line">// name未定义，是私有的</div><div class="line">console.log(toy.name); // undefined  </div><div class="line">// 公有方法访问name</div><div class="line">console.log(toy.getName()); // &quot;iPod&quot;  </div><div class="line">var myobj; // 通过自执行函数给myobj赋值</div><div class="line">(function () &#123;</div><div class="line">    // 自由对象</div><div class="line">    var name = &quot;my, oh my&quot;;  </div><div class="line">    // 实现了公有部分，所以没有var</div><div class="line">    myobj = &#123;</div><div class="line">        // 授权方法</div><div class="line">        getName: function () &#123;</div><div class="line">            return name;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<h2 id="模式-4：Revelation模式"><a href="#模式-4：Revelation模式" class="headerlink" title="模式 4：Revelation模式"></a>模式 4：Revelation模式</h2><p>也是关于隐藏私有方法的模式，和<a href="http://www.cnblogs.com/TomXu/archive/2011/12/30/2288372.html" target="_blank" rel="external">《深入理解JavaScript系列（3）：全面解析Module模式》</a>里的 Module 模式有点类似，但是不是 return 的方式，而是在外部先声明一个变量，然后在内部给变量赋值公有方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">var myarray;</div><div class="line">(function () &#123;</div><div class="line">    var astr = &quot;[object Array]&quot;,</div><div class="line">        toString = Object.prototype.toString;  </div><div class="line">    function isArray(a) &#123;</div><div class="line">        return toString.call(a) === astr;</div><div class="line">    &#125;  </div><div class="line">    function indexOf(haystack, needle) &#123;</div><div class="line">        var i = 0,</div><div class="line">            max = haystack.length;</div><div class="line">        for (; i &lt; max; i += 1) &#123;</div><div class="line">            if (haystack[i] === needle) &#123;</div><div class="line">                return i;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return -1;</div><div class="line">    &#125;  </div><div class="line">    //通过赋值的方式，将上面所有的细节都隐藏了</div><div class="line">    myarray = &#123;</div><div class="line">        isArray: isArray,</div><div class="line">        indexOf: indexOf,</div><div class="line">        inArray: indexOf</div><div class="line">    &#125;;</div><div class="line">&#125; ());  </div><div class="line">//测试代码</div><div class="line">console.log(myarray.isArray([1, 2])); // true</div><div class="line">console.log(myarray.isArray(&#123; 0: 1 &#125;)); // false</div><div class="line">console.log(myarray.indexOf([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2</div><div class="line">console.log(myarray.inArray([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2  </div><div class="line">myarray.indexOf = null;</div><div class="line">console.log(myarray.inArray([&quot;a&quot;, &quot;b&quot;, &quot;z&quot;], &quot;z&quot;)); // 2</div></pre></td></tr></table></figure>
<h2 id="模式-5：链模式"><a href="#模式-5：链模式" class="headerlink" title="模式 5：链模式"></a>模式 5：链模式</h2><p>链模式可以你连续可以调用一个对象的方法，比如 obj.add(1).remove(2).delete(4).add(2)这样的形式，其实现思路非常简单，就是将 this 原样返回。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">    value: 1,</div><div class="line">    increment: function () &#123;</div><div class="line">        this.value += 1;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    add: function (v) &#123;</div><div class="line">        this.value += v;</div><div class="line">        return this;</div><div class="line">    &#125;,</div><div class="line">    shout: function () &#123;</div><div class="line">        console.log(this.value);</div><div class="line">    &#125;</div><div class="line">&#125;;  </div><div class="line">// 链方法调用</div><div class="line">obj.increment().add(3).shout(); // 5  </div><div class="line">// 也可以单独一个一个调用</div><div class="line">obj.increment();</div><div class="line">obj.add(3);</div><div class="line">obj.shout();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇是对象创建模式的上篇，敬请期待明天的下篇。</p>
<h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/08/26/深入理解javascript/50Function 模式（下篇）/"><span>Function 模式（下篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/26/深入理解javascript/50Function 模式（下篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-26T08:56:02.000Z">
          2016-08-26
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本篇我们介绍的一些模式称为初始化模式和性能模式，主要是用在初始化以及提高性能方面，一些模式之前已经提到过，这里只是做一下总结。</p>
<h2 id="立即执行的函数"><a href="#立即执行的函数" class="headerlink" title="立即执行的函数"></a>立即执行的函数</h2><p>在本系列第 4 篇的<a href="http://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html" target="_blank" rel="external">《立即调用的函数表达式》中</a>，我们已经对类似的函数进行过详细的描述，这里我们只是再举两个简单的例子做一下总结。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 声明完函数以后，立即执行该函数</div><div class="line">(function () &#123;</div><div class="line">    console.log(&apos;watch out!&apos;);</div><div class="line">&#125; ());  </div><div class="line">//这种方式声明的函数，也可以立即执行</div><div class="line">!function () &#123;</div><div class="line">    console.log(&apos;watch out!&apos;);</div><div class="line">&#125; ();  </div><div class="line">// 如下方式也都可以哦</div><div class="line">~function () &#123; /* code */ &#125; ();</div><div class="line">-function () &#123; /* code */ &#125; ();</div><div class="line">+function () &#123; /* code */ &#125; ();</div></pre></td></tr></table></figure>
<h2 id="立即执行的对象初始化"><a href="#立即执行的对象初始化" class="headerlink" title="立即执行的对象初始化"></a>立即执行的对象初始化</h2><p>该模式的意思是指在声明一个对象（而非函数）的时候，立即执行对象里的某一个方法来进行初始化工作，通常该模式可以用在一次性执行的代码上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">(&#123;</div><div class="line">    // 这里你可以定义常量，设置其它值</div><div class="line">    maxwidth: 600,</div><div class="line">    maxheight: 400,  </div><div class="line">    //  当然也可以定义utility方法</div><div class="line">    gimmeMax: function () &#123;</div><div class="line">        return this.maxwidth + &quot;x&quot; + this.maxheight;</div><div class="line">    &#125;,  </div><div class="line">    // 初始化</div><div class="line">    init: function () &#123;</div><div class="line">        console.log(this.gimmeMax());</div><div class="line">        // 更多代码...</div><div class="line">    &#125;</div><div class="line">&#125;).init();  // 这样就开始初始化咯</div></pre></td></tr></table></figure>
<h2 id="分支初始化"><a href="#分支初始化" class="headerlink" title="分支初始化"></a>分支初始化</h2><p>分支初始化是指在初始化的时候，根据不同的条件（场景）初始化不同的代码，也就是所谓的条件语句赋值。之前我们在做事件处理的时候，通常使用类似下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var utils = &#123;</div><div class="line">    addListener: function (el, type, fn) &#123;</div><div class="line">        if (typeof window.addEventListener === &apos;function&apos;) &#123;</div><div class="line">            el.addEventListener(type, fn, false);</div><div class="line">        &#125; else if (typeof document.attachEvent !== &apos;undefined&apos;) &#123;</div><div class="line">            el.attachEvent(&apos;on&apos; + type, fn);</div><div class="line">        &#125; else &#123;</div><div class="line">            el[&apos;on&apos; + type] = fn;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    removeListener: function (el, type, fn) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们来改进一下，首先我们要定义两个接口，一个用来add事件句柄，一个用来 remove 事件句柄，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var utils = &#123;</div><div class="line">    addListener: null,</div><div class="line">    removeListener: null</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">if (typeof window.addEventListener === &apos;function&apos;) &#123;</div><div class="line">    utils.addListener = function (el, type, fn) &#123;</div><div class="line">        el.addEventListener(type, fn, false);</div><div class="line">    &#125;;</div><div class="line">&#125; else if (typeof document.attachEvent !== &apos;undefined&apos;) &#123; // IE</div><div class="line">    utils.addListener = function (el, type, fn) &#123;</div><div class="line">        el.attachEvent(&apos;on&apos; + type, fn);</div><div class="line">    &#125;;</div><div class="line">    utils.removeListener = function (el, type, fn) &#123;</div><div class="line">        el.detachEvent(&apos;on&apos; + type, fn);</div><div class="line">    &#125;;</div><div class="line">&#125; else &#123; // 其它旧浏览器</div><div class="line">    utils.addListener = function (el, type, fn) &#123;</div><div class="line">        el[&apos;on&apos; + type] = fn;</div><div class="line">    &#125;;</div><div class="line">    utils.removeListener = function (el, type, fn) &#123;</div><div class="line">        el[&apos;on&apos; + type] = null;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用起来，是不是就很方便了？代码也优雅多了。</p>
<h2 id="自声明函数"><a href="#自声明函数" class="headerlink" title="自声明函数"></a>自声明函数</h2><p>一般是在函数内部，重写同名函数代码，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var scareMe = function () &#123;</div><div class="line">    alert(&quot;Boo!&quot;);</div><div class="line">    scareMe = function () &#123;</div><div class="line">        alert(&quot;Double boo!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种代码，非常容易使人迷惑，我们先来看看例子的执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 1. 添加新属性</div><div class="line">scareMe.property = &quot;properly&quot;;</div><div class="line">// 2. scareMe赋与一个新值</div><div class="line">var prank = scareMe;</div><div class="line">// 3. 作为一个方法调用</div><div class="line">var spooky = &#123;</div><div class="line">    boo: scareMe</div><div class="line">&#125;;</div><div class="line">// 使用新变量名称进行调用</div><div class="line">prank(); // &quot;Boo!&quot;</div><div class="line">prank(); // &quot;Boo!&quot;</div><div class="line">console.log(prank.property); // &quot;properly&quot;</div><div class="line">// 使用方法进行调用</div><div class="line">spooky.boo(); // &quot;Boo!&quot;</div><div class="line">spooky.boo(); // &quot;Boo!&quot;</div><div class="line">console.log(spooky.boo.property); // &quot;properly&quot;</div></pre></td></tr></table></figure>
<p>通过执行结果，可以发现，将定于的函数赋值与新变量（或内部方法），代码并不执行重载的 scareMe 代码，而如下例子则正好相反：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 使用自声明函数</div><div class="line">scareMe(); // Double boo!</div><div class="line">scareMe(); // Double boo!</div><div class="line">console.log(scareMe.property); // undefined</div></pre></td></tr></table></figure>
<p>大家使用这种模式时，一定要非常小心才行，否则实际结果很可能和你期望的结果不一样，当然你也可以利用这个特殊做一些特殊的操作。</p>
<h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><p>该模式主要是利用函数的属性特性来避免大量的重复计算。通常代码形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myFunc = function (param) &#123;</div><div class="line">    if (!myFunc.cache[param]) &#123;</div><div class="line">        var result = &#123;&#125;;</div><div class="line">        // ... 复杂操作 ...</div><div class="line">        myFunc.cache[param] = result;</div><div class="line">    &#125;</div><div class="line">    return myFunc.cache[param];</div><div class="line">&#125;;</div><div class="line">// cache 存储</div><div class="line">myFunc.cache = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>但是上述代码有个问题，如果传入的参数是 toString 或者其它类似 Object 拥有的一些公用方法的话，就会出现问题，这时候就需要使用传说中的 hasOwnProperty 方法了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var myFunc = function (param) &#123;</div><div class="line">    if (!myFunc.cache.hasOwnProperty(param)) &#123;</div><div class="line">        var result = &#123;&#125;;</div><div class="line">        // ... 复杂操作 ...</div><div class="line">        myFunc.cache[param] = result;</div><div class="line">    &#125;</div><div class="line">    return myFunc.cache[param];</div><div class="line">&#125;;  </div><div class="line">// cache 存储</div><div class="line">myFunc.cache = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>或者如果你传入的参数是多个的话，可以将这些参数通过 JSON 的 stringify 方法生产一个 cachekey 值进行存储，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var myFunc = function () &#123;</div><div class="line">    var cachekey = JSON.stringify(Array.prototype.slice.call(arguments)),</div><div class="line">        result;</div><div class="line">    if (!myFunc.cache[cachekey]) &#123;</div><div class="line">        result = &#123;&#125;;</div><div class="line">        // ... 复杂操作 ...</div><div class="line">        myFunc.cache[cachekey] = result;</div><div class="line">    &#125;</div><div class="line">    return myFunc.cache[cachekey];</div><div class="line">&#125;;  </div><div class="line">// cache 存储</div><div class="line">myFunc.cache = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>或者多个参数的话，也可以利用 arguments.callee 特性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var myFunc = function (param) &#123;</div><div class="line">    var f = arguments.callee,</div><div class="line">        result;</div><div class="line">    if (!f.cache[param]) &#123;</div><div class="line">        result = &#123;&#125;;</div><div class="line">        // ... 复杂操作 ...</div><div class="line">        f.cache[param] = result;</div><div class="line">    &#125;</div><div class="line">    return f.cache[param];</div><div class="line">&#125;;  </div><div class="line">// cache 存储</div><div class="line">myFunc.cache = &#123;&#125;;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>就不用总结了吧，大家仔细看代码就行咯</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/08/23/深入理解javascript/8S.O.L.I.D 五大原则之里氏替换原则 LSP/"><span>S.O.L.I.D 五大原则之里氏替换原则 LSP</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/23/深入理解javascript/8S.O.L.I.D 五大原则之里氏替换原则 LSP/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-23T04:02:02.000Z">
          2016-08-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第3篇，里氏替换原则 LSP（The Liskov Substitution Principle ）。</p>
<p>开闭原则的描述是：</p>
<blockquote>
<p>Subtypes must be substitutable for their base types.<br>派生类型必须可以替换它的基类型。</p>
</blockquote>
<p>在面向对象编程里，继承提供了一个机制让子类和共享基类的代码，这是通过在基类型里封装通用的数据和行为来实现的，然后已经及类型来声明更详细的子类型，为了应用里氏替换原则，继承子类型需要在语义上等价于基类型里的期望行为。</p>
<p>为了来更好的理解，请参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">function Vehicle(my) &#123;</div><div class="line">    var my = my || &#123;&#125;;</div><div class="line">    my.speed = 0;</div><div class="line">    my.running = false;</div><div class="line">    this.speed = function() &#123;</div><div class="line">        return my.speed;</div><div class="line">    &#125;;</div><div class="line">    this.start = function() &#123;</div><div class="line">        my.running = true;</div><div class="line">    &#125;;</div><div class="line">    this.stop = function() &#123;</div><div class="line">        my.running = false;</div><div class="line">    &#125;;</div><div class="line">    this.accelerate = function() &#123;</div><div class="line">        my.speed++;</div><div class="line">    &#125;;</div><div class="line">    this.decelerate = function() &#123;</div><div class="line">        my.speed--;</div><div class="line">    &#125;, this.state = function() &#123;</div><div class="line">        if (!my.running) &#123;</div><div class="line">            return &quot;parked&quot;;</div><div class="line">        &#125;</div><div class="line">        else if (my.running &amp;&amp; my.speed) &#123;</div><div class="line">            return &quot;moving&quot;;</div><div class="line">        &#125;</div><div class="line">        else if (my.running) &#123;</div><div class="line">            return &quot;idle&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码我们定义了一个 Vehicle 函数，其构造函数为 vehicle 对象提供了一些基本的操作，我们来想想如果当前函数当前正运行在服务客户的产品环境上，如果现在需要添加一个新的构造函数来实现加快移动的 vehicle。思考以后，我们写出了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function FastVehicle(my) &#123;</div><div class="line">    var my = my || &#123;&#125;;</div><div class="line">    var that = new Vehicle(my);</div><div class="line">    that.accelerate = function() &#123;</div><div class="line">        my.speed += 3;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在浏览器的控制台我们都测试了，所有的功能都是我们的预期，没有问题，FastVehicle 的速度增快了 3 倍，而且继承他的方法也是按照我们的预期工作。此后，我们开始部署这个新版本的类库到产品环境上，可是我们却接到了新的构造函数导致现有的代码不能支持执行了，下面的代码段揭示了这个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var maneuver = function(vehicle) &#123;</div><div class="line">    write(vehicle.state());</div><div class="line">    vehicle.start();</div><div class="line">    write(vehicle.state());</div><div class="line">    vehicle.accelerate();</div><div class="line">    write(vehicle.state());</div><div class="line">    write(vehicle.speed());</div><div class="line">    vehicle.decelerate();</div><div class="line">    write(vehicle.speed());</div><div class="line">    if (vehicle.state() != &quot;idle&quot;) &#123;</div><div class="line">        throw &quot;The vehicle is still moving!&quot;;</div><div class="line">    &#125;</div><div class="line">    vehicle.stop();</div><div class="line">    write(vehicle.state());</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>根据上面的代码，我们看到抛出的异常是“The vehicle is still moving!”，这是因为写这段代码的作者一直认为加速（accelerate）和减速（decelerate）的数字是一样的。但 FastVehicle 的代码和 Vehicle 的代码并不是完全能够替换掉的。因此，FastVehicle 违反了里氏替换原则。</p>
<p>在这点上，你可能会想：“但，客户端不能老假定 vehicle 都是按照这样的规则来做”，里氏替换原则(LSP)的妨碍（译者注：就是妨碍实现 LSP 的代码）不是基于我们所想的继承子类应该在行为里确保更新代码，而是这样的更新是否能在当前的期望中得到实现。</p>
<p>上述代码这个 case，解决这个不兼容的问题需要在 vehicle 类库或者客户端调用代码上进行一点重新设计，或者两者都要改。</p>
<h2 id="减少-LSP-妨碍"><a href="#减少-LSP-妨碍" class="headerlink" title="减少 LSP 妨碍"></a>减少 LSP 妨碍</h2><p>那么，我们如何避免 LSP 妨碍？不幸的话，并不是一直都是可以做到的。我们这里有几个策略我们处理这个事情。</p>
<h3 id="契约（Contracts）"><a href="#契约（Contracts）" class="headerlink" title="契约（Contracts）"></a>契约（Contracts）</h3><p>处理 LSP 过分妨碍的一个策略是使用契约，契约清单有 2 种形式：执行说明书（executable specifications）和错误处理，在执行说明书里，一个详细类库的契约也包括一组自动化测试，而错误处理是在代码里直接处理的，例如在前置条件，后置条件，常量检查等，可以从 Bertrand Miller 的大作<a href="http://en.wikipedia.org/wiki/Design_by_contract" target="_blank" rel="external">《契约设计》</a>中查看这个技术。虽然自动化测试和契约设计不在本篇文字的范围内，但当我们用的时候我还是推荐如下内容：</p>
<ol>
<li>检查使用测试驱动开发（Test-Driven Development）来指导你代码的设计</li>
<li>设计可重用类库的时候可随意使用契约设计技术</li>
</ol>
<p>对于你自己要维护和实现的代码，使用契约设计趋向于添加很多不必要的代码，如果你要控制输入，添加测试是非常有必要的，如果你是类库作者，使用契约设计，你要注意不正确的使用方法以及让你的用户使之作为一个测试工具。</p>
<h3 id="避免继承"><a href="#避免继承" class="headerlink" title="避免继承"></a>避免继承</h3><p>避免 LSP 妨碍的另外一个测试是：如果可能的话，尽量不用继承，在Gamma的大作<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="external">《Design Patterns – Elements of Reusable Object-Orineted Software》</a>中，我们可以看到如下建议：</p>
<blockquote>
<p>Favor object composition over class inheritance<br>尽量使用对象组合而不是类继承</p>
</blockquote>
<p>有些书里讨论了组合比继承好的唯一作用是静态类型，基于类的语言（例如，在运行时可以改变行为），与 JavaScript 相关的一个问题是耦合，当使用继承的时候，继承子类型和他们的基类型耦合在一起了，就是说基类型的改变会影响到继承子类型。组合倾向于对象更小化，更容易向静态和动态语言语言维护。</p>
<h2 id="与行为有关，而不是继承"><a href="#与行为有关，而不是继承" class="headerlink" title="与行为有关，而不是继承"></a>与行为有关，而不是继承</h2><p>到现在，我们讨论了和继承上下文在内的里氏替换原则，指示出 JavaScript 的面向对象实。不过，里氏替换原则（LSP）的本质不是真的和继承有关，而是行为兼容性。JavaScript 是一个动态语言，一个对象的契约行为不是对象的类型决定的，而是对象期望的功能决定的。里氏替换原则的初始构想是作为继承的一个原则指南，等价于对象设计中的隐式接口。</p>
<p>举例来说，让我们来看一下 Robert C. Martin的 大作<a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="external">《敏捷软件开发 原则、模式与实践》</a>中的一个矩形类型：</p>
<h3 id="矩形例子"><a href="#矩形例子" class="headerlink" title="矩形例子"></a>矩形例子</h3><p>考虑我们有一个程序用到下面这样的一个矩形对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var rectangle = &#123;</div><div class="line">    length: 0,</div><div class="line">    width: 0</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>过后，程序有需要一个正方形，由于正方形就是一个长(length)和宽(width)都一样的特殊矩形，所以我们觉得创建一个正方形代替矩形。我们添加了 length 和 width 属性来匹配矩形的声明，但我们觉得使用属性的g etters/setters 一般我们可以让 length 和 width 保存同步，确保声明的是一个正方形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var square = &#123;&#125;;</div><div class="line">(function() &#123;</div><div class="line">    var length = 0, width = 0;</div><div class="line">    // 注意defineProperty方式是262-5版的新特性</div><div class="line">    Object.defineProperty(square, &quot;length&quot;, &#123;</div><div class="line">        get: function() &#123; return length; &#125;,</div><div class="line">        set: function(value) &#123; length = width = value; &#125;</div><div class="line">    &#125;);</div><div class="line">    Object.defineProperty(square, &quot;width&quot;, &#123;</div><div class="line">        get: function() &#123; return width; &#125;,</div><div class="line">        set: function(value) &#123; length = width = value; &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>不幸的是，当我们使用正方形代替矩形执行代码的时候发现了问题，其中一个计算矩形面积的方法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var g = function(rectangle) &#123;</div><div class="line">    rectangle.length = 3;</div><div class="line">    rectangle.width = 4;</div><div class="line">    write(rectangle.length);</div><div class="line">    write(rectangle.width);</div><div class="line">    write(rectangle.length * rectangle.width);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该方法在调用的时候，结果是 16，而不是期望的 12，我们的正方形 square 对象违反了 LSP 原则，square 的长度和宽度属性暗示着并不是和矩形 100% 兼容，但我们并不总是这样明确的暗示。解决这个问题，我们可以重新设计一个 shape 对象来实现程序，依据多边形的概念，我们声明 rectangle 和square，relevant。不管怎么说，我们的目的是要说里氏替换原则并不只是继承，而是任何方法（其中的行为可以另外的行为）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里氏替换原则（LSP）表达的意思不是继承的关系，而是任何方法（只要该方法的行为能体会另外的行为就行）。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/08/02/深入理解javascript/49Function 模式（上篇）/"><span>Function 模式（上篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/08/02/深入理解javascript/49Function 模式（上篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-08-02T09:02:02.000Z">
          2016-08-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本篇主要是介绍 Function 方面使用的一些技巧（上篇），利用 Function 特性可以编写出很多非常有意思的代码，本篇主要包括：回调模式、配置对象、返回函数、分布程序、柯里化（Currying）。</p>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>在 JavaScript 中，当一个函数 A 作为另外一个函数 B 的其中一个参数时，则函数 A 称为回调函数，即 A 可以在函数 B 的周期内执行（开始、中间、结束时均可）。</p>
<p>举例来说，有一个函数用于生成 node</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var complexComputation = function () &#123; /* 内部处理，并返回一个node*/&#125;;</div><div class="line">有一个findNodes函数声明用于查找所有的节点，然后通过callback回调进行执行代码。  </div><div class="line">var findNodes = function (callback) &#123;</div><div class="line">var nodes = [];  </div><div class="line">var node = complexComputation();  </div><div class="line">// 如果回调函数可用，则执行它</div><div class="line">if (typeof callback === &quot;function&quot;) &#123;</div><div class="line">callback(node);</div><div class="line">&#125;  </div><div class="line">nodes.push(node);</div><div class="line">return nodes;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>关于 callback 的定义，我们可以事先定义好来用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 定义callback</div><div class="line">var hide = function (node) &#123;</div><div class="line">node.style.display = &quot;none&quot;;</div><div class="line">&#125;; </div><div class="line">// 查找node，然后隐藏所有的node</div><div class="line">var hiddenNodes = findNodes(hide);</div><div class="line">也可以直接在调用的时候使用匿名定义，如下：  </div><div class="line">// 使用匿名函数定义callback</div><div class="line">var blockNodes = findNodes(function (node) &#123;</div><div class="line">node.style.display = &apos;block&apos;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>我们平时用的最多的，估计就数 jQuery 的 ajax 方法的调用了，通过在 done/faild 上定义 callback，以便在 ajax 调用成功或者失败的时候做进一步处理，代码如下(本代码基于 jquery1.8 版)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var menuId = $(&quot;ul.nav&quot;).first().attr(&quot;id&quot;);</div><div class="line">var request = $.ajax(&#123;</div><div class="line">  url: &quot;script.php&quot;,</div><div class="line">  type: &quot;POST&quot;,</div><div class="line">  data: &#123;id : menuId&#125;,</div><div class="line">  dataType: &quot;html&quot;</div><div class="line">&#125;);  </div><div class="line">//调用成功时的回调处理</div><div class="line">request.done(function(msg) &#123;</div><div class="line">  $(&quot;#log&quot;).html( msg );</div><div class="line">&#125;);  </div><div class="line">//调用失败时的回调处理</div><div class="line">request.fail(function(jqXHR, textStatus) &#123;</div><div class="line">  alert( &quot;Request failed: &quot; + textStatus );</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="配置对象"><a href="#配置对象" class="headerlink" title="配置对象"></a>配置对象</h2><p>如果一个函数（或方法）的参数只有一个参数，并且参数为对象字面量，我们则称这种模式为配置对象模式。例如，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var conf = &#123;</div><div class="line">    username:&quot;shichuan&quot;,</div><div class="line">    first:&quot;Chuan&quot;,</div><div class="line">    last:&quot;Shi&quot;</div><div class="line">&#125;;</div><div class="line">addPerson(conf);</div></pre></td></tr></table></figure>
<p>则在 addPerson 内部，就可以随意使用 conf 的值了，一般用于初始化工作，例如 jquery 里的 ajaxSetup 也就是这种方式来实现的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 事先设置好初始值</div><div class="line">$.ajaxSetup(&#123;</div><div class="line">   url: &quot;/xmlhttp/&quot;,</div><div class="line">   global: false,</div><div class="line">   type: &quot;POST&quot;</div><div class="line"> &#125;);  </div><div class="line">// 然后再调用</div><div class="line"> $.ajax(&#123; data: myData &#125;);</div></pre></td></tr></table></figure>
<p>另外，很多 jquery 的插件也有这种形式的传参，只不过也可以不传，不传的时候则就使用默认值了。</p>
<h2 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h2><p>返回函数，则是指在一个函数的返回值为另外一个函数，或者根据特定的条件灵活创建的新函数，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var setup = function () &#123;</div><div class="line">    console.log(1);</div><div class="line">    return function () &#123;</div><div class="line">        console.log(2);</div><div class="line">    &#125;;</div><div class="line">&#125;;  </div><div class="line">// 调用setup 函数</div><div class="line">var my = setup(); // 输出 1</div><div class="line">my(); // 输出 2</div><div class="line">// 或者直接调用也可</div><div class="line">setup()();</div></pre></td></tr></table></figure>
<p>或者你可以利用闭包的特性，在 setup 函数里记录一个私有的计数器数字，通过每次调用来增加计数器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var setup = function () &#123;</div><div class="line">    var count = 0;</div><div class="line">    return function () &#123;</div><div class="line">        return ++count;</div><div class="line">    &#125;;</div><div class="line">&#125;;   </div><div class="line">// 用法</div><div class="line">var next = setup();</div><div class="line">next(); // 返回 1</div><div class="line">next(); // 返回 2</div><div class="line">next(); // 返回 3</div></pre></td></tr></table></figure>
<h2 id="偏应用"><a href="#偏应用" class="headerlink" title="偏应用"></a>偏应用</h2><p>这里的偏应用，其实是将参数的传入工作分开进行，在有的时候一系列的操作可能会有某一个或几个参数始终完全一样，那么我们就可以先定义一个偏函数，然后再去执行这个函数（执行时传入剩余的不同参数）。</p>
<p>举个例子，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var partialAny = (function (aps) &#123;</div><div class="line">    // 该函数是你们自执行函数表达式的结果，并且赋值给了partialAny变量</div><div class="line">    function func(fn) &#123;</div><div class="line">        var argsOrig = aps.call(arguments, 1);</div><div class="line">        return function () &#123;</div><div class="line">            var args = [],</div><div class="line">                argsPartial = aps.call(arguments),</div><div class="line">                i = 0;  </div><div class="line">            // 变量所有的原始参数集，</div><div class="line">            // 如果参数是partialAny._ 占位符，则使用下一个函数参数对应的值</div><div class="line">            // 否则使用原始参数里的值</div><div class="line">            for (; i &lt; argsOrig.length; i++) &#123;</div><div class="line">                args[i] = argsOrig[i] === func._</div><div class="line">                            ? argsPartial.shift()</div><div class="line">                            : argsOrig[i];</div><div class="line">            &#125;  </div><div class="line">            // 如果有任何多余的参数，则添加到尾部</div><div class="line">            return fn.apply(this, args.concat(argsPartial));</div><div class="line">        &#125;;</div><div class="line">    &#125;  </div><div class="line">    // 用于占位符设置</div><div class="line">    func._ = &#123;&#125;;  </div><div class="line">    return func;</div><div class="line">&#125;)(Array.prototype.slice);</div></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 定义处理函数</div><div class="line">function hex(r, g, b) &#123;</div><div class="line">    return &apos;#&apos; + r + g + b;</div><div class="line">&#125;  </div><div class="line">//定义偏函数, 将hex的第一个参数r作为不变的参数值ff</div><div class="line">var redMax = partialAny(hex, &apos;ff&apos;, partialAny._, partialAny._);  </div><div class="line">// 新函数redMax的调用方式如下，只需要传入2个参数了：</div><div class="line">console.log(redMax(&apos;11&apos;, &apos;22&apos;)); // &quot;#ff1122&quot;</div></pre></td></tr></table></figure>
<p>如果觉得 partialAny._太长，可以用__代替哦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var __ = partialAny._;</div><div class="line">var greenMax = partialAny(hex, __, &apos;ff&apos;);</div><div class="line">console.log(greenMax(&apos;33&apos;, &apos;44&apos;));</div><div class="line">var blueMax = partialAny(hex, __, __, &apos;ff&apos;);</div><div class="line">console.log(blueMax(&apos;55&apos;, &apos;66&apos;));</div><div class="line">var magentaMax = partialAny(hex, &apos;ff&apos;, __, &apos;ff&apos;);</div><div class="line">console.log(magentaMax(&apos;77&apos;));</div></pre></td></tr></table></figure>
<p>这样使用，就简洁多了吧。</p>
<h2 id="Currying"><a href="#Currying" class="headerlink" title="Currying"></a>Currying</h2><p>Currying 是函数式编程的一个特性，将多个参数的处理转化成单个参数的处理，类似链式调用。</p>
<p>举一个简单的 add 函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function add(x, y) &#123;</div><div class="line">    var oldx = x, oldy = y;</div><div class="line">    if (typeof oldy === &quot;undefined&quot;) &#123; // partial</div><div class="line">        return function (newy) &#123;</div><div class="line">            return oldx + newy;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return x + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样调用方式就可以有多种了，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 测试</div><div class="line">typeof add(5); // &quot;function&quot;</div><div class="line">add(3)(4); // 7  </div><div class="line">// 也可以这样调用</div><div class="line">var add2000 = add(2000);</div><div class="line">add2000(10); // 2010</div></pre></td></tr></table></figure>
<p>接下来，我们来定义一个比较通用的 currying 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 第一个参数为要应用的function，第二个参数是需要传入的最少参数个数</div><div class="line">function curry(func, minArgs) &#123;</div><div class="line">    if (minArgs == undefined) &#123;</div><div class="line">        minArgs = 1;</div><div class="line">    &#125;  </div><div class="line">    function funcWithArgsFrozen(frozenargs) &#123;</div><div class="line">        return function () &#123;</div><div class="line">            // 优化处理，如果调用时没有参数，返回该函数本身</div><div class="line">            var args = Array.prototype.slice.call(arguments);</div><div class="line">            var newArgs = frozenargs.concat(args);</div><div class="line">            if (newArgs.length &gt;= minArgs) &#123;</div><div class="line">                return func.apply(this, newArgs);</div><div class="line">            &#125; else &#123;</div><div class="line">                return funcWithArgsFrozen(newArgs);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;  </div><div class="line">    return funcWithArgsFrozen([]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们就可以随意定义我们的业务行为了，比如定义加法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var plus = curry(function () &#123;</div><div class="line">    var result = 0;</div><div class="line">    for (var i = 0; i &lt; arguments.length; ++i) &#123;</div><div class="line">        result += arguments[i];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;, 2);</div></pre></td></tr></table></figure>
<p>使用方式，真实多种多样哇。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">plus(3, 2) // 正常调用</div><div class="line">plus(3) // 偏应用，返回一个函数（返回值为3+参数值）</div><div class="line">plus(3)(2) // 完整应用（返回5）</div><div class="line">plus()(3)()()(2) // 返回 5</div><div class="line">plus(3, 2, 4, 5) // 可以接收多个参数</div><div class="line">plus(3)(2, 3, 5) // 同理</div></pre></td></tr></table></figure>
<p>如下是减法的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var minus = curry(function (x) &#123;</div><div class="line">    var result = x;</div><div class="line">    for (var i = 1; i &lt; arguments.length; ++i) &#123;</div><div class="line">        result -= arguments[i];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;, 2);</div></pre></td></tr></table></figure>
<p>或者如果你想交换参数的顺序，你可以这样定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var flip = curry(function (func) &#123;</div><div class="line">    return curry(function (a, b) &#123;</div><div class="line">        return func(b, a);</div><div class="line">    &#125;, 2);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 里的 Function 有很多特殊的功效，可以利用闭包以及 arguments 参数特性实现很多不同的技巧，下一篇我们将继续介绍利用 Function 进行初始化的技巧。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/07/16/深入理解javascript/12变量对象（Variable Object）/"><span>变量对象（Variable Object）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/07/16/深入理解javascript/12变量对象（Variable Object）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-07-16T09:06:02.000Z">
          2016-07-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>JavaScript 编程的时候总避免不了声明函数和变量，以成功构建我们的系统，但是解释器是如何并且在什么地方去查找这些函数和变量呢？我们引用这些对象的时候究竟发生了什么？</p>
<p>大多数 ECMAScript 程序员应该都知道变量与执行上下文有密切关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 10; // 全局上下文中的变量</div><div class="line">(function () &#123;</div><div class="line">  var b = 20; // function上下文中的局部变量</div><div class="line">&#125;)();</div><div class="line">alert(a); // 10</div><div class="line">alert(b); // 全局变量 &quot;b&quot; 没有声明</div></pre></td></tr></table></figure>
<p>并且，很多程序员也都知道，当前 ECMAScript 规范指出独立作用域只能通过“函数(function)”代码类型的执行上下文创建。也就是说，相对于 C/C++来说，ECMAScript 里的 for 循环并不能创建一个局部的上下文。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (var k in &#123;a: 1, b: 2&#125;) &#123;</div><div class="line">  alert(k);</div><div class="line">&#125;</div><div class="line">alert(k); // 尽管循环已经结束但变量k依然在当前作用域</div></pre></td></tr></table></figure>
<p>我们来看看一下，我们声明数据的时候到底都发现了什么细节。</p>
<h2 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h2><p>如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。</p>
<blockquote>
<p>变量对象(缩写为 VO)是一个与执行上下文相关的特殊对象，它存储着在上下文中声明的以下内容：</p>
</blockquote>
<ul>
<li>变量 (var, 变量声明)；</li>
<li>函数声明 (FunctionDeclaration, 缩写为 FD)；</li>
<li>函数的形参；</li>
</ul>
<p>举例来说，我们可以用普通的 ECMAScript 对象来表示一个变量对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div></pre></td></tr></table></figure>
<p>就像我们所说的，VO 就是执行上下文的属性(property)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  VO: &#123;</div><div class="line">    // 上下文数据（var, FD, function arguments)</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>只有全局上下文的变量对象允许通过 VO 的属性名称来间接访问(因为在全局上下文里，全局对象自身就是变量对象，稍后会详细介绍)，在其它上下文中是不能直接访问 VO 对象的，因为它只是内部机制的一个实现。</p>
<p>当我们声明一个变量或一个函数的时候，和我们创建 VO 新属性的时候一样没有别的区别（即：有名称以及对应的值）。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = 10;</div><div class="line">function test(x) &#123;</div><div class="line">  var b = 20;</div><div class="line">&#125;;</div><div class="line">test(30);</div></pre></td></tr></table></figure>
<p>对应的变量对象是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 全局上下文的变量对象</div><div class="line">VO(globalContext) = &#123;</div><div class="line">  a: 10,</div><div class="line">  test: &lt;reference to function&gt;</div><div class="line">&#125;;</div><div class="line">// test函数上下文的变量对象</div><div class="line">VO(test functionContext) = &#123;</div><div class="line">  x: 30,</div><div class="line">  b: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在具体实现层面(以及规范中)变量对象只是一个抽象概念。(从本质上说，在具体执行上下文中，VO 名称是不一样的，并且初始结构也不一样。</p>
<h2 id="不同执行上下文中的变量对象"><a href="#不同执行上下文中的变量对象" class="headerlink" title="不同执行上下文中的变量对象"></a>不同执行上下文中的变量对象</h2><p>对于所有类型的执行上下文来说，变量对象的一些操作(如变量初始化)和行为都是共通的。从这个角度来看，把变量对象作为抽象的基本事物来理解更为容易。同样在函数上下文中也定义和变量对象相关的额外内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">抽象变量对象VO (变量初始化过程的一般行为)</div><div class="line">  ║</div><div class="line">  ╠══&gt; 全局上下文变量对象GlobalContextVO</div><div class="line">  ║        (VO === this === global)</div><div class="line">  ║</div><div class="line">  ╚══&gt; 函数上下文变量对象FunctionContextVO</div><div class="line">           (VO === AO, 并且添加了&lt;arguments&gt;和&lt;formal parameters&gt;)</div></pre></td></tr></table></figure>
<p>我们来详细看一下：</p>
<h2 id="全局上下文中的变量对象"><a href="#全局上下文中的变量对象" class="headerlink" title="全局上下文中的变量对象"></a>全局上下文中的变量对象</h2><p>首先，我们要给全局对象一个明确的定义：</p>
<ul>
<li>全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；</li>
<li>这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。</li>
</ul>
<p>全局对象初始创建阶段将 Math、String、Date、parseInt 作为自身属性，等属性初始化，同样也可以有额外创建的其它对象作为属性（其可以指向到全局对象自身）。例如，在 DOM 中，全局对象的 window 属性就可以引用全局对象自身(当然，并不是所有的具体实现都是这样)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">global = &#123;</div><div class="line">  Math: &lt;...&gt;,</div><div class="line">  String: &lt;...&gt;</div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  window: global //引用自身</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当访问全局对象的属性时通常会忽略掉前缀，这是因为全局对象是不能通过名称直接访问的。不过我们依然可以通过全局上下文的 this 来访问全局对象，同样也可以递归引用自身。例如，DOM 中的 window。综上所述，代码可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String(10); // 就是global.String(10);</div><div class="line">// 带有前缀</div><div class="line">window.a = 10; // === global.window.a = 10 === global.a = 10;</div><div class="line">this.b = 20; // global.b = 20;</div></pre></td></tr></table></figure>
<p>因此，回到全局上下文中的变量对象——在这里，变量对象就是全局对象自己：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(globalContext) === global;</div></pre></td></tr></table></figure>
<p>非常有必要要理解上述结论，基于这个原理，在全局上下文中声明的对应，我们才可以间接通过全局对象的属性来访问它（例如，事先不知道变量名称）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = new String(&apos;test&apos;);</div><div class="line">alert(a); // 直接访问，在VO(globalContext)里找到：&quot;test&quot;</div><div class="line">alert(window[&apos;a&apos;]); // 间接通过global访问：global === VO(globalContext): &quot;test&quot;</div><div class="line">alert(a === this.a); // true</div><div class="line">var aKey = &apos;a&apos;;</div><div class="line">alert(window[aKey]); // 间接通过动态属性名称访问：&quot;test&quot;</div></pre></td></tr></table></figure>
<h2 id="函数上下文中的变量对象"><a href="#函数上下文中的变量对象" class="headerlink" title="函数上下文中的变量对象"></a>函数上下文中的变量对象</h2><p>在函数执行上下文中，VO 是不能直接访问的，此时由活动对象(activation object，缩写为 AO)扮演 VO 的角色。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VO(functionContext) === AO;</div></pre></td></tr></table></figure>
<p>活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性的值是 Arguments 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AO = &#123;</div><div class="line">  arguments: &lt;ArgO&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>Arguments 对象是活动对象的一个属性，它包括如下属性：</p>
<ol>
<li>callee — 指向当前函数的引用</li>
<li>length — 真正传递的参数个数</li>
<li>properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes 内部元素的个数等于 arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。</li>
</ol>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function foo(x, y, z) &#123;</div><div class="line">  // 声明的函数参数数量arguments (x, y, z)</div><div class="line">  alert(foo.length); // 3</div><div class="line">  // 真正传进来的参数个数(only x, y)</div><div class="line">  alert(arguments.length); // 2</div><div class="line">  // 参数的callee是函数自身</div><div class="line">  alert(arguments.callee === foo); // true</div><div class="line">  // 参数共享</div><div class="line">  alert(x === arguments[0]); // true</div><div class="line">  alert(x); // 10</div><div class="line">  arguments[0] = 20;</div><div class="line">  alert(x); // 20</div><div class="line">  x = 30;</div><div class="line">  alert(arguments[0]); // 30</div><div class="line">  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的</div><div class="line">  z = 40;</div><div class="line">  alert(arguments[2]); // undefined</div><div class="line">  arguments[2] = 50;</div><div class="line">  alert(z); // 40</div><div class="line">&#125;</div><div class="line">foo(10, 20);</div></pre></td></tr></table></figure>
<p>这个例子的代码，在当前版本的 Google Chrome 浏览器里有一个 bug — 即使没有传递参数 z，z 和 arguments[2]仍然是共享的。</p>
<h2 id="处理上下文代码的-2-个阶段"><a href="#处理上下文代码的-2-个阶段" class="headerlink" title="处理上下文代码的 2 个阶段"></a>处理上下文代码的 2 个阶段</h2><p>现在我们终于到了本文的核心点了。执行上下文的代码被分成两个基本的阶段来处理：</p>
<ol>
<li>进入执行上下文</li>
<li>执行代码</li>
</ol>
<p>变量对象的修改变化与这两个阶段紧密相关。</p>
<p>注：这 2 个阶段的处理是一般行为，和上下文的类型无关（也就是说，在全局上下文和函数上下文中的表现是一样的）。</p>
<h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h2><p>当进入执行上下文(代码执行之前)时，VO 里已经包含了下列属性(前面已经说了)：</p>
<h3 id="函数的所有形参-如果我们是在函数执行上下文中"><a href="#函数的所有形参-如果我们是在函数执行上下文中" class="headerlink" title="函数的所有形参(如果我们是在函数执行上下文中)"></a>函数的所有形参(如果我们是在函数执行上下文中)</h3><p>— 由名称和对应值组成的一个变量对象的属性被创建；没有传递对应参数的话，那么由名称和 undefined 值组成的一种变量对象的属性也将被创建。</p>
<h3 id="所有函数声明-FunctionDeclaration-FD"><a href="#所有函数声明-FunctionDeclaration-FD" class="headerlink" title="所有函数声明(FunctionDeclaration, FD)"></a>所有函数声明(FunctionDeclaration, FD)</h3><p>—由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建；如果变量对象已经存在相同名称的属性，则完全替换这个属性。</p>
<h3 id="所有变量声明-var-VariableDeclaration"><a href="#所有变量声明-var-VariableDeclaration" class="headerlink" title="所有变量声明(var, VariableDeclaration)"></a>所有变量声明(var, VariableDeclaration)</h3><p>— 由名称和对应值（undefined）组成一个变量对象的属性被创建；如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p>
<p>让我们看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function test(a, b) &#123;</div><div class="line">  var c = 10;</div><div class="line">  function d() &#123;&#125;</div><div class="line">  var e = function _e() &#123;&#125;;</div><div class="line">  (function x() &#123;&#125;);</div><div class="line">&#125;</div><div class="line">test(10); // call</div></pre></td></tr></table></figure>
<p>当进入带有参数 10 的 test 函数上下文时，AO 表现为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AO(test) = &#123;</div><div class="line">  a: 10,</div><div class="line">  b: undefined,</div><div class="line">  c: undefined,</div><div class="line">  d: &lt;reference to FunctionDeclaration &quot;d&quot;&gt;</div><div class="line">  e: undefined</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意，AO 里并不包含函数“x”。这是因为“x” 是一个函数表达式(FunctionExpression, 缩写为 FE) 而不是函数声明，函数表达式不会影响 VO。 不管怎样，函数“_e” 同样也是函数表达式，但是就像我们下面将看到的那样，因为它分配给了变量 “e”，所以它可以通过名称“e”来访问。 函数声明 FunctionDeclaration 与函数表达式 FunctionExpression 的不同，将在第 15 章 Functions 进行详细的探讨，也可以参考本系列第 2 章揭秘命名函数表达式来了解。</p>
<p>这之后，将进入处理上下文代码的第二个阶段 — 执行代码。</p>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>这个周期内，AO/VO 已经拥有了属性(不过，并不是所有的属性都有值，大部分属性的值还是系统默认的初始值 undefined )。</p>
<p>还是前面那个例子， AO/VO 在代码解释期间被修改如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO[&apos;c&apos;] = 10;</div><div class="line">AO[&apos;e&apos;] = &lt;reference to FunctionExpression &quot;_e&quot;&gt;;</div></pre></td></tr></table></figure>
<p>再次注意，因为 FunctionExpression“_e”保存到了已声明的变量“e”上，所以它仍然存在于内存中。而 FunctionExpression “x”却不存在于 AO/VO 中，也就是说如果我们想尝试调用“x”函数，不管在函数定义之前还是之后，都会出现一个错误“x is not defined”，未保存的函数表达式只有在它自己的定义或递归中才能被调用。</p>
<p>另一个经典例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">alert(x); // function</div><div class="line">var x = 10;</div><div class="line">alert(x); // 10</div><div class="line">x = 20;</div><div class="line">function x() &#123;&#125;; </div><div class="line">alert(x); // 20</div></pre></td></tr></table></figure>
<p>为什么第一个 alert “x” 的返回值是 function，而且它还是在“x” 声明之前访问的“x” 的？为什么不是 10 或 20 呢？因为，根据规范函数声明是在当<strong>进入上下文</strong>时填入的； 同意周期，在进入上下文的时候还有一个变量声明“x”，那么正如我们在上一个阶段所说，变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个<strong>进入上下文</strong>阶段，变量声明不会干扰VO 中已经存在的同名函数声明或形式参数声明，因此，在进入上下文时，VO 的结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">VO = &#123;&#125;;</div><div class="line">VO[&apos;x&apos;] = &lt;reference to FunctionDeclaration &quot;x&quot;&gt;</div><div class="line">// 找到var x = 10;</div><div class="line">// 如果function &quot;x&quot;没有已经声明的话</div><div class="line">// 这时候&quot;x&quot;的值应该是undefined</div><div class="line">// 但是这个case里变量声明没有影响同名的function的值</div><div class="line">VO[&apos;x&apos;] = &lt;the value is not disturbed, still function&gt;</div></pre></td></tr></table></figure>
<p>紧接着，在执行代码阶段，VO 做如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">VO[&apos;x&apos;] = 10;</div><div class="line">VO[&apos;x&apos;] = 20;</div></pre></td></tr></table></figure>
<p>我们可以在第二、三个 alert 看到这个效果。</p>
<p>在下面的例子里我们可以再次看到，变量是在进入上下文阶段放入 VO 中的。(因为，虽然 else 部分代码永远不会执行，但是不管怎样，变量“b”仍然存在于 VO 中。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  var a = 1;</div><div class="line">&#125; else &#123;</div><div class="line">  var b = 2;</div><div class="line">&#125;</div><div class="line">alert(a); // 1</div><div class="line">alert(b); // undefined,不是b没有声明，而是b的值是undefined</div></pre></td></tr></table></figure>
<h2 id="关于变量"><a href="#关于变量" class="headerlink" title="关于变量"></a>关于变量</h2><p>通常，各类文章和 JavaScript 相关的书籍都声称：“不管是使用 var 关键字(在全局上下文)还是不使用 var 关键字(在任何地方)，都可以声明一个变量”。请记住，这是错误的概念：</p>
<p><code>任何时候，变量只能通过使用 var 关键字才能声明。</code></p>
<p>上面的赋值语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a = 10;</div></pre></td></tr></table></figure>
<p>这仅仅是给全局对象创建了一个新属性(但它不是变量)。“不是变量”并不是说它不能被改变，而是指它不符合 ECMAScript 规范中的变量概念，所以它“不是变量”(它之所以能成为全局对象的属性，完全是因为 VO(globalContext) === global，大家还记得这个吧？)。</p>
<p>让我们通过下面的实例看看具体的区别吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(a); // undefined</div><div class="line">alert(b); // &quot;b&quot; 没有声明</div><div class="line">b = 10;</div><div class="line">var a = 20;</div></pre></td></tr></table></figure>
<p>所有根源仍然是 VO 和进入上下文阶段和代码执行阶段：</p>
<p>进入上下文阶段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">VO = &#123;</div><div class="line">  a: undefined</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以看到，因为“b”不是一个变量，所以在这个阶段根本就没有“b”，“b”将只在代码执行阶段才会出现(但是在我们这个例子里，还没有到那就已经出错了)。</p>
<p>让我们改变一下例子代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(a); // undefined, 这个大家都知道，</div><div class="line">b = 10;</div><div class="line">alert(b); // 10, 代码执行阶段创建</div><div class="line">var a = 20;</div><div class="line">alert(a); // 20, 代码执行阶段修改</div></pre></td></tr></table></figure>
<p>关于变量，还有一个重要的知识点。变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete}，这个特性的含义就是不能用 delete 操作符直接删除变量属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = 10;</div><div class="line">alert(window.a); // 10</div><div class="line">alert(delete a); // true</div><div class="line">alert(window.a); // undefined</div><div class="line">var b = 20;</div><div class="line">alert(window.b); // 20</div><div class="line">alert(delete b); // false</div><div class="line">alert(window.b); // still 20</div></pre></td></tr></table></figure>
<p>但是这个规则在有个上下文里不起走样，那就是 eval 上下文，变量没有{DontDelete}特性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eval(&apos;var a = 10;&apos;);</div><div class="line">alert(window.a); // 10</div><div class="line">alert(delete a); // true</div><div class="line">alert(window.a); // undefined</div></pre></td></tr></table></figure>
<p>使用一些调试工具(例如：Firebug)的控制台测试该实例时，请注意，Firebug 同样是使用 eval 来执行控制台里你的代码。因此，变量属性同样没有{DontDelete}特性，可以被删除。</p>
<h2 id="特殊实现-parent-属性"><a href="#特殊实现-parent-属性" class="headerlink" title="特殊实现: parent 属性"></a>特殊实现: <strong>parent</strong> 属性</h2><p>前面已经提到过，按标准规范，活动对象是不可能被直接访问到的。但是，一些具体实现并没有完全遵守这个规定，例如 SpiderMonkey 和 Rhino；的实现中，函数有一个特殊的属性 <strong>parent</strong>，通过这个属性可以直接引用到活动对象（或全局变量对象），在此对象里创建了函数。</p>
<p>例如 (SpiderMonkey, Rhino)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var global = this;</div><div class="line">var a = 10;</div><div class="line">function foo() &#123;&#125;</div><div class="line">alert(foo.__parent__); // global</div><div class="line">var VO = foo.__parent__;</div><div class="line">alert(VO.a); // 10</div><div class="line">alert(VO === global); // true</div></pre></td></tr></table></figure>
<p>在上面的例子中我们可以看到，函数 foo 是在全局上下文中创建的，所以属性<strong>parent</strong> 指向全局上下文的变量对象，即全局对象。</p>
<p>然而，在SpiderMonkey中用同样的方式访问活动对象是不可能的：在不同版本的SpiderMonkey中，内部函数的<strong>parent</strong> 有时指向 null ，有时指向全局对象。</p>
<p>在 Rhino 中，用同样的方式访问活动对象是完全可以的。</p>
<p>例如 (Rhino)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var global = this;</div><div class="line">var x = 10;</div><div class="line">(function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  // &quot;foo&quot;上下文里的活动对象</div><div class="line">  var AO = (function () &#123;&#125;).__parent__;</div><div class="line">  print(AO.y); // 20</div><div class="line">  // 当前活动对象的__parent__ 是已经存在的全局对象</div><div class="line">  // 变量对象的特殊链形成了</div><div class="line">  // 所以我们叫做作用域链</div><div class="line">  print(AO.__parent__ === global); // true</div><div class="line">  print(AO.__parent__.x); // 10</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章里，我们深入学习了跟执行上下文相关的对象。我希望这些知识对您来说能有所帮助，能解决一些您曾经遇到的问题或困惑。按照计划，在后续的章节中，我们将探讨作用域链，标识符解析，闭包。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.3" target="_blank" rel="external">Variable Instantiation</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.5" target="_blank" rel="external">Global Object</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.6" target="_blank" rel="external">Activation Object</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.8" target="_blank" rel="external">Arguments Object</a>.</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/06/23/深入理解javascript/7S.O.L.I.D 五大原则之开闭原则 OCP/"><span>S.O.L.I.D 五大原则之开闭原则 OCP</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/23/深入理解javascript/7S.O.L.I.D 五大原则之开闭原则 OCP/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-23T09:02:02.000Z">
          2016-06-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第 2 篇，开闭原则 OCP（The Open/Closed Principle ）。</p>
<p>开闭原则的描述是：</p>
<blockquote>
<p>Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.<br>软件实体（类，模块，方法等等）应当对扩展开放，对修改关闭，即软件实体应当在不修改的前提下扩展。</p>
</blockquote>
<p>open for extension（对扩展开放）的意思是说当新需求出现的时候，可以通过扩展现有模型达到目的。而 Close for modification（对修改关闭）的意思是说不允许对该实体做任何修改，说白了，就是这些需要执行多样行为的实体应该设计成不需要修改就可以实现各种的变化，坚持开闭原则有利于用最少的代码进行项目维护。</p>
<h2 id="问题代码"><a href="#问题代码" class="headerlink" title="问题代码"></a>问题代码</h2><p>为了直观地描述，我们来举个例子演示一下，下属代码是动态展示 question 列表的代码（没有使用开闭原则）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">// 问题类型</div><div class="line">var AnswerType = &#123;</div><div class="line">    Choice: 0,</div><div class="line">    Input: 1</div><div class="line">&#125;;</div><div class="line">// 问题实体</div><div class="line">function question(label, answerType, choices) &#123;</div><div class="line">    return &#123;</div><div class="line">        label: label,</div><div class="line">        answerType: answerType,</div><div class="line">        choices: choices // 这里的choices是可选参数</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">var view = (function () &#123;</div><div class="line">    // render一个问题</div><div class="line">    function renderQuestion(target, question) &#123;</div><div class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</div><div class="line">        questionWrapper.className = &apos;question&apos;;</div><div class="line">        var questionLabel = document.createElement(&apos;div&apos;);</div><div class="line">        questionLabel.className = &apos;question-label&apos;;</div><div class="line">        var label = document.createTextNode(question.label);</div><div class="line">        questionLabel.appendChild(label);</div><div class="line">        var answer = document.createElement(&apos;div&apos;);</div><div class="line">        answer.className = &apos;question-input&apos;;</div><div class="line">        // 根据不同的类型展示不同的代码：分别是下拉菜单和输入框两种</div><div class="line">        if (question.answerType === AnswerType.Choice) &#123;</div><div class="line">            var input = document.createElement(&apos;select&apos;);</div><div class="line">            var len = question.choices.length;</div><div class="line">            for (var i = 0; i &lt; len; i++) &#123;</div><div class="line">                var option = document.createElement(&apos;option&apos;);</div><div class="line">                option.text = question.choices[i];</div><div class="line">                option.value = question.choices[i];</div><div class="line">                input.appendChild(option);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        else if (question.answerType === AnswerType.Input) &#123;</div><div class="line">            var input = document.createElement(&apos;input&apos;);</div><div class="line">            input.type = &apos;text&apos;;</div><div class="line">        &#125;</div><div class="line">        answer.appendChild(input);</div><div class="line">        questionWrapper.appendChild(questionLabel);</div><div class="line">        questionWrapper.appendChild(answer);</div><div class="line">        target.appendChild(questionWrapper);</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        // 遍历所有的问题列表进行展示</div><div class="line">        render: function (target, questions) &#123;</div><div class="line">            for (var i = 0; i &lt; questions.length; i++) &#123;</div><div class="line">                renderQuestion(target, questions[i]);</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">var questions = [</div><div class="line">                question(&apos;Have you used tobacco products within the last 30 days?&apos;, AnswerType.Choice, [&apos;Yes&apos;, &apos;No&apos;]),</div><div class="line">                question(&apos;What medications are you currently using?&apos;, AnswerType.Input)</div><div class="line">                ];</div><div class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</div><div class="line">view.render(questionRegion, questions);</div></pre></td></tr></table></figure>
<p>上面的代码，view 对象里包含一个 render 方法用来展示 question 列表，展示的时候根据不同的 question 类型使用不同的展示方式，一个 question 包含一个 label 和一个问题类型以及 choices 的选项（如果是选择类型的话）。如果问题类型是 Choice 那就根据选项生产一个下拉菜单，如果类型是 Input，那就简单地展示 input输入框。</p>
<p>该代码有一个限制，就是如果再增加一个 question 类型的话，那就需要再次修改 renderQuestion 里的条件语句，这明显违反了开闭原则。</p>
<h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>让我们来重构一下这个代码，以便在出现新 question 类型的情况下允许扩展 view 对象的 render 能力，而不需要修改 view 对象内部的代码。</p>
<p>先来创建一个通用的 questionCreator 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function questionCreator(spec, my) &#123;</div><div class="line">    var that = &#123;&#125;;</div><div class="line">    my = my || &#123;&#125;;</div><div class="line">    my.label = spec.label;</div><div class="line">    my.renderInput = function () &#123;</div><div class="line">        throw &quot;not implemented&quot;; </div><div class="line">        // 这里renderInput没有实现，主要目的是让各自问题类型的实现代码去覆盖整个方法</div><div class="line">    &#125;;</div><div class="line">    that.render = function (target) &#123;</div><div class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</div><div class="line">        questionWrapper.className = &apos;question&apos;;</div><div class="line">        var questionLabel = document.createElement(&apos;div&apos;);</div><div class="line">        questionLabel.className = &apos;question-label&apos;;</div><div class="line">        var label = document.createTextNode(spec.label);</div><div class="line">        questionLabel.appendChild(label);</div><div class="line">        var answer = my.renderInput();</div><div class="line">        // 该render方法是同样的粗合理代码</div><div class="line">        // 唯一的不同就是上面的一句my.renderInput()</div><div class="line">        // 因为不同的问题类型有不同的实现</div><div class="line">        questionWrapper.appendChild(questionLabel);</div><div class="line">        questionWrapper.appendChild(answer);</div><div class="line">        return questionWrapper;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该代码的作用组合要是 render 一个问题，同时提供一个未实现的 renderInput 方法以便其他 function 可以覆盖，以使用不同的问题类型，我们继续看一下每个问题类型的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">function choiceQuestionCreator(spec) &#123;</div><div class="line">    var my = &#123;&#125;,</div><div class="line">that = questionCreator(spec, my);           </div><div class="line">    // choice类型的renderInput实现</div><div class="line">    my.renderInput = function () &#123;</div><div class="line">        var input = document.createElement(&apos;select&apos;);</div><div class="line">        var len = spec.choices.length;</div><div class="line">        for (var i = 0; i &lt; len; i++) &#123;</div><div class="line">            var option = document.createElement(&apos;option&apos;);</div><div class="line">            option.text = spec.choices[i];</div><div class="line">            option.value = spec.choices[i];</div><div class="line">            input.appendChild(option);</div><div class="line">        &#125;</div><div class="line">        return input;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div><div class="line">function inputQuestionCreator(spec) &#123;</div><div class="line">    var my = &#123;&#125;,</div><div class="line">that = questionCreator(spec, my);</div><div class="line">    // input类型的renderInput实现</div><div class="line">    my.renderInput = function () &#123;</div><div class="line">        var input = document.createElement(&apos;input&apos;);</div><div class="line">        input.type = &apos;text&apos;;</div><div class="line">        return input;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>choiceQuestionCreator 函数和 inputQuestionCreator 函数分别对应下拉菜单和 input 输入框的 renderInput 实现，通过内部调用统一的 questionCreator(spec, my)然后返回 that 对象（同一类型哦）。</p>
<p>view 对象的代码就很固定了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var view = &#123;</div><div class="line">    render: function(target, questions) &#123;</div><div class="line">        for (var i = 0; i &lt; questions.length; i++) &#123;</div><div class="line">            target.appendChild(questions[i].render());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>所以我们声明问题的时候只需要这样做，就 OK 了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var questions = [</div><div class="line">    choiceQuestionCreator(&#123;</div><div class="line">    label: &apos;Have you used tobacco products within the last 30 days?&apos;,</div><div class="line">    choices: [&apos;Yes&apos;, &apos;No&apos;]</div><div class="line">　　&#125;),</div><div class="line">    inputQuestionCreator(&#123;</div><div class="line">    label: &apos;What medications are you currently using?&apos;</div><div class="line">　　&#125;)</div><div class="line">    ];</div></pre></td></tr></table></figure>
<p>最终的使用代码，我们可以这样来用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</div><div class="line">view.render(questionRegion, questions);</div></pre></td></tr></table></figure>
<p>重构后的最终代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">function questionCreator(spec, my) &#123;</div><div class="line">    var that = &#123;&#125;;</div><div class="line">    my = my || &#123;&#125;;</div><div class="line">    my.label = spec.label;</div><div class="line">    my.renderInput = function() &#123;</div><div class="line">        throw &quot;not implemented&quot;;</div><div class="line">    &#125;;</div><div class="line">    that.render = function(target) &#123;</div><div class="line">        var questionWrapper = document.createElement(&apos;div&apos;);</div><div class="line">        questionWrapper.className = &apos;question&apos;;</div><div class="line">        var questionLabel = document.createElement(&apos;div&apos;);</div><div class="line">        questionLabel.className = &apos;question-label&apos;;</div><div class="line">        var label = document.createTextNode(spec.label);</div><div class="line">        questionLabel.appendChild(label);</div><div class="line">        var answer = my.renderInput();</div><div class="line">        questionWrapper.appendChild(questionLabel);</div><div class="line">        questionWrapper.appendChild(answer);</div><div class="line">        return questionWrapper;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div><div class="line">function choiceQuestionCreator(spec) &#123;</div><div class="line">    var my = &#123;&#125;,</div><div class="line">        that = questionCreator(spec, my);</div><div class="line">    my.renderInput = function() &#123;</div><div class="line">        var input = document.createElement(&apos;select&apos;);</div><div class="line">        var len = spec.choices.length;</div><div class="line">        for (var i = 0; i &lt; len; i++) &#123;</div><div class="line">            var option = document.createElement(&apos;option&apos;);</div><div class="line">            option.text = spec.choices[i];</div><div class="line">            option.value = spec.choices[i];</div><div class="line">            input.appendChild(option);</div><div class="line">        &#125;</div><div class="line">        return input;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div><div class="line">function inputQuestionCreator(spec) &#123;</div><div class="line">    var my = &#123;&#125;,</div><div class="line">        that = questionCreator(spec, my);</div><div class="line">    my.renderInput = function() &#123;</div><div class="line">        var input = document.createElement(&apos;input&apos;);</div><div class="line">        input.type = &apos;text&apos;;</div><div class="line">        return input;</div><div class="line">    &#125;;</div><div class="line">    return that;</div><div class="line">&#125;</div><div class="line">var view = &#123;</div><div class="line">    render: function(target, questions) &#123;</div><div class="line">        for (var i = 0; i &lt; questions.length; i++) &#123;</div><div class="line">            target.appendChild(questions[i].render());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var questions = [</div><div class="line">    choiceQuestionCreator(&#123;</div><div class="line">    label: &apos;Have you used tobacco products within the last 30 days?&apos;,</div><div class="line">    choices: [&apos;Yes&apos;, &apos;No&apos;]</div><div class="line">&#125;),</div><div class="line">    inputQuestionCreator(&#123;</div><div class="line">    label: &apos;What medications are you currently using?&apos;</div><div class="line">&#125;)</div><div class="line">    ];</div><div class="line">var questionRegion = document.getElementById(&apos;questions&apos;);</div><div class="line">view.render(questionRegion, questions);</div></pre></td></tr></table></figure>
<p>上面的代码里应用了一些技术点，我们来逐一看一下：</p>
<ol>
<li>首先，questionCreator 方法的创建，可以让我们使用模板方法模式将处理问题的功能 delegat 给针对每个问题类型的扩展代码 renderInput 上。</li>
<li>其次，我们用一个私有的 spec 属性替换掉了前面 question 方法的构造函数属性，因为我们封装了 render 行为进行操作，不再需要把这些属性暴露给外部代码了。</li>
<li>第三，我们为每个问题类型创建一个对象进行各自的代码实现，但每个实现里都必须包含 renderInput 方法以便覆盖 questionCreator 方法里的 renderInput 代码，这就是我们常说的策略模式。</li>
<li>通过重构，我们可以去除不必要的问题类型的枚举 AnswerType，而且可以让 choices 作为 choiceQuestionCreator 函数的必选参数（之前的版本是一个可选参数）。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重构以后的版本的 view 对象可以很清晰地进行新的扩展了，为不同的问题类型扩展新的对象，然后声明 questions 集合的时候再里面指定类型就行了，view 对象本身不再修改任何改变，从而达到了开闭原则的要求。</p>
<p>另：懂 C#的话，不知道看了上面的代码后是否和多态的实现有些类似？其实上述的代码用原型也是可以实现的，大家可以自行研究一下。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/06/22/深入理解javascript/13ThisYes,this!/"><span>ThisYes,this!</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/06/22/深入理解javascript/13ThisYes,this!/" rel="bookmark">
        <time class="entry-date published" datetime="2016-06-22T15:02:02.000Z">
          2016-06-22
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在这篇文章里，我们将讨论跟执行上下文直接相关的更多细节。讨论的主题就是 this 关键字。实践证明，这个主题很难，在不同执行上下文中 this 的确定经常会发生问题。</p>
<p>许多程序员习惯的认为，在程序语言中，this 关键字与面向对象程序开发紧密相关，其完全指向由构造器新创建的对象。在 ECMAScript 规范中也是这样实现的，但正如我们将看到那样，在 ECMAScript 中，this 并不限于只用来指向新创建的对象。</p>
<p>让我们更详细的了解一下，在 ECMAScript 中 this 到底是什么？</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>this 是执行上下文中的一个属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">  VO: &#123;...&#125;,</div><div class="line">  this: thisValue</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里 VO 是我们前一章讨论的变量对象。</p>
<p>this 与上下文中可执行代码的类型有直接关系，this 值在进入上下文时确定，并且在上下文运行期间永久不变。</p>
<p>下面让我们更详细研究这些案例：</p>
<h2 id="全局代码中的-this"><a href="#全局代码中的-this" class="headerlink" title="全局代码中的 this"></a>全局代码中的 this</h2><p>在这里一切都简单。在全局代码中，this 始终是全局对象本身，这样就有可能间接的引用到它了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 显示定义全局对象的属性</div><div class="line">this.a = 10; // global.a = 10</div><div class="line">alert(a); // 10</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 通过赋值给一个无标示符隐式</div><div class="line">b = 20;</div><div class="line">alert(this.b); // 20</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 也是通过变量声明隐式声明的</div><div class="line">// 因为全局上下文的变量对象是全局对象自身</div><div class="line">var c = 30;</div><div class="line">alert(this.c); // 30</div></pre></td></tr></table></figure>
<h2 id="函数代码中的-this"><a href="#函数代码中的-this" class="headerlink" title="函数代码中的 this"></a>函数代码中的 this</h2><p>在函数代码中使用 this 时很有趣，这种情况很难且会导致很多问题。</p>
<p>这种类型的代码中，this 值的首要特点（或许是最主要的）是它不是静态的绑定到一个函数。</p>
<p>正如我们上面曾提到的那样，this 是进入上下文时确定，在一个函数代码中，这个值在每一次完全不同。</p>
<p>不管怎样，在代码运行时的 this 值是不变的，也就是说，因为它不是一个变量，就不可能为其分配一个新值（相反，在 Python 编程语言中，它明确的定义为对象本身，在运行期间可以不断改变）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10&#125;;</div><div class="line">var bar = &#123;</div><div class="line">  x: 20,</div><div class="line">  test: function () &#123;</div><div class="line">    alert(this === bar); // true</div><div class="line">    alert(this.x); // 20</div><div class="line">    this = foo; // 错误，任何时候不能改变this的值</div><div class="line">    alert(this.x); // 如果不出错的话，应该是10，而不是20</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">// 在进入上下文的时候</div><div class="line">// this被当成bar对象</div><div class="line">// determined as &quot;bar&quot; object; why so - will</div><div class="line">// be discussed below in detail</div><div class="line">bar.test(); // true, 20</div><div class="line">foo.test = bar.test;</div><div class="line">// 不过，这里this依然不会是foo</div><div class="line">// 尽管调用的是相同的function</div><div class="line">foo.test(); // false, 10</div></pre></td></tr></table></figure>
<p>那么，影响了函数代码中 this 值的变化有几个因素：</p>
<p>首先，在通常的函数调用中，this 是由激活上下文代码的调用者来提供的，即调用函数的父上下文(parent context )。this 取决于调用函数的方式。</p>
<p>为了在任何情况下准确无误的确定 this 值，有必要理解和记住这重要的一点。正是调用函数的方式影响了调用的上下文中的 this 值，没有别的什么（我们可以在一些文章，甚至是在关于 javascript 的书籍中看到，它们声称：“this 值取决于函数如何定义，如果它是全局函数，this 设置为全局对象，如果函数是一个对象的方法，this 将总是指向这个对象。–这绝对不正确”）。继续我们的话题，可以看到，即使是正常的全局函数也会被调用方式的不同形式激活，这些不同的调用方式导致了不同的 this 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  alert(this);</div><div class="line">&#125;</div><div class="line">foo(); // global</div><div class="line">alert(foo === foo.prototype.constructor); // true</div><div class="line">// 但是同一个function的不同的调用表达式，this是不同的</div><div class="line">foo.prototype.constructor(); // foo.prototype</div></pre></td></tr></table></figure>
<p>有可能作为一些对象定义的方法来调用函数，但是 this 将不会设置为这个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  bar: function () &#123;</div><div class="line">    alert(this);</div><div class="line">    alert(this === foo);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">foo.bar(); // foo, true</div><div class="line">var exampleFunc = foo.bar;</div><div class="line">alert(exampleFunc === foo.bar); // true</div><div class="line">// 再一次，同一个 function 的不同的调用表达式，this 是不同的</div><div class="line">exampleFunc(); // global, false</div></pre></td></tr></table></figure>
<p>那么，调用函数的方式如何影响 this 值？为了充分理解 this 值的确定，需要详细分析其内部类型之一——引用类型（Reference type）。</p>
<h2 id="引用类型（Reference-type）"><a href="#引用类型（Reference-type）" class="headerlink" title="引用类型（Reference type）"></a>引用类型（Reference type）</h2><p>使用伪代码我们可以将引用类型的值可以表示为拥有两个属性的对象——base（即拥有属性的那个对象），和 base 中的 propertyName 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var valueOfReferenceType = &#123;</div><div class="line">  base: &lt;base object&gt;,</div><div class="line">  propertyName: &lt;property name&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>引用类型的值只有两种情况：</p>
<ol>
<li>当我们处理一个标示符时</li>
<li>或一个属性访问器</li>
</ol>
<p>标示符的处理过程在下一篇文章里详细讨论，在这里我们只需要知道，在该算法的返回值中，总是一个引用类型的值（这对 this 来说很重要）。</p>
<p>标识符是变量名，函数名，函数参数名和全局对象中未识别的属性名。例如，下面标识符的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = 10;</div><div class="line">function bar() &#123;&#125;</div></pre></td></tr></table></figure>
<p>在操作的中间结果中，引用类型对应的值如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;foo&apos;</div><div class="line">&#125;;</div><div class="line">var barReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;bar&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为了从引用类型中得到一个对象真正的值，伪代码中的 GetValue 方法可以做如下描述：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function GetValue(value) &#123;</div><div class="line"></div><div class="line">  if (Type(value) != Reference) &#123;</div><div class="line">    return value;</div><div class="line">  &#125;</div><div class="line">  var base = GetBase(value);</div><div class="line">  if (base === null) &#123;</div><div class="line">    throw new ReferenceError;</div><div class="line">  &#125;</div><div class="line">  return base.[[Get]](GetPropertyName(value));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部的[[Get]]方法返回对象属性真正的值，包括对原型链中继承的属性分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GetValue(fooReference); // 10</div><div class="line">GetValue(barReference); // function object &quot;bar&quot;</div></pre></td></tr></table></figure>
<p>属性访问器都应该熟悉。它有两种变体：点（.）语法（此时属性名是正确的标示符，且事先知道），或括号语法（[]）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo.bar();</div><div class="line">foo[&apos;bar&apos;]();</div></pre></td></tr></table></figure>
<p>在中间计算的返回值中，我们有了引用类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fooBarReference = &#123;</div><div class="line">  base: foo,</div><div class="line">  propertyName: &apos;bar&apos;</div><div class="line">&#125;;</div><div class="line">GetValue(fooBarReference); // function object &quot;bar&quot;</div></pre></td></tr></table></figure>
<p>引用类型的值与函数上下文中的 this 值如何相关？——从最重要的意义上来说。 这个关联的过程是这篇文章的核心。 一个函数上下文中确定 this 值的通用规则如下：</p>
<p>在一个函数上下文中， this 由调用者提供，由调用函数的方式来决定。如果调用括号()的左边是引用类型的值，this 将设为引用类型值的 base 对象（base object），在其他情况下（与引用类型不同的任何其它属性），这个值为 null。不过，实际不存在 this 的值为 null 的情况，因为当 this 的值为 null 的时候，其值会被隐式转换为全局对象。<code>*注：第 5 版的 ECMAScript 中，已经不强迫转换成全局变量了，而是赋值为 undefined。*</code></p>
<p>我们看看这个例子中的表现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  return this;</div><div class="line">&#125;</div><div class="line">foo(); // global</div></pre></td></tr></table></figure>
<p>我们看到在调用括号的左边是一个引用类型值（因为 foo 是一个标示符）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;foo&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>相应地，this 也设置为引用类型的 base 对象。即全局对象。</p>
<p>同样，使用属性访问器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  bar: function () &#123;</div><div class="line">    return this;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">foo.bar(); // foo</div></pre></td></tr></table></figure>
<p>我们再次拥有一个引用类型，其 base 是 foo 对象，在函数 bar 激活时用作 this。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var fooBarReference = &#123;</div><div class="line">  base: foo,</div><div class="line">  propertyName: &apos;bar&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>但是，用另外一种形式激活相同的函数，我们得到其它的 this 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var test = foo.bar;</div><div class="line">test(); // global</div></pre></td></tr></table></figure>
<p>因为 test 作为标示符，生成了引用类型的其他值，其 base（全局对象）用作 this 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var testReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;test&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>现在，我们可以很明确的告诉你，为什么用表达式的不同形式激活同一个函数会不同的 this 值，答案在于引用类型（type Reference）不同的中间值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  alert(this);</div><div class="line">&#125;</div><div class="line">foo(); // global, because</div><div class="line">var fooReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;foo&apos;</div><div class="line">&#125;;</div><div class="line">alert(foo === foo.prototype.constructor); // true</div><div class="line">// 另外一种形式的调用表达式</div><div class="line">foo.prototype.constructor(); // foo.prototype, because</div><div class="line">var fooPrototypeConstructorReference = &#123;</div><div class="line">  base: foo.prototype,</div><div class="line">  propertyName: &apos;constructor&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>另外一个通过调用方式动态确定 this 值的经典例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  alert(this.bar);</div><div class="line">&#125;</div><div class="line">var x = &#123;bar: 10&#125;;</div><div class="line">var y = &#123;bar: 20&#125;;</div><div class="line">x.test = foo;</div><div class="line">y.test = foo;</div><div class="line">x.test(); // 10</div><div class="line">y.test(); // 20</div></pre></td></tr></table></figure>
<h2 id="函数调用和非引用类型"><a href="#函数调用和非引用类型" class="headerlink" title="函数调用和非引用类型"></a>函数调用和非引用类型</h2><p>因此，正如我们已经指出，当调用括号的左边不是引用类型而是其它类型，这个值自动设置为 null，结果为全局对象。</p>
<p>让我们再思考这种表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  alert(this); // null =&gt; global</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个函数对象但不是引用类型的对象（它不是标示符，也不是属性访问器），相应地，this 值最终设为全局对象。</p>
<p>更多复杂的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  bar: function () &#123;</div><div class="line">    alert(this);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">foo.bar(); // Reference, OK =&gt; foo</div><div class="line">(foo.bar)(); // Reference, OK =&gt; foo</div><div class="line">(foo.bar = foo.bar)(); // global?</div><div class="line">(false || foo.bar)(); // global?</div><div class="line">(foo.bar, foo.bar)(); // global?</div></pre></td></tr></table></figure>
<p>为什么我们有一个属性访问器，它的中间值应该为引用类型的值，在某些调用中我们得到的 this 值不是 base 对象，而是 global 对象？</p>
<p>问题在于后面的三个调用，在应用一定的运算操作之后，在调用括号的左边的值不在是引用类型。</p>
<ol>
<li>第一个例子很明显———明显的引用类型，结果是，this 为 base 对象，即 foo。</li>
<li>在第二个例子中，组运算符并不适用，想想上面提到的，从引用类型中获得一个对象真正的值的方法，如 GetValue。相应的，在组运算的返回中———我们得到仍是一个引用类型。这就是 this 值为什么再次设为 base对象，即 foo。</li>
<li>第三个例子中，与组运算符不同，赋值运算符调用了 GetValue方法。返回的结果是函数对象（但不是引用类型），这意味着 this 设为 null，结果是 global 对象。</li>
<li>第四个和第五个也是一样——逗号运算符和逻辑运算符（OR）调用了 GetValue 方法，相应地，我们失去了引用而得到了函数。并再次设为 global。</li>
</ol>
<h2 id="引用类型和-this-为-null"><a href="#引用类型和-this-为-null" class="headerlink" title="引用类型和 this 为 null"></a>引用类型和 this 为 null</h2><p>有一种情况是这样的：当调用表达式限定了 call 括号左边的引用类型的值， 尽管 this 被设定为 null，但结果被隐式转化成 global。当引用类型值的 base 对象是被活动对象时，这种情况就会出现。</p>
<p>下面的实例中，内部函数被父函数调用，此时我们就能够看到上面说的那种特殊情况。正如我们在第 12 章知道的一样，局部变量、内部函数、形式参数储存在给定函数的激活对象中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  function bar() &#123;</div><div class="line">    alert(this); // global</div><div class="line">  &#125;</div><div class="line">  bar(); // the same as AO.bar()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>活动对象总是作为 this 返回，值为 null——（即伪代码的 AO.bar()相当于 null.bar()）。这里我们再次回到上面描述的例子，this 设置为全局对象。</p>
<p>有一种情况除外：如果 with 对象包含一个函数名属性，在 with 语句的内部块中调用函数。With 语句添加到该对象作用域的最前端，即在活动对象的前面。相应地，也就有了引用类型（通过标示符或属性访问器）， 其 base 对象不再是活动对象，而是 with 语句的对象。顺便提一句，它不仅与内部函数相关，也与全局函数相关，因为 with 对象比作用域链里的最前端的对象(全局对象或一个活动对象)还要靠前。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">with (&#123;</div><div class="line">  foo: function () &#123;</div><div class="line">    alert(this.x);</div><div class="line">  &#125;,</div><div class="line">  x: 20</div><div class="line">&#125;) &#123;</div><div class="line">  foo(); // 20</div><div class="line">&#125;</div><div class="line">// because</div><div class="line">var  fooReference = &#123;</div><div class="line">  base: __withObject,</div><div class="line">  propertyName: &apos;foo&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同样的情况出现在 catch 语句的实际参数中函数调用：在这种情况下，catch 对象添加到作用域的最前端，即在活动对象或全局对象的前面。但是，这个特定的行为被确认为 ECMA-262-3 的一个 bug，这个在新版的 ECMA-262-5 中修复了。这样，在特定的活动对象中，this 指向全局对象。而不是 catch 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  throw function () &#123;</div><div class="line">    alert(this);</div><div class="line">  &#125;;</div><div class="line">&#125; catch (e) &#123;</div><div class="line">  e(); // ES3标准里是__catchObject, ES5标准里是global </div><div class="line">&#125;</div><div class="line">// on idea</div><div class="line">var eReference = &#123;</div><div class="line">  base: __catchObject,</div><div class="line">  propertyName: &apos;e&apos;</div><div class="line">&#125;;</div><div class="line">// ES5新标准里已经fix了这个bug，</div><div class="line">// 所以this就是全局对象了</div><div class="line">var eReference = &#123;</div><div class="line">  base: global,</div><div class="line">  propertyName: &apos;e&apos;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同样的情况出现在命名函数（函数的更对细节参考第 15 章 Functions）的递归调用中。在函数的第一次调用中，base 对象是父活动对象（或全局对象），在递归调用中，base 对象应该是存储着函数表达式可选名称的特定对象。但是，在这种情况下，this 总是指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function foo(bar) &#123;</div><div class="line">  alert(this);</div><div class="line">  !bar &amp;&amp; foo(1); // &quot;should&quot; be special object, but always (correct) global</div><div class="line">&#125;)(); // global</div></pre></td></tr></table></figure>
<h2 id="作为构造器调用的函数中的-this"><a href="#作为构造器调用的函数中的-this" class="headerlink" title="作为构造器调用的函数中的 this"></a>作为构造器调用的函数中的 this</h2><p>还有一个与 this 值相关的情况是在函数的上下文中，这是一个构造函数的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">  alert(this); // &quot;a&quot;对象下创建一个新属性</div><div class="line">  this.x = 10;</div><div class="line">&#125;</div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10</div></pre></td></tr></table></figure>
<p>在这个例子中，new 运算符调用“A”函数的内部的[[Construct]] 方法，接着，在对象创建后，调用内部的[[Call]] 方法。 所有相同的函数“A”都将 this 的值设置为新创建的对象。</p>
<h2 id="函数调用中手动设置-this"><a href="#函数调用中手动设置-this" class="headerlink" title="函数调用中手动设置 this"></a>函数调用中手动设置 this</h2><p>在函数原型中定义的两个方法（因此所有的函数都可以访问它）允许去手动设置函数调用的 this 值。它们是 .apply 和 .call 方法。他们用接受的第一个参数作为 this 值，this 在调用的作用域中使用。这两个方法的区别很小，对于 .apply，第二个参数必须是数组（或者是类似数组的对象，如 arguments，反过来，.call 能接受任何参数。两个方法必须的参数是第一个——this。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var b = 10;</div><div class="line">function a(c) &#123;</div><div class="line">  alert(this.b);</div><div class="line">  alert(c);</div><div class="line">&#125;</div><div class="line">a(20); // this === global, this.b == 10, c == 20</div><div class="line">a.call(&#123;b: 20&#125;, 30); // this === &#123;b: 20&#125;, this.b == 20, c == 30</div><div class="line">a.apply(&#123;b: 30&#125;, [40]) // this === &#123;b: 30&#125;, this.b == 30, c == 40</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在这篇文章中，我们讨论了 ECMAScript 中 this 关键字的特征（对比于 C++ 和 Java，它们的确是特色）。我希望这篇文章有助于你准确的理解 ECMAScript 中 this 关键字如何工作。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.7" target="_blank" rel="external">This</a></li>
<li><a href="http://bclary.com/2004/11/07/#a-11.1.1" target="_blank" rel="external">The this keyword</a></li>
<li><a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="external">The new operator</a></li>
<li><a href="http://bclary.com/2004/11/07/#a-11.2.3" target="_blank" rel="external">Function calls</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  
  <a href="/page/2/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/xuhongbo" target="_blank">Xuhongbo</a>
    </br>
    
    &copy; 2017 John Doe
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>