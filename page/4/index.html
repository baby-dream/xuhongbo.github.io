<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 4 页 | Hexo</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2016/02/12/深入理解javascript/3全面解析 Module 模式/"><span>全面解析 Module 模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/12/深入理解javascript/3全面解析 Module 模式/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-12T09:56:02.000Z">
          2016-02-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Module 模式是 JavaScript 编程中一个非常通用的模式，一般情况下，大家都知道基本用法，本文尝试着给大家更多该模式的高级使用方式。</p>
<p>首先我们来看看 Module 模式的基本特征：</p>
<ol>
<li>模块化，可重用</li>
<li>封装了变量和 function，和全局的 namaspace 不接触，松耦合</li>
<li>只暴露可用 public 的方法，其它私有方法全部隐藏</li>
</ol>
<p>关于 Module 模式，最早是由 YUI 的成员 Eric Miraglia 在 4 年前提出了这个概念，我们将从一个简单的例子来解释一下基本的用法（如果你已经非常熟悉了，请忽略这一节）。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>先看一下最简单的一个实现，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var Calculator = function (eq) &#123;</div><div class="line">    //这里可以声明私有成员</div><div class="line">    var eqCtl = document.getElementById(eq);</div><div class="line">    return &#123;</div><div class="line">        // 暴露公开的成员</div><div class="line">        add: function (x, y) &#123;</div><div class="line">            var val = x + y;</div><div class="line">            eqCtl.innerHTML = val;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们可以通过如下的方式来调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var calculator = new Calculator(&apos;eq&apos;);</div><div class="line">calculator.add(2, 2);</div></pre></td></tr></table></figure>
<p>大家可能看到了，每次用的时候都要 new 一下，也就是说每个实例在内存里都是一份 copy，如果你不需要传参数或者没有一些特殊苛刻的要求的话，我们可以在最后一个}后面加上一个括号，来达到自执行的目的，这样该实例在内存中只会存在一份 copy，不过在展示他的优点之前，我们还是先来看看这个模式的基本使用方法吧。</p>
<h2 id="匿名闭包"><a href="#匿名闭包" class="headerlink" title="匿名闭包"></a>匿名闭包</h2><p>匿名闭包是让一切成为可能的基础，而这也是 JavaScript 最好的特性，我们来创建一个最简单的闭包函数，函数内部的代码一直存在于闭包内，在整个运行周期内，该闭包都保证了内部的代码处于私有状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">    // ... 所有的变量和function都在这里声明，并且作用域也只能在这个匿名闭包里</div><div class="line">    // ...但是这里的代码依然可以访问外部全局的对象</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>注意，匿名函数后面的括号，这是 JavaScript 语言所要求的，因为如果你不声明的话，JavaScript 解释器默认是声明一个 function 函数，有括号，就是创建一个函数表达式，也就是自执行，用的时候不用和上面那样在 new 了，当然你也可以这样来声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(function () &#123;/* 内部代码 */&#125;)();</div></pre></td></tr></table></figure>
<p>不过我们推荐使用第一种方式，关于函数自执行，我后面会有专门一篇文章进行详解，这里就不多说了。</p>
<h2 id="引用全局变量"><a href="#引用全局变量" class="headerlink" title="引用全局变量"></a>引用全局变量</h2><p>JavaScript 有一个特性叫做隐式全局变量，不管一个变量有没有用过，JavaScript 解释器反向遍历作用域链来查找整个变量的 var 声明，如果没有找到 var，解释器则假定该变量是全局变量，如果该变量用于了赋值操作的话，之前如果不存在的话，解释器则会自动创建它，这就是说在匿名闭包里使用或创建全局变量非常容易，不过比较困难的是，代码比较难管理，尤其是阅读代码的人看着很多区分哪些变量是全局的，哪些是局部的。</p>
<p>不过，好在匿名函数里我们可以提供一个比较简单的替代方案，我们可以将全局变量当成一个参数传入到匿名函数然后使用，相比隐式全局变量，它又清晰又快，我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function ($, YAHOO) &#123;</div><div class="line">    // 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</div><div class="line">&#125; (jQuery, YAHOO));</div></pre></td></tr></table></figure>
<p>现在很多类库里都有这种使用方式，比如 jQuery 源码。</p>
<p>不过，有时候可能不仅仅要使用全局变量，而是也想声明全局变量，如何做呢？我们可以通过匿名函数的返回值来返回这个全局变量，这也就是一个基本的 Module 模式，来看一个完整的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;, privateName = &quot;博客园&quot;;</div><div class="line">    function privateAddTopic(data) &#123;</div><div class="line">        // 这里是内部处理代码</div><div class="line">    &#125;</div><div class="line">    my.Name = privateName;</div><div class="line">    my.AddTopic = function (data) &#123;</div><div class="line">        privateAddTopic(data);</div><div class="line">    &#125;;</div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p>上面的代码声明了一个全局变量 blogModule，并且带有 2 个可访问的属性：blogModule.AddTopic 和 blogModule.Name，除此之外，其它代码都在匿名函数的闭包里保持着私有状态。同时根据上面传入全局变量的例子，我们也可以很方便地传入其它的全局变量。</p>
<h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><p>上面的内容对大多数用户已经很足够了，但我们还可以基于此模式延伸出更强大，易于扩展的结构，让我们一个一个来看。</p>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>Module 模式的一个限制就是所有的代码都要写在一个文件，但是在一些大型项目里，将一个功能分离成多个文件是非常重要的，因为可以多人合作易于开发。再回头看看上面的全局参数导入例子，我们能否把 blogModule 自身传进去呢？答案是肯定的，我们先将 blogModule 传进去，添加一个函数属性，然后再返回就达到了我们所说的目的，上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        //添加内部代码  </div><div class="line">    &#125;;</div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p>这段代码，看起来是不是有 C#里扩展方法的感觉？有点类似，但本质不一样哦。同时尽管 var 不是必须的，但为了确保一致，我们再次使用了它，代码执行以后，blogModule 下的 AddPhoto 就可以使用了，同时匿名函数内部的代码也依然保证了私密性和内部状态。</p>
<h2 id="松耦合扩展"><a href="#松耦合扩展" class="headerlink" title="松耦合扩展"></a>松耦合扩展</h2><p>上面的代码尽管可以执行，但是必须先声明 blogModule，然后再执行上面的扩展代码，也就是说步骤不能乱，怎么解决这个问题呢？我们来回想一下，我们平时声明变量都是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var cnblogs = cnblogs || &#123;&#125; ;</div></pre></td></tr></table></figure>
<p>这是确保 cnblogs 对象，在存在的时候直接用，不存在的时候直接赋值为{}，我们来看看如何利用这个特性来实现 Module 模式的任意加载顺序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line">    // 添加一些功能       </div><div class="line">    return my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<p>通过这样的代码，每个单独分离的文件都保证这个结构，那么我们就可以实现任意顺序的加载，所以，这个时候的 var 就是必须要声明的，因为不声明，其它文件读取不到哦。</p>
<h2 id="紧耦合扩展"><a href="#紧耦合扩展" class="headerlink" title="紧耦合扩展"></a>紧耦合扩展</h2><p>虽然松耦合扩展很牛叉了，但是可能也会存在一些限制，比如你没办法重写你的一些属性或者函数，也不能在初始化的时候就是用 Module 的属性。紧耦合扩展限制了加载顺序，但是提供了我们重载的机会，看如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line">    var oldAddPhotoMethod = my.AddPhoto;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        // 重载方法，依然可通过oldAddPhotoMethod调用旧的方法</div><div class="line">    &#125;;</div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p>通过这种方式，我们达到了重载的目的，当然如果你想在继续在内部使用原有的属性，你可以调用 oldAddPhotoMethod 来用。</p>
<h2 id="克隆与继承"><a href="#克隆与继承" class="headerlink" title="克隆与继承"></a>克隆与继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (old) &#123;</div><div class="line">    var my = &#123;&#125;,</div><div class="line">        key;</div><div class="line">    for (key in old) &#123;</div><div class="line">        if (old.hasOwnProperty(key)) &#123;</div><div class="line">            my[key] = old[key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var oldAddPhotoMethod = old.AddPhoto;</div><div class="line">    my.AddPhoto = function () &#123;</div><div class="line">        // 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</div><div class="line">    &#125;;</div><div class="line">    return my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p>这种方式灵活是灵活，但是也需要花费灵活的代价，其实该对象的属性对象或 function 根本没有被复制，只是对同一个对象多了一种引用而已，所以如果老对象去改变它，那克隆以后的对象所拥有的属性或 function 函数也会被改变，解决这个问题，我们就得是用递归，但递归对 function 函数的赋值也不好用，所以我们在递归的时候 eval 相应的 function。不管怎么样，我还是把这一个方式放在这个帖子里了，大家使用的时候注意一下就行了。</p>
<h2 id="跨文件共享私有对象"><a href="#跨文件共享私有对象" class="headerlink" title="跨文件共享私有对象"></a>跨文件共享私有对象</h2><p>通过上面的例子，我们知道，如果一个 module 分割到多个文件的话，每个文件需要保证一样的结构，也就是说每个文件匿名函数里的私有对象都不能交叉访问，那如果我们非要使用，那怎么办呢？ 我们先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var blogModule = (function (my) &#123;</div><div class="line">    var _private = my._private = my._private || &#123;&#125;,       </div><div class="line">        _seal = my._seal = my._seal || function () &#123;</div><div class="line">            delete my._private;</div><div class="line">            delete my._seal;</div><div class="line">            delete my._unseal;           </div><div class="line">        &#125;,</div><div class="line">        _unseal = my._unseal = my._unseal || function () &#123;</div><div class="line">            my._private = _private;</div><div class="line">            my._seal = _seal;</div><div class="line">            my._unseal = _unseal;</div><div class="line">        &#125;;      </div><div class="line">    return my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<p>任何文件都可以对他们的局部变量_private 设属性，并且设置对其他的文件也立即生效。一旦这个模块加载结束，应用会调用 blogModule._seal()”上锁”，这会阻止外部接入内部的_private。如果这个模块需要再次增生，应用的生命周期内，任何文件都可以调用_unseal() ”开锁”，然后再加载新文件。加载后再次调用 _seal()”上锁”。</p>
<h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><p>最后一个也是最简单的使用方式，那就是创建子模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (function () &#123;</div><div class="line">    var my = &#123;&#125;;</div><div class="line">    // ...</div><div class="line">    return my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p>尽管非常简单，我还是把它放进来了，因为我想说明的是子模块也具有一般模块所有的高级使用方式，也就是说你可以对任意子模块再次使用上面的一些应用方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的大部分方式都可以互相组合使用的，一般来说如果要设计系统，可能会用到松耦合扩展，私有状态和子模块这样的方式。另外，我这里没有提到性能问题，但我认为 Module 模式效率高，代码少，加载速度快。使用松耦合扩展允许并行加载，这更可以提升下载速度。不过初始化时间可能要慢一些，但是为了使用好的模式，这是值得的。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/01/19/深入理解javascript/10JavaScript 核心（晋级高手必读篇）/"><span>JavaScript 核心（晋级高手必读篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/01/19/深入理解javascript/10JavaScript 核心（晋级高手必读篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-01-19T05:02:02.000Z">
          2016-01-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>我们首先来看一下对象[Object]的概念，这也是 ECMASript 中最基本的概念。</p>
<h2 id="对象-Object"><a href="#对象-Object" class="headerlink" title="对象 Object"></a>对象 Object</h2><p>ECMAScript 是一门高度抽象的面向对象(object-oriented)语言，用以处理 Objects 对象。当然，也有基本类型，但是必要时，也需要转换成 object 对象来用。</p>
<blockquote>
<p>Object 是一个属性的集合，并且都拥有一个单独的原型对象[prototype object]。这个原型对象[prototype object]可以是一个 object 或者 null 值。</p>
</blockquote>
<p>让我们来举一个基本 Object 的例子，首先我们要清楚，一个 Object 的 prototype 是一个内部的[[prototype]]属性的引用。</p>
<p>不过一般来说，我们会使用<strong>&lt;内部属性名&gt;</strong> 下划线来代替双括号，例如<strong>proto</strong>(这是某些脚本引擎比如 SpiderMonkey 的对于原型概念的具体实现，尽管并非标准)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述代码 foo 对象有两个显式的属性[explicit own properties]和一个自带隐式的<strong>proto</strong> 属性[implicit<strong>proto</strong> property]，指向 foo 的原型。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/1.png" alt="img"></p>
<p>图 1. 一个含有原型的基本对象</p>
<p>为什么需要原型呢，让我们考虑原型链的概念来回答这个问题。</p>
<h2 id="原型链（Prototype-chain）"><a href="#原型链（Prototype-chain）" class="headerlink" title="原型链（Prototype chain）"></a>原型链（Prototype chain）</h2><p>原型对象也是普通的对象，并且也有可能有自己的原型，如果一个原型对象的原型不为 null 的话，我们就称之为原型链（prototype chain）。</p>
<blockquote>
<p>原型链是一个由对象组成的有限对象链由于实现继承和共享属性。</p>
</blockquote>
<p>想象一个这种情况，2 个对象，大部分内容都一样，只有一小部分不一样，很明显，在一个好的设计模式中，我们会需要重用那部分相同的，而不是在每个对象中重复定义那些相同的方法或者属性。在基于类[class-based]的系统中，这些重用部分被称为类的继承 – 相同的部分放入 class A，然后 class B 和 class C 从 A 继承，并且可以声明拥有各自的独特的东西。</p>
<p>ECMAScript 没有类的概念。但是，重用[reuse]这个理念没什么不同（某些方面，甚至比 class-更加灵活），可以由 prototype chain 原型链来实现。这种继承被称为 delegation based inheritance-基于继承的委托，或者更通俗一些，叫做原型继承。</p>
<p>类似于类”A”，”B”，”C”，在ECMAScript中尼创建对象类”a”，”b”，”c”，相应地， 对象“a” 拥有对象“b”和”c”的共同部分。同时对象“b”和”c”只包含它们自己的附加属性或方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">  x: 10,</div><div class="line">  calculate: function (z) &#123;</div><div class="line">    return this.x + this.y + z</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">var b = &#123;</div><div class="line">  y: 20,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line">var c = &#123;</div><div class="line">  y: 30,</div><div class="line">  __proto__: a</div><div class="line">&#125;;</div><div class="line">// 调用继承过来的方法</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div></pre></td></tr></table></figure>
<p>这样看上去是不是很简单啦。b 和 c 可以使用 a 中定义的 calculate 方法，这就是有原型链来[prototype chain]实现的。</p>
<p>原理很简单:如果在对象 b 中找不到 calculate 方法(也就是对象 b 中没有这个 calculate 属性), 那么就会沿着原型链开始找。如果这个 calculate 方法在 b 的 prototype 中没有找到，那么就会沿着原型链找到 a 的 prototype，一直遍历完整个原型链。记住，一旦找到，就返回第一个找到的属性或者方法。因此，第一个找到的属性成为继承属性。如果遍历完整个原型链，仍然没有找到，那么就会返回 undefined。</p>
<p>注意一点，this 这个值在一个继承机制中，仍然是指向它原本属于的对象，而不是从原型链上找到它时，它所属于的对象。例如，以上的例子，this.y 是从 b 和 c 中获取的，而不是 a。当然，你也发现了 this.x 是从 a 取的，因为是通过原型链机制找到的。</p>
<p>如果一个对象的 prototype 没有显示的声明过或定义过，那么<strong>prototype</strong>的默认值就是 object.prototype，而 object.prototype 也会有一个<strong>prototype</strong>， 这个就是原型链的终点了，被设置为 null。</p>
<p>下面的图示就是表示了上述 a，b，c 的继承关系</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/2.png" alt="img"></p>
<p>图 2. 原型链</p>
<p>原型链通常将会在这样的情况下使用：对象拥有 相同或相似的状态结构(same or similar state structure) （即相同的属性集合）与不同的状态值(different state values)。在这种情况下，我们可以使用 构造函数(Constructor) 在特定模式(specified pattern) 下创建对象。</p>
<h2 id="构造函数-Constructor"><a href="#构造函数-Constructor" class="headerlink" title="构造函数(Constructor)"></a>构造函数(Constructor)</h2><p>除了创建对象，构造函数(constructor) 还做了另一件有用的事情—自动为创建的新对象设置了原型对象(prototype object) 。原型对象存放于 ConstructorFunction.prototype 属性中。</p>
<p>例如，我们重写之前例子，使用构造函数创建对象“b”和“c”，那么对象”a”则扮演了“Foo.prototype”这个角色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 构造函数</div><div class="line">function Foo(y) &#123;</div><div class="line">  // 构造函数将会以特定模式创建对象：被创建的对象都会有&quot;y&quot;属性</div><div class="line">  this.y = y;</div><div class="line">&#125;</div><div class="line">// &quot;Foo.prototype&quot;存放了新建对象的原型引用</div><div class="line">// 所以我们可以将之用于定义继承和共享属性或方法</div><div class="line">// 所以，和上例一样，我们有了如下代码：</div><div class="line">// 继承属性&quot;x&quot;</div><div class="line">Foo.prototype.x = 10; </div><div class="line">// 继承方法&quot;calculate&quot;</div><div class="line">Foo.prototype.calculate = function (z) &#123;</div><div class="line">  return this.x + this.y + z;</div><div class="line">&#125;; </div><div class="line">// 使用foo模式创建 &quot;b&quot; and &quot;c&quot;</div><div class="line">var b = new Foo(20);</div><div class="line">var c = new Foo(30);</div><div class="line">// 调用继承的方法</div><div class="line">b.calculate(30); // 60</div><div class="line">c.calculate(40); // 80</div><div class="line">// 让我们看看是否使用了预期的属性 </div><div class="line">console.log(</div><div class="line">  b.__proto__ === Foo.prototype, // true</div><div class="line">  c.__proto__ === Foo.prototype, // true</div><div class="line">  // &quot;Foo.prototype&quot;自动创建了一个特殊的属性&quot;constructor&quot;</div><div class="line">  // 指向a的构造函数本身</div><div class="line">  // 实例&quot;b&quot;和&quot;c&quot;可以通过授权找到它并用以检测自己的构造函数</div><div class="line">  b.constructor === Foo, // true</div><div class="line">  c.constructor === Foo, // true</div><div class="line">  Foo.prototype.constructor === Foo // true</div><div class="line">  b.calculate === b.__proto__.calculate, // true</div><div class="line">  b.__proto__.calculate === Foo.prototype.calculate // true </div><div class="line">);</div></pre></td></tr></table></figure>
<p>上述代码可表示为如下的关系：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/3.png" alt="img"></p>
<p>图 3. 构造函数与对象之间的关系</p>
<p>上述图示可以看出，每一个 object 都有一个 prototype. 构造函数 Foo 也拥有自己的<strong>proto</strong>，也就是 Function.prototype，而 Function.prototype 的<strong>proto</strong>指向了 Object.prototype。 重申一遍，Foo.prototype 只是一个显式的属性，也就是 b 和 c 的<strong>proto</strong>属性。</p>
<p>这个问题完整和详细的解释可以在大叔即将翻译的第 18、19 两章找到。有两个部分：<code>面向对象编程.一般理论(OOP. The general theory)</code>，描述了不同的面向对象的范式与风格(OOP paradigms and stylistics)，以及与ECMAScript的比较， <code>面向对象编程.ECMAScript实现(OOP. ECMAScript implementation)</code>，专门讲述了 ECMAScript 中的面向对象编程。</p>
<p>现在，我们已经了解了基本的 object 原理，那么我们接下去来看看 ECMAScript 里面的程序执行环境[runtime program execution]. 这就是通常称为的“执行上下文堆栈”[execution context stack]。每一个元素都可以抽象的理解为 object。你也许发现了，没错，在 ECMAScript 中，几乎处处都能看到 object 的身影。</p>
<h2 id="执行上下文栈-Execution-Context-Stack"><a href="#执行上下文栈-Execution-Context-Stack" class="headerlink" title="执行上下文栈(Execution Context Stack)"></a>执行上下文栈(Execution Context Stack)</h2><p>在 ECMASscript 中的代码有三种类型：global，function 和 eval。</p>
<p>每一种代码的执行都需要依赖自身的上下文。当然 global 的上下文可能涵盖了很多的 function 和 eval 的实例。函数的每一次调用，都会进入函数执行中的上下文,并且来计算函数中变量等的值。eval 函数的每一次执行，也会进入 eval 执行中的上下文，判断应该从何处获取变量的值。</p>
<p>注意，一个 function 可能产生无限的上下文环境，因为一个函数的调用（甚至递归）都产生了一个新的上下文环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(bar) &#123;&#125;</div><div class="line">// 调用相同的function，每次都会产生3个不同的上下文</div><div class="line">//（包含不同的状态，例如参数bar的值）</div><div class="line">foo(10);</div><div class="line">foo(20);</div><div class="line">foo(30);</div></pre></td></tr></table></figure>
<p>一个执行上下文可以激活另一个上下文，就好比一个函数调用了另一个函数(或者全局的上下文调用了一个全局函数)，然后一层一层调用下去。逻辑上来说，这种实现方式是栈，我们可以称之为上下文堆栈。</p>
<p>激活其它上下文的某个上下文被称为 调用者(caller) 。被激活的上下文被称为被调用者(callee) 。被调用者同时也可能是调用者(比如一个在全局上下文中被调用的函数调用某些自身的内部方法)。</p>
<p>当一个 caller 激活了一个 callee，那么这个 caller 就会暂停它自身的执行，然后将控制权交给这个 callee. 于是这个 callee 被放入堆栈，称为进行中的上下文[running/active execution context]。当这个 callee 的上下文结束之后，会把控制权再次交给它的 caller，然后 caller 会在刚才暂停的地方继续执行。在这个 caller 结束之后，会继续触发其他的上下文。一个 callee 可以用返回（return）或者抛出异常（exception）来结束自身的上下文。</p>
<p>如下图，所有的 ECMAScript 的程序执行都可以看做是一个执行上下文堆栈[execution context (EC) stack]。堆栈的顶部就是处于激活状态的上下文。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/4.png" alt="img"></p>
<p>图 4. 执行上下文栈</p>
<p>当一段程序开始时，会先进入全局执行上下文环境[global execution context], 这个也是堆栈中最底部的元素。此全局程序会开始初始化，初始化生成必要的对象[objects]和函数[functions]. 在此全局上下文执行的过程中，它可能会激活一些方法（当然是已经初始化过的），然后进入他们的上下文环境，然后将新的元素压入堆栈。在这些初始化都结束之后，这个系统会等待一些事件（例如用户的鼠标点击等），会触发一些方法，然后进入一个新的上下文环境。</p>
<p>见图5，有一个函数上下文“EC1″和一个全局上下文“Global EC”，下图展现了从“Global EC”进入和退出“EC1″时栈的变化:</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/5.png" alt="img"></p>
<p>图 5. 执行上下文栈的变化</p>
<p>ECMAScript 运行时系统就是这样管理代码的执行。</p>
<p>关于ECMAScript执行上下文栈的内容请查阅本系列教程的<code>第11章执行上下文(Execution context)</code>。</p>
<p>如上所述，栈中每一个执行上下文可以表示为一个对象。让我们看看上下文对象的结构以及执行其代码所需的状态(state) 。</p>
<h2 id="执行上下文-Execution-Context"><a href="#执行上下文-Execution-Context" class="headerlink" title="执行上下文(Execution Context)"></a>执行上下文(Execution Context)</h2><p>一个执行的上下文可以抽象的理解为 object。每一个执行的上下文都有一系列的属性（我们称为上下文状态），他们用来追踪关联代码的执行进度。这个图示就是一个 context 的结构。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/6.png" alt="img"></p>
<p>图 6. 上下文结构</p>
<p>除了这 3 个所需要的属性(<code>变量对象(variable object)</code>，<code>this 指针(this value)</code>，<code>作用域链(scope chain)</code> )，执行上下文根据具体实现还可以具有任意额外属性。接着，让我们仔细来看看这三个属性。</p>
<h2 id="变量对象-Variable-Object"><a href="#变量对象-Variable-Object" class="headerlink" title="变量对象(Variable Object)"></a>变量对象(Variable Object)</h2><ul>
<li>变量对象(variable object) 是与执行上下文相关的 数据作用域(scope of data) 。</li>
<li>它是与上下文关联的特殊对象，用于存储被定义在上下文中的 变量(variables) 和 函数声明(function declarations) 。</li>
</ul>
<blockquote>
<p>注意：函数表达式[function expression]（而不是函数声明[function declarations，区别请参考本系列第2章]）是不包含在VO[variable object]里面的。</p>
</blockquote>
<p>变量对象（Variable Object）是一个抽象的概念，不同的上下文中，它表示使用不同的 object。例如，在 global 全局上下文中，变量对象也是全局对象自身[global object]。（这就是我们可以通过全局对象的属性来指向全局变量）。</p>
<p>让我们看看下面例子中的全局执行上下文情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = 10;</div><div class="line">function bar() &#123;&#125; // // 函数声明</div><div class="line">(function baz() &#123;&#125;); // 函数表达式</div><div class="line">console.log(</div><div class="line">  this.foo == foo, // true</div><div class="line">  window.bar == bar // true</div><div class="line">);</div><div class="line">console.log(baz); // 引用错误，baz没有被定义</div></pre></td></tr></table></figure>
<p>全局上下文中的变量对象(VO)会有如下属性：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/7.png" alt="img"></p>
<p>图 7. 全局变量对象</p>
<p>如上所示，函数“baz”如果作为函数表达式则不被不被包含于变量对象。这就是在函数外部尝试访问产生引用错误(ReferenceError) 的原因。请注意，ECMAScript 和其他语言相比(比如 C/C++)，仅有函数能够创建新的作用域。在函数内部定义的变量与内部函数，在外部非直接可见并且不污染全局对象。使用 eval 的时候，我们同样会使用一个新的(eval创建)执行上下文。eval 会使用全局变量对象或调用者的变量对象(eval 的调用来源)。</p>
<p>那函数以及自身的变量对象又是怎样的呢?在一个函数上下文中，变量对象被表示为活动对象(activation object)。</p>
<h2 id="活动对象-activation-object"><a href="#活动对象-activation-object" class="headerlink" title="活动对象(activation object)"></a>活动对象(activation object)</h2><p>当函数被调用者激活，这个特殊的活动对象(activation object) 就被创建了。它包含普通参数(formal parameters) 与特殊参数(arguments)对象(具有索引属性的参数映射表)。活动对象在函数上下文中作为变量对象使用。</p>
<p>即：函数的变量对象保持不变，但除去存储变量与函数声明之外，还包含以及特殊对象 arguments 。</p>
<p>考虑下面的情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo(x, y) &#123;</div><div class="line">  var z = 30;</div><div class="line">  function bar() &#123;&#125; // 函数声明</div><div class="line">  (function baz() &#123;&#125;); // 函数表达式</div><div class="line">&#125;</div><div class="line">foo(10, 20);</div></pre></td></tr></table></figure>
<p>“foo”函数上下文的下一个激活对象(AO)如下图所示：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/8.png" alt="img"></p>
<p>图 8. 激活对象</p>
<p>同样道理，function expression 不在 AO 的行列。</p>
<p>对于这个 AO 的详细内容可以通过本系列教程第 9 章找到。</p>
<p>我们接下去要讲到的是第三个主要对象。众所周知，在 ECMAScript 中，我们会用到内部函数[inner functions]，在这些内部函数中，我们可能会引用它的父函数变量，或者全局的变量。我们把这些变量对象成为上下文作用域对象[scope object of the context]. 类似于上面讨论的原型链[prototype chain]，我们在这里称为作用域链[scope chain]。</p>
<h2 id="作用域链-Scope-Chains"><a href="#作用域链-Scope-Chains" class="headerlink" title="作用域链(Scope Chains)"></a>作用域链(Scope Chains)</h2><blockquote>
<p>作用域链是一个 对象列表(list of objects) ，用以检索上下文代码中出现的标识符(identifiers) 。</p>
</blockquote>
<p>作用域链的原理和原型链很类似，如果这个变量在自己的作用域中没有，那么它会寻找父级的，直到最顶层。</p>
<p>标示符[Identifiers]可以理解为变量名称、函数声明和普通参数。例如，当一个函数在自身函数体内需要引用一个变量，但是这个变量并没有在函数内部声明（或者也不是某个参数名），那么这个变量就可以称为自由变量[free variable]。那么我们搜寻这些自由变量就需要用到作用域链。</p>
<p>在一般情况下，一个作用域链包括父级变量对象（variable object）（作用域链的顶部）、函数自身变量 VO 和活动对象（activation object）。不过，有些情况下也会包含其它的对象，例如在执行期间，动态加入作用域链中的—例如 with 或者 catch 语句。[译注：with-objects指的是with语句，产生的临时作用域对象；catch-clauses 指的是 catch从句，如 catch(e)，这会产生异常对象，导致作用域变更]。</p>
<p>当查找标识符的时候，会从作用域链的活动对象部分开始查找，然后(如果标识符没有在活动对象中找到)查找作用域链的顶部，循环往复，就像作用域链那样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">(function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  (function bar() &#123;</div><div class="line">    var z = 30;</div><div class="line">    // &quot;x&quot;和&quot;y&quot;是自由变量</div><div class="line">    // 会在作用域链的下一个对象中找到（函数”bar”的互动对象之后）</div><div class="line">    console.log(x + y + z);</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们假设作用域链的对象联动是通过一个叫做<strong>parent</strong>的属性，它是指向作用域链的下一个对象。这可以在 Rhino Code 中测试一下这种流程，这种技术也确实在 ES5 环境中实现了(有一个称为 outer 链接)。当然也可以用一个简单的数据来模拟这个模型。使用<strong>parent</strong>的概念，我们可以把上面的代码演示成如下的情况。（因此，父级变量是被存在函数的[[Scope]]属性中的）。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/9.png" alt="img"></p>
<p>图 9. 作用域链</p>
<p>在代码执行过程中，如果使用 with 或者 catch 语句就会改变作用域链。而这些对象都是一些简单对象，他们也会有原型链。这样的话，作用域链会从两个维度来搜寻。</p>
<ol>
<li>首先在原本的作用域链</li>
<li>每一个链接点的作用域的链（如果这个链接点是有 prototype 的话）</li>
</ol>
<p>我们再看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;</div><div class="line">var w = 20;</div><div class="line">var y = 30;</div><div class="line">// 在SpiderMonkey全局对象里</div><div class="line">// 例如，全局上下文的变量对象是从&quot;Object.prototype&quot;继承到的</div><div class="line">// 所以我们可以得到“没有声明的全局变量”</div><div class="line">// 因为可以从原型链中获取</div><div class="line">console.log(x); // 10</div><div class="line">(function foo() &#123;</div><div class="line">  // &quot;foo&quot; 是局部变量</div><div class="line">  var w = 40;</div><div class="line">  var x = 100;</div><div class="line">  // &quot;x&quot; 可以从&quot;Object.prototype&quot;得到，注意值是10哦</div><div class="line">  // 因为&#123;z: 50&#125;是从它那里继承的</div><div class="line">  with (&#123;z: 50&#125;) &#123;</div><div class="line">    console.log(w, x, y , z); // 40, 10, 30, 50</div><div class="line">  &#125;</div><div class="line">  // 在&quot;with&quot;对象从作用域链删除之后</div><div class="line">  // x又可以从foo的上下文中得到了，注意这次值又回到了100哦</div><div class="line">  // &quot;w&quot; 也是局部变量</div><div class="line">  console.log(x, w); // 100, 40</div><div class="line">  // 在浏览器里</div><div class="line">  // 我们可以通过如下语句来得到全局的w值</div><div class="line">  console.log(window.w); // 20</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们就会有如下结构图示。这表示，在我们去搜寻<strong>parent</strong>之前，首先会去<strong>proto</strong>的链接中。</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/10.png" alt="img"></p>
<p>图 10. with 增大的作用域链</p>
<p>注意，不是所有的全局对象都是由 Object.prototype 继承而来的。上述图示的情况可以在 SpiderMonkey 中测试。</p>
<p>只要所有外部函数的变量对象都存在，那么从内部函数引用外部数据则没有特别之处——我们只要遍历作用域链表，查找所需变量。然而，如上文所提及，当一个上下文终止之后，其状态与自身将会被 销毁(destroyed) ，同时内部函数将会从外部函数中返回。此外，这个返回的函数之后可能会在其他的上下文中被激活，那么如果一个之前被终止的含有一些自由变量的上下文又被激活将会怎样?通常来说，解决这个问题的概念在 ECMAScrip t中与作用域链直接相关，被称为 (词法)闭包((lexical) closure)。</p>
<h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><p>在 ECMAScript 中，函数是“第一类”对象。这个名词意味着函数可以作为参数被传递给其他函数使用 (在这种情况下，函数被称为“funargs”——“functional arguments”的缩写[译注：这里不知翻译为泛函参数是否恰当])。接收“funargs”的函数被称之为 高阶函数(higher-order functions) ，或者更接近数学概念的话，被称为 运算符(operators) 。其他函数的运行时也会返回函数，这些返回的函数被称为 function valued 函数 (有 functional value 的函数)。</p>
<p>“funargs”与“functional values”有两个概念上的问题，这两个子问题被称为“Funarg problem” (“泛函参数问题”)。要准确解决泛函参数问题，需要引入 闭包(closures) 到的概念。让我们仔细描述这两个问题(我们可以见到，在 ECMAScript 中使用了函数的[[Scope]]属性来解决这个问题)。</p>
<p>“funarg problem”的一个子问题是“upward funarg problem”[译注：或许可以翻译为：向上查找的函数参数问题]。当一个函数从其他函数返回到外部的时候，这个问题将会出现。要能够在外部上下文结束时，进入外部上下文的变量，内部函数 在创建的时候(at creation moment) 需要将之存储进[[Scope]]属性的父元素的作用域中。然后当函数被激活时，上下文的作用域链表现为激活对象与[[Scope]]属性的组合(事实上，可以在上图见到)：</p>
<blockquote>
<p>Scope chain = Activation object + [[Scope]]<br>作用域链 = 活动对象 + [[Scope]]</p>
</blockquote>
<p>请注意，最主要的事情是——函数在被创建时保存外部作用域，是因为这个 被保存的作用域链(saved scope chain) 将会在未来的函数调用中用于变量查找。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 10;</div><div class="line">  return function bar() &#123;</div><div class="line">    console.log(x);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">// &quot;foo&quot;返回的也是一个function</div><div class="line">// 并且这个返回的function可以随意使用内部的变量x</div><div class="line">var returnedFunction = foo();</div><div class="line">// 全局变量 &quot;x&quot;</div><div class="line">var x = 20;</div><div class="line">// 支持返回的function</div><div class="line">returnedFunction(); // 结果是10而不是20</div></pre></td></tr></table></figure>
<p>这种形式的作用域称为静态作用域[static/lexical scope]。上面的 x 变量就是在函数 bar 的[[Scope]]中搜寻到的。理论上来说，也会有动态作用域[dynamic scope], 也就是上述的 x 被解释为 20，而不是 10. 但是 EMCAScript 不使用动态作用域。</p>
<p>“funarg problem”的另一个类型就是自上而下[”downward funarg problem”].在这种情况下，父级的上下会存在，但是在判断一个变量值的时候会有多义性。也就是，这个变量究竟应该使用哪个作用域。是在函数创建时的作用域呢，还是在执行时的作用域呢？为了避免这种多义性，可以采用闭包，也就是使用静态作用域。</p>
<p>请看下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 全局变量 &quot;x&quot;</div><div class="line">var x = 10;</div><div class="line">// 全局function</div><div class="line">function foo() &#123;</div><div class="line">  console.log(x);</div><div class="line">&#125;</div><div class="line">(function (funArg) &#123;</div><div class="line">  // 局部变量 &quot;x&quot;</div><div class="line">  var x = 20;</div><div class="line">  // 这不会有歧义</div><div class="line">  // 因为我们使用&quot;foo&quot;函数的[[Scope]]里保存的全局变量&quot;x&quot;,</div><div class="line">  // 并不是caller作用域的&quot;x&quot;</div><div class="line">  funArg(); // 10, 而不是20</div><div class="line">&#125;)(foo); // 将foo作为一个&quot;funarg&quot;传递下去</div></pre></td></tr></table></figure>
<p>从上述的情况，我们似乎可以断定，在语言中，使用静态作用域是闭包的一个强制性要求。不过，在某些语言中，会提供动态和静态作用域的结合，可以允许开发员选择哪一种作用域。但是在 ECMAScript 中，只采用了静态作用域。所以 ECMAScript 完全支持使用[[Scope]]的属性。我们可以给闭包得出如下定义：</p>
<blockquote>
<p>闭包是一系列代码块（在ECMAScript中是函数），并且静态保存所有父级的作用域。通过这些保存的作用域来搜寻到函数中的自由变量。</p>
</blockquote>
<p>请注意，因为每一个普通函数在创建时保存了[[Scope]]，理论上，ECMAScript 中所有函数都是闭包。</p>
<p>还有一个很重要的点，几个函数可能含有相同的父级作用域（这是一个很普遍的情况，例如有好几个内部或者全局的函数）。在这种情况下，在[[Scope]]中存在的变量是会共享的。一个闭包中变量的变化，也会影响另一个闭包的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function baz() &#123;</div><div class="line">  var x = 1;</div><div class="line">  return &#123;</div><div class="line">    foo: function foo() &#123; return ++x; &#125;,</div><div class="line">    bar: function bar() &#123; return --x; &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">var closures = baz();</div><div class="line">console.log(</div><div class="line">  closures.foo(), // 2</div><div class="line">  closures.bar()  // 1</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上述代码可以用这张图来表示：</p>
<p><img src="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/images/11.png" alt="img"></p>
<p>图 11. 共享的[[Scope]]</p>
<p>在某个循环中创建多个函数时，上图会引发一个困惑。如果在创建的函数中使用循环变量(如”k”)，那么所有的函数都使用同样的循环变量，导致一些程序员经常会得不到预期值。现在清楚为什么会产生如此问题了——因为所有函数共享同一个[[Scope]]，其中循环变量为最后一次复赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = function () &#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">data[0](); // 3, but not 0</div><div class="line">data[1](); // 3, but not 1</div><div class="line">data[2](); // 3, but not 2</div></pre></td></tr></table></figure>
<p>有一些用以解决这类问题的技术。其中一种技巧是在作用域链中提供一个额外的对象，比如增加一个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = (function (x) &#123;</div><div class="line">    return function () &#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); // 将k当做参数传递进去</div><div class="line">&#125; </div><div class="line">// 结果正确</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<p>闭包理论的深入研究与具体实践可以在本系列教程第 16 章闭包(Closures)中找到。如果想得到关于作用域链的更多信息，可以参照本系列教程第 14 章作用域链(Scope chain)。</p>
<p>下一章节将会讨论一个执行上下文的最后一个属性——this 指针的概念。</p>
<h2 id="This-指针"><a href="#This-指针" class="headerlink" title="This 指针"></a>This 指针</h2><blockquote>
<p>this适合执行的上下文环境息息相关的一个特殊对象。因此，它也可以称为上下文对象<a href="激活执行上下文的上下文">context object</a>。</p>
</blockquote>
<p>任何对象都可以作为上下文的 this 值。我想再次澄清对与 ECMAScript 中，与执行上下文相关的一些描述——特别是 this 的误解。通常，this 被错误地，描述为变量对象的属性。最近比如在这本书中就发现了(尽管书中提及 this 的那一章还不错)。 请牢记：</p>
<blockquote>
<p>this是执行上下文环境的一个属性，而不是某个变量对象的属性。</p>
</blockquote>
<p>这个特点很重要，因为和变量不同，this 是没有一个类似搜寻变量的过程。当你在代码中使用了 this，这个 this 的值就直接从执行的上下文中获取了，而不会从作用域链中搜寻。this 的值只取决中进入上下文时的情况。</p>
<p>顺便说一句，和 ECMAScript 不同，Python 有一个 self 的参数，和 this 的情况差不多，但是可以在执行过程中被改变。在 ECMAScript 中，是不可以给 this 赋值的，因为，还是那句话，this 不是变量。</p>
<p>在 global context(全局上下文)中，this 的值就是指全局这个对象，这就意味着，this 值就是这个变量本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">console.log(</div><div class="line">  x, // 10</div><div class="line">  this.x, // 10</div><div class="line">  window.x // 10</div><div class="line">);</div></pre></td></tr></table></figure>
<p>在函数上下文[function context]中，this 会可能会根据每次的函数调用而成为不同的值 .this 会由每一次 caller 提供，caller 是通过调用表达式[call expression]产生的（也就是这个函数如何被激活调用的）。例如，下面的例子中 foo 就是一个 callee，在全局上下文中被激活。下面的例子就表明了不同的 caller 引起 this 的不同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// &quot;foo&quot;函数里的alert没有改变</div><div class="line">// 但每次激活调用的时候this是不同的</div><div class="line">function foo() &#123;</div><div class="line">  alert(this);</div><div class="line">&#125;</div><div class="line">// caller 激活 &quot;foo&quot;这个callee，</div><div class="line">// 并且提供&quot;this&quot;给这个 callee</div><div class="line">foo(); // 全局对象</div><div class="line">foo.prototype.constructor(); // foo.prototype</div><div class="line">var bar = &#123;</div><div class="line">  baz: foo</div><div class="line">&#125;;</div><div class="line">bar.baz(); // bar</div><div class="line">(bar.baz)(); // also bar</div><div class="line">(bar.baz = bar.baz)(); // 这是一个全局对象</div><div class="line">(bar.baz, bar.baz)(); // 也是全局对象</div><div class="line">(false || bar.baz)(); // 也是全局对象</div><div class="line">var otherFoo = bar.baz;</div><div class="line">otherFoo(); // 还是全局对象</div></pre></td></tr></table></figure>
<p>如果要深入思考每一次函数调用中，this 值的变化(更重要的是怎样变化)，你可以阅读本系列教程第 10 章 This。上文所提及的情况都会在此章内详细讨论。</p>
<h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结(Conclusion)"></a>总结(Conclusion)</h2><p>在此我们完成了一个简短的概述。尽管看来不是那么简短，但是这些话题若要完整表述完毕，则需要一整本书。我们没有提及两个重要话题：函数(functions) (以及不同类型的函数之间的不同，比如函数声明与函数表达式)与 ECMAScript 的 求值策略(evaluation strategy) 。这两个话题可以分别查阅本系列教程第 15 章函数(Functions) 与第 19 章求值策略(Evaluation strategy)。</p>
<h2 id="同步与推荐"><a href="#同步与推荐" class="headerlink" title="同步与推荐"></a>同步与推荐</h2><p>深入理解 JavaScript 系列文章，包括了原创，翻译，转载等各类型的文章，如果对你有用，请推荐支持一把，给大叔写作的动力。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/01/16/深入理解javascript/2揭秘命名函数表达式/"><span>揭秘命名函数表达式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/01/16/深入理解javascript/2揭秘命名函数表达式/" rel="bookmark">
        <time class="entry-date published" datetime="2016-01-16T09:02:02.000Z">
          2016-01-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上还没用发现有人对命名函数表达式进去重复深入的讨论，正因为如此，网上出现了各种各样的误解，本文将从原理和实践两个方面来探讨 JavaScript 关于命名函数表达式的优缺点。</p>
<p>简单的说，命名函数表达式只有一个用户，那就是在 Debug 或者 Profiler 分析的时候来描述函数的名称，也可以使用函数名实现递归，但很快你就会发现其实是不切实际的。当然，如果你不关注调试，那就没什么可担心的了，否则，如果你想了解兼容性方面的东西的话，你还是应该继续往下看看。</p>
<p>我们先开始看看，什么叫函数表达式，然后再说一下现代调试器如何处理这些表达式，如果你已经对这方面很熟悉的话，请直接跳过此小节。</p>
<h2 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h2><p>在 ECMAScript 中，创建函数的最常用的两个方法是函数表达式和函数声明，两者期间的区别是有点晕，因为 ECMA 规范只明确了一点：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符：</p>
<p>函数声明:</p>
<p>function 函数名称 (参数：可选){ 函数体 }</p>
<p>函数表达式：</p>
<p>function 函数名称（可选）(参数：可选){ 函数体 }</p>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称的话，如何判断是函数声明还是函数表达式呢？ECMAScript 是通过上下文来区分的，如果 function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果 function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125; // 声明，因为它是程序的一部分</div><div class="line">var bar = function foo()&#123;&#125;; // 表达式，因为它是赋值表达式的一部分</div><div class="line">new function bar()&#123;&#125;; // 表达式，因为它是new表达式</div><div class="line">(function()&#123;</div><div class="line">  function bar()&#123;&#125; // 声明，因为它是函数体的一部分</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;&#125; // 函数声明</div><div class="line">(function foo()&#123;&#125;); // 函数表达式：包含在分组操作符内</div><div class="line">try &#123;</div><div class="line">  (var x = 5); // 分组操作符，只能包含表达式而不能包含语句：这里的var就是语句</div><div class="line">&#125; catch(err) &#123;</div><div class="line">  // SyntaxError</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以会想到，在使用 eval 对 JSON 进行执行的时候，JSON 字符串通常被包含在一个圆括号里：<code>eval(&#39;(&#39; + json + &#39;)&#39;)</code>，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  &#123; &quot;x&quot;: 5 &#125;; // &quot;&#123;&quot; 和 &quot;&#125;&quot; 做解析成代码块</div><div class="line">&#125; catch(err) &#123;</div><div class="line">  // SyntaxError</div><div class="line">&#125;</div><div class="line">(&#123; &quot;x&quot;: 5 &#125;); // 分组操作符强制将&quot;&#123;&quot; 和 &quot;&#125;&quot;作为对象字面量来解析</div></pre></td></tr></table></figure>
<p>表达式和声明存在着十分微妙的差别，首先，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，参考如下例子，函数 fn 是在 alert 之后声明的，但是在 alert 执行的时候，fn已经有定义了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(fn());</div><div class="line">function fn() &#123;</div><div class="line">  return &apos;Hello world!&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外，还有一点需要提醒一下，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 千万别这样做！</div><div class="line">// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个</div><div class="line">if (true) &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    return &apos;first&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    return &apos;second&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 相反，这样情况，我们要用函数表达式</div><div class="line">var foo;</div><div class="line">if (true) &#123;</div><div class="line">  foo = function() &#123;</div><div class="line">    return &apos;first&apos;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  foo = function() &#123;</div><div class="line">    return &apos;second&apos;;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>函数声明的实际规则如下：</p>
<p>函数声明只能出现在程序或函数体内。从句法上讲，它们不能出现在 Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含 Statement 语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在 Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字 function 开头。而这实际上就是说，函数表达式同样也不能出现在 Statement 语句或 Block（块）中（因为 Block（块）就是由 Statement 语句构成的）。</p>
<h2 id="函数语句"><a href="#函数语句" class="headerlink" title="函数语句"></a>函数语句</h2><p>在 ECMAScript 的语法扩展中，有一个是函数语句，目前只有基于 Gecko 的浏览器实现了该扩展，所以对于下面的例子，我们仅是抱着学习的目的来看，一般来说不推荐使用（除非你针对 Gecko 浏览器进行开发）。</p>
<p>1.一般语句能用的地方，函数语句也能用，当然也包括 Block 块中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function f()&#123; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function f()&#123; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.函数语句可以像其他语句一样被解析，包含基于条件执行的情形</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // 1</div><div class="line">// 注：其它客户端会将foo解析成函数声明 </div><div class="line">// 因此，第二个foo会覆盖第一个，结果返回2，而不是1</div></pre></td></tr></table></figure>
<p>3.函数语句不是在变量初始化期间声明的，而是在运行时声明的——与函数表达式一样。不过，函数语句的标识符一旦声明能在函数的整个作用域生效了。标识符有效性正是导致函数语句与函数表达式不同的关键所在（下一小节我们将会展示命名函数表达式的具体行为）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 此刻，foo还没用声明</div><div class="line">typeof foo; // &quot;undefined&quot;</div><div class="line">if (true) &#123;</div><div class="line">  // 进入这里以后，foo就被声明在整个作用域内了</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  // 从来不会走到这里，所以这里的foo也不会被声明</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">typeof foo; // &quot;function&quot;</div></pre></td></tr></table></figure>
<p>不过，我们可以使用下面这样的符合标准的代码来模式上面例子中的函数语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var foo;</div><div class="line">if (true) &#123;</div><div class="line">  foo = function foo()&#123; return 1; &#125;;</div><div class="line">&#125;</div><div class="line">else &#123;</div><div class="line">  foo = function foo() &#123; return 2; &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.函数语句和函数声明（或命名函数表达式）的字符串表示类似，也包括标识符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 1; &#125;</div><div class="line">&#125;</div><div class="line">String(foo); // function foo() &#123; return 1; &#125;</div></pre></td></tr></table></figure>
<p>5.另外一个，早期基于 Gecko 的实现（Firefox 3 及以前版本）中存在一个 bug，即函数语句覆盖函数声明的方式不正确。在这些早期的实现中，函数语句不知何故不能覆盖函数声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function foo()&#123; return 1; &#125;</div><div class="line">if (true) &#123;</div><div class="line">  // 用函数语句重写</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // FF3以下返回1，FF3.5以上返回2</div><div class="line">// 不过，如果前面是函数表达式，则没用问题</div><div class="line">var foo = function()&#123; return 1; &#125;;</div><div class="line">if (true) &#123;</div><div class="line">  function foo()&#123; return 2; &#125;</div><div class="line">&#125;</div><div class="line">foo(); // 所有版本都返回2</div></pre></td></tr></table></figure>
<p>再次强调一点，上面这些例子只是在某些浏览器支持，所以推荐大家不要使用这些，除非你就在特性的浏览器上做开发。</p>
<h2 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h2><p>函数表达式在实际应用中还是很常见的，在 web 开发中友个常用的模式是基于对某种特性的测试来伪装函数定义，从而达到性能优化的目的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 该代码来自Garrett Smith的APE Javascript library库(http://dhtmlkitchen.com/ape/) </div><div class="line">var contains = (function() &#123;</div><div class="line">  var docEl = document.documentElement;</div><div class="line">  if (typeof docEl.compareDocumentPosition != &apos;undefined&apos;) &#123;</div><div class="line">    return function(el, b) &#123;</div><div class="line">      return (el.compareDocumentPosition(b) &amp; 16) !== 0;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (typeof docEl.contains != &apos;undefined&apos;) &#123;</div><div class="line">    return function(el, b) &#123;</div><div class="line">      return el !== b &amp;&amp; el.contains(b);</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  return function(el, b) &#123;</div><div class="line">    if (el === b) return false;</div><div class="line">    while (el != b &amp;&amp; (b = b.parentNode) != null);</div><div class="line">    return el === b;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子 var bar = function foo(){}；就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = function foo()&#123;</div><div class="line">  return typeof foo; // foo是在内部作用域内有效</div><div class="line">&#125;;</div><div class="line">// foo在外部用于是不可见的</div><div class="line">typeof foo; // &quot;undefined&quot;</div><div class="line">f(); // &quot;function&quot;</div></pre></td></tr></table></figure>
<p>既然，这么要求，那命名函数表达式到底有啥用啊？为啥要取名？</p>
<p>正如我们开头所说：给它一个名字就是可以让调试过程更方便，因为在调试的时候，如果在调用栈中的每个项都有自己的名字来描述，那么调试过程就太爽了，感受不一样嘛。</p>
<h2 id="调试器中的函数名"><a href="#调试器中的函数名" class="headerlink" title="调试器中的函数名"></a>调试器中的函数名</h2><p>如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色，可是通常情况下，这些调试器只安装简单的规则来取名，所以说没有太大价格，我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">function bar()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 这里我们使用了3个带名字的函数声明</div><div class="line">// 所以当调试器走到debugger语句的时候，Firebug的调用栈上看起来非常清晰明了 </div><div class="line">// 因为很明白地显示了名称</div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure>
<p>通过查看调用栈的信息，我们可以很明了地知道 foo 调用了 bar，bar 又调用了 baz（而 foo 本身有在 expr_test.html 文档的全局作用域内被调用），不过，还有一个比较爽地方，就是刚才说的 Firebug 为匿名表达式取名的功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = function()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">// Call stack</div><div class="line">baz</div><div class="line">bar() //看到了么？ </div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure>
<p>然后，当函数表达式稍微复杂一些的时候，调试器就不那么聪明了，我们只能在调用栈中看到问号：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = (function()&#123;</div><div class="line">  if (window.addEventListener) &#123;</div><div class="line">    return function()&#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (window.attachEvent) &#123;</div><div class="line">    return function() &#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">// Call stack</div><div class="line">baz</div><div class="line">(?)() // 这里可是问号哦</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure>
<p>另外，当把函数赋值给多个变量的时候，也会出现令人郁闷的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return baz();</div><div class="line">&#125;</div><div class="line">var bar = function()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;;</div><div class="line">var baz = bar;</div><div class="line">bar = function() &#123; </div><div class="line">  alert(&apos;spoofed&apos;);</div><div class="line">&#125;;</div><div class="line">foo();</div><div class="line">// Call stack:</div><div class="line">bar()</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure>
<p>这时候，调用栈显示的是 foo 调用了 bar，但实际上并非如此，之所以有这种问题，是因为 baz 和另外一个包含 alert(‘spoofed’)的函数做了引用交换所导致的。</p>
<p>归根结底，只有给函数表达式取个名字，才是最委托的办法，也就是使用命名函数表达式。我们来使用带名字的表达式来重写上面的例子（注意立即调用的表达式块里返回的 2 个函数的名字都是 bar）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">  return bar();</div><div class="line">&#125;</div><div class="line">var bar = (function()&#123;</div><div class="line">  if (window.addEventListener) &#123;</div><div class="line">    return function bar()&#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">  else if (window.attachEvent) &#123;</div><div class="line">    return function bar() &#123;</div><div class="line">      return baz();</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line">&#125;)();</div><div class="line">function baz()&#123;</div><div class="line">  debugger;</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">// 又再次看到了清晰的调用栈信息了耶!</div><div class="line">baz</div><div class="line">bar</div><div class="line">foo</div><div class="line">expr_test.html()</div></pre></td></tr></table></figure>
<p>OK，又学了一招吧？不过在高兴之前，我们再看看不同寻常的 JScript 吧。</p>
<h2 id="JScript的Bug"><a href="#JScript的Bug" class="headerlink" title="JScript的Bug"></a>JScript的Bug</h2><p>比较恶的是，IE 的 ECMAScrip t实现 JScript 严重混淆了命名函数表达式，搞得现很多人都出来反对命名函数表达式，而且即便是最新的一版（IE8 中使用的 5.8 版）仍然存在下列问题。</p>
<p>下面我们就来看看IE在实现中究竟犯了那些错误，俗话说知已知彼，才能百战不殆。我们来看看如下几个例子：</p>
<p>例 1：函数表达式的标示符泄露到外部作用域</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">typeof g; // &quot;function&quot;</div></pre></td></tr></table></figure>
<p>上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但 JScript 明显是违反了这一规范，上面例子中的标示符 g 被解析成函数对象，这就乱了套了，很多难以发现的 bug 都是因为这个原因导致的。</p>
<p><em>注：IE9 貌似已经修复了这个问题</em></p>
<p>例 2：将命名函数表达式同时当作函数声明和函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">typeof g; // &quot;function&quot;</div><div class="line">var f = function g()&#123;&#125;;</div></pre></td></tr></table></figure>
<p>特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是 JScript 实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了 g。</p>
<p>这个例子引出了下一个例子。</p>
<p>例 3：命名函数表达式会创建两个截然不同的函数对象！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">f === g; // false</div><div class="line">f.expando = &apos;foo&apos;;</div><div class="line">g.expando; // undefined</div></pre></td></tr></table></figure>
<p>看到这里，大家会觉得问题严重了，因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建 2 个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的 g 的同名属性来使用，那问题就大了，因为根本就不可能。</p>
<p>再来看一个稍微复杂的例子：</p>
<p>例 4：仅仅顺序解析函数声明而忽略条件语句块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = function g() &#123;</div><div class="line">  return 1;</div><div class="line">&#125;;</div><div class="line">if (false) &#123;</div><div class="line">  f = function g()&#123;</div><div class="line">    return 2;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">g(); // 2</div></pre></td></tr></table></figure>
<p>这个 bug 查找就难多了，但导致 bug 的原因却非常简单。首先，g 被当作函数声明解析，由于 JScript 中的函数声明不受条件代码块约束，所以在这个很恶的 if 分支中，g 被当作另一个函数 function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时 f 被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入这个可恶 if 分支，因此 f 就会继续引用第一个函数 function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了 g，那么将会调用一个毫不相干的 g 函数对象。</p>
<p>你可能会问，将不同的对象和 arguments.callee 相比较时，有什么样的区别呢？我们来看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;</div><div class="line">   return [</div><div class="line">     arguments.callee == f,</div><div class="line">     arguments.callee == g</div><div class="line">   ];</div><div class="line"> &#125;;</div><div class="line"> f(); // [true, false]</div><div class="line"> g(); // [false, true]</div></pre></td></tr></table></figure>
<p>可以看到，arguments.callee 的引用一直是被调用的函数，实际上这也是好事，稍后会解释。</p>
<p>还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  f = function f()&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>按照代码的分析，我们原本是想创建一个全局属性 f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript 在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的 function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p>
<p>了解了 JScript 这么变态以后，我们就要及时预防这些问题了，首先<strong>防范标识符泄漏带外部作用域</strong>，其次，应该<strong>永远不引用被用作函数名称的标识符</strong>；还记得前面例子中那个讨人厌的标识符 g 吗？——如果我们能够当 g 不 存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过 f 或者 arguments.callee 来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把命名函数表达式声明期间错误创建的函数清理干净。</p>
<p>对于，上面最后一点，我们还得再解释一下。</p>
<h2 id="JScript-的内存管理"><a href="#JScript-的内存管理" class="headerlink" title="JScript 的内存管理"></a>JScript 的内存管理</h2><p>知道了这些不符合规范的代码解析 bug 以后，我们如果用它的话，就会发现内存方面其实是有问题的，来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">  if (true) &#123;</div><div class="line">    return function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  return function g()&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们知道，这个匿名函数调用返回的函数（带有标识符 g 的函数），然后赋值给了外部的 f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的 g 函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为 if 语句内部的函数与 g 是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对 g 函数的引用，否则它一直占着内存不放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">  var f, g;</div><div class="line">  if (true) &#123;</div><div class="line">    f = function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    f = function g()&#123;&#125;;</div><div class="line">  &#125;</div><div class="line">  // 设置g为null以后它就不会再占内存了</div><div class="line">  g = null;</div><div class="line">  return f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>通过设置g为null，垃圾回收器就把g引用的那个隐式函数给回收掉了，为了验证我们的代码，我们来做一些测试，以确保我们的内存被回收了。</p>
<p>测试</p>
<p>测试很简单，就是命名函数表达式创建 10000 个函数，然后把它们保存在一个数组中。等一会儿以后再看这些函数到底占用了多少内存。然后，再断开这些引用并重复这一过程。下面是测试代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">function createFn()&#123;</div><div class="line">  return (function()&#123;</div><div class="line">    var f;</div><div class="line">    if (true) &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;standard&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    else if (false) &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;alternative&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">      f = function F()&#123;</div><div class="line">        return &apos;fallback&apos;;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line">    // var F = null;</div><div class="line">    return f;</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line">var arr = [ ];</div><div class="line">for (var i=0; i&lt;10000; i++) &#123;</div><div class="line">  arr[i] = createFn();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过运行在 Windows XP SP2 中的任务管理器可以看到如下结果：</p>
<p>IE6:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">without `null`:   7.6K -&gt; 20.3K</div><div class="line">with `null`:      7.6K -&gt; 18K</div></pre></td></tr></table></figure>
<p>IE7:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">without `null`:   14K -&gt; 29.7K</div><div class="line">with `null`:      14K -&gt; 27K</div></pre></td></tr></table></figure>
<p>如我们所料，显示断开引用可以释放内存，但是释放的内存不是很多，10000 个函数对象才释放大约 3M 的内存，这对一些小型脚本不算什么，但对于大型程序，或者长时间运行在低内存的设备里的时候，这是非常有必要的。</p>
<p>关于在 Safari 2.x 中 JS 的解析也有一些 bug，但介于版本比较低，所以我们在这里就不介绍了，大家如果想看的话，请仔细查看英文资料。</p>
<h2 id="SpiderMonkey-的怪癖"><a href="#SpiderMonkey-的怪癖" class="headerlink" title="SpiderMonkey 的怪癖"></a>SpiderMonkey 的怪癖</h2><p>大家都知道，命名函数表达式的标识符只在函数的局部作用域中有效。但包含这个标识符的局部作用域又是什么样子的吗？其实非常简单。在命名函数表达式被求值时，会创建一个特殊的对象，该对象的唯一目的就是保存一个属性，而这个属性的名字对应着函数标识符，属性的值对应着那个函数。这个对象会被注入到当前作用域链的前端。然后，被“扩展”的作用域链又被用于初始化函数。</p>
<p>在这里，有一点十分有意思，那就是 ECMA-262 定义这个（保存函数标识符的）“特殊”对象的方式。标准说“像调用 new Object()表达式那样”创建这个对象。如果从字面上来理解这句话，那么这个对象就应该是全局 Object 的一个实例。然而，只有一个实现是按照标准字面上的要求这么做的，这个实现就是 SpiderMonkey。因此，在 SpiderMonkey 中，扩展 Object.prototype 有可能会干扰函数的局部作用域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = &apos;outer&apos;;</div><div class="line">(function()&#123;</div><div class="line">  var x = &apos;inner&apos;;</div><div class="line">  /*</div><div class="line">    函数foo的作用域链中有一个特殊的对象——用于保存函数的标识符。这个特殊的对象实际上就是&#123; foo: &lt;function object&gt; &#125;。</div><div class="line">    当通过作用域链解析x时，首先解析的是foo的局部环境。如果没有找到x，则继续搜索作用域链中的下一个对象。下一个对象</div><div class="line">    就是保存函数标识符的那个对象——&#123; foo: &lt;function object&gt; &#125;，由于该对象继承自Object.prototype，所以在此可以找到x。</div><div class="line">    而这个x的值也就是Object.prototype.x的值（outer）。结果，外部函数的作用域（包含x = &apos;inner&apos;的作用域）就不会被解析了。</div><div class="line">  */</div><div class="line">  (function foo()&#123;</div><div class="line">    alert(x); // 提示框中显示：outer</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>不过，更高版本的 SpiderMonkey 改变了上述行为，原因可能是认为那是一个安全漏洞。也就是说，“特殊”对象不再继承 Object.prototype 了。不过，如果你使用 Firefox 3 或者更低版本，还可以“重温”这种行为。</p>
<p>另一个把内部对象实现为全局 Object 对象的是黑莓（Blackberry）浏览器。目前，它的活动对象（Activation Object）仍然继承 Object.prototype。可是，ECMA-262 并没有说活动对象也要“像调用 new Object()表达式那样”来创建（或者说像创建保存NFE标识符的对象一样创建）。 人家规范只说了活动对象是规范中的一种机制。</p>
<p>那我们就来看看黑莓里都发生了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = &apos;outer&apos;;</div><div class="line">(function()&#123;</div><div class="line">  var x = &apos;inner&apos;;</div><div class="line">  (function()&#123;</div><div class="line">    /*</div><div class="line">    在沿着作用域链解析x的过程中，首先会搜索局部函数的活动对象。当然，在该对象中找不到x。</div><div class="line">    可是，由于活动对象继承自Object.prototype，因此搜索x的下一个目标就是Object.prototype；而</div><div class="line">    Object.prototype中又确实有x的定义。结果，x的值就被解析为——outer。跟前面的例子差不多，</div><div class="line">    包含x = &apos;inner&apos;的外部函数的作用域（活动对象）就不会被解析了。</div><div class="line">    */ </div><div class="line">    alert(x); // 显示：outer</div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>不过神奇的还是，函数中的变量甚至会与已有的 Object.prototype 的成员发生冲突，来看看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  var constructor = function()&#123; return 1; &#125;;</div><div class="line">  (function()&#123;</div><div class="line">    constructor(); // 求值结果是&#123;&#125;（即相当于调用了Object.prototype.constructor()）而不是1</div><div class="line">    constructor === Object.prototype.constructor; // true</div><div class="line">    toString === Object.prototype.toString; // true</div><div class="line">    // …… </div><div class="line">  &#125;)();</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>要避免这个问题，要避免使用 Object.prototype 里的属性名称，如 toString，valueOf， hasOwnProperty 等等。</p>
<p>JScript解决方案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var fn = (function()&#123;</div><div class="line">  // 声明要引用函数的变量</div><div class="line">  var f;</div><div class="line">  // 有条件地创建命名函数</div><div class="line">  // 并将其引用赋值给f</div><div class="line">  if (true) &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  else if (false) &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    f = function F()&#123; &#125;</div><div class="line">  &#125;</div><div class="line">  // 声明一个与函数名（标识符）对应的变量，并赋值为null</div><div class="line">  // 这实际上是给相应标识符引用的函数对象作了一个标记，</div><div class="line">  // 以便垃圾回收器知道可以回收它了</div><div class="line">  var F = null;</div><div class="line">  // 返回根据条件定义的函数</div><div class="line">  return f;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>最后我们给出一个应用上述技术的应用实例，这是一个跨浏览器的 addEvent 函数代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// 1) 使用独立的作用域包含声明</div><div class="line">var addEvent = (function()&#123;</div><div class="line">  var docEl = document.documentElement;</div><div class="line">  // 2) 声明要引用函数的变量</div><div class="line">  var fn;</div><div class="line">  if (docEl.addEventListener) &#123;</div><div class="line">    // 3) 有意给函数一个描述性的标识符</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element.addEventListener(eventName, callback, false);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else if (docEl.attachEvent) &#123;</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element.attachEvent(&apos;on&apos; + eventName, callback);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  else &#123;</div><div class="line">    fn = function addEvent(element, eventName, callback) &#123;</div><div class="line">      element[&apos;on&apos; + eventName] = callback;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  // 4) 清除由JScript创建的addEvent函数</div><div class="line">  //    一定要保证在赋值前使用var关键字</div><div class="line">  //    除非函数顶部已经声明了addEvent</div><div class="line">  var addEvent = null;</div><div class="line">  // 5) 最后返回由fn引用的函数</div><div class="line">  return fn;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>其实，如果我们不想要这个描述性名字的话，我们就可以用最简单的形式来做，也就是在函数内部声明一个函数（而不是函数表达式），然后返回该函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var hasClassName = (function()&#123;</div><div class="line">  // 定义私有变量</div><div class="line">  var cache = &#123; &#125;;</div><div class="line">  // 使用函数声明</div><div class="line">  function hasClassName(element, className) &#123;</div><div class="line">    var _className = &apos;(?:^|\\s+)&apos; + className + &apos;(?:\\s+|$)&apos;;</div><div class="line">    var re = cache[_className] || (cache[_className] = new RegExp(_className));</div><div class="line">    return re.test(element.className);</div><div class="line">  &#125;</div><div class="line">  // 返回函数</div><div class="line">  return hasClassName;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>显然，当存在多个分支函数定义时，这个方案就不行了。不过有种模式貌似可以实现：那就是提前使用函数声明来定义所有函数，并分别为这些函数指定不同的标识符：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var addEvent = (function()&#123;</div><div class="line">  var docEl = document.documentElement;</div><div class="line">  function addEventListener()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line">  function attachEvent()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line">  function addEventAsProperty()&#123;</div><div class="line">    /* ... */</div><div class="line">  &#125;</div><div class="line">  if (typeof docEl.addEventListener != &apos;undefined&apos;) &#123;</div><div class="line">    return addEventListener;</div><div class="line">  &#125;</div><div class="line">  elseif (typeof docEl.attachEvent != &apos;undefined&apos;) &#123;</div><div class="line">    return attachEvent;</div><div class="line">  &#125;</div><div class="line">  return addEventAsProperty;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>虽然这个方案很优雅，但也不是没有缺点。第一，由于使用不同的标识符，导致丧失了命名的一致性。且不说这样好还是坏，最起码它不够清晰。有人喜欢使用相同的名字，但也有人根本不在乎字眼上的差别。可毕竟，不同的名字会让人联想到所用的不同实现。例如，在调试器中看到 attachEvent，我们就知 道 addEvent 是基于 attachEvent 的实现。当然，基于实现来命名的方式也不一定都行得通。假如我们要提供一个 API，并按照这种方式把函数命名为 inner。那么 API 用户的很容易就会被相应实现的 细节搞得晕头转向。</p>
<p>要解决这个问题，当然就得想一套更合理的命名方案了。但关键是不要再额外制造麻烦。我现在能想起来的方案大概有如下几个：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&apos;addEvent&apos;, &apos;altAddEvent&apos;, &apos;fallbackAddEvent&apos;</div><div class="line">// 或者</div><div class="line">&apos;addEvent&apos;, &apos;addEvent2&apos;, &apos;addEvent3&apos;</div><div class="line">// 或者</div><div class="line">&apos;addEvent_addEventListener&apos;, &apos;addEvent_attachEvent&apos;, &apos;addEvent_asProperty&apos;</div></pre></td></tr></table></figure>
<p>另外，这种模式还存在一个小问题，即增加内存占用。提前创建 N 个不同名字的函数，等于有 N-1 的函数是用不到的。具体来讲，如果 document.documentElement 中包含 attachEvent，那么 addEventListener 和 addEventAsProperty 则根本就用不着了。可是，他们都占着内存哪；而且，这些内存将永远都得不到释放，原因跟 JScript 臭哄哄的命名表达式相同——这两个函数都被“截留”在返回的那个函数的闭包中了。</p>
<p>不过，增加内存占用这个问题确实没什么大不了的。如果某个库——例如 Prototype.js ——采用了这种模式，无非也就是多创建一两百个函数而已。只要不是（在运行时）重复地创建这些函数，而是只（在加载时）创建一次，那么就没有什么好担心的。</p>
<h2 id="WebKit-的-displayName"><a href="#WebKit-的-displayName" class="headerlink" title="WebKit 的 displayName"></a>WebKit 的 displayName</h2><p>WebKit 团队在这个问题采取了有点儿另类的策略。介于匿名和命名函数如此之差的表现力，WebKit 引入了一个“特殊的”displayName 属性（本质上是一个字符串），如果开发人员为函数的这个属性赋值，则该属性的值将在调试器或性能分析器中被显示在函数“名称”的位置上。<a href="http://www.alertdebugging.com/2009/04/29/building-a-better-javascript-profiler-with-webkit/" target="_blank" rel="external">Francisco Tolmasky 详细地解释了这个策略的原理和实现。</a></p>
<h2 id="未来考虑"><a href="#未来考虑" class="headerlink" title="未来考虑"></a>未来考虑</h2><p>将来的 ECMAScript-262 第 5 版（目前还是草案）会引入所谓的<strong>严格模式（strict mode）</strong>。开启严格模式的实现会禁用语言中的那些不稳定、不可靠和不安全的特性。据说出于安全方面的考虑，arguments.callee 属性将在严格模式下被“封杀”。因此，在处于严格模式时，访问 arguments.callee 会导致 TypeError（参见 ECMA-262 第 5 版的 10.6 节）。而我之所以在此提到严格模式，是因为如果在基于第 5 版标准的实现中无法使用 arguments.callee 来执行递归操作，那么使用命名函数表达式的可能性就会大大增加。从这个意义上来说，理解命名函数表达式的语义及其 bug 也就显得更加重要了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 此前，你可能会使用arguments.callee</div><div class="line">(function(x) &#123;</div><div class="line">  if (x &lt;= 1) return 1;</div><div class="line">  return x * arguments.callee(x - 1);</div><div class="line">&#125;)(10);</div><div class="line">// 但在严格模式下，有可能就要使用命名函数表达式</div><div class="line">(function factorial(x) &#123;</div><div class="line">  if (x &lt;= 1) return 1;</div><div class="line">  return x * factorial(x - 1);</div><div class="line">&#125;)(10);</div><div class="line">// 要么就退一步，使用没有那么灵活的函数声明</div><div class="line">function factorial(x) &#123;</div><div class="line">  if (x &lt;= 1) return 1;</div><div class="line">  return x * factorial(x - 1);</div><div class="line">&#125;</div><div class="line">factorial(10);</div></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/01/16/深入理解javascript/11执行上下文（Execution Contexts）/"><span>执行上下文（Execution Contexts）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/01/16/深入理解javascript/11执行上下文（Execution Contexts）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-01-16T05:02:02.000Z">
          2016-01-16
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>从本章开始，我将陆续（翻译、转载、整理）<a href="http://dmitrysoshnikov.com/" target="_blank" rel="external">http://dmitrysoshnikov.com/</a>网站关于 ECMAScript 标标准理解的好文。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，即会进入到一个执行上下文。执行上下文(简称-EC)是 ECMA-262 标准里的一个抽象概念，用于同可执行代码(executable code)概念进行区分。</p>
<p>标准规范没有从技术实现的角度定义EC的准确类型和结构，这应该是具体实现 ECMAScript 引擎时要考虑的问题。</p>
<p>活动的执行上下文组在逻辑上组成一个堆栈。堆栈底部永远都是全局上下文(global context)，而顶部就是当前(活动的)执行上下文。堆栈在EC类型进入和退出上下文的时候被修改（推入或弹出）。</p>
<h2 id="可执行代码类型"><a href="#可执行代码类型" class="headerlink" title="可执行代码类型"></a>可执行代码类型</h2><p>可执行代码的类型这个概念与执行上下文的抽象概念是有关系的。在某些时刻，可执行代码与执行上下文完全有可能是等价的。</p>
<p>例如，我们可以定义执行上下文堆栈是一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ECStack = [];</div></pre></td></tr></table></figure>
<p>每次进入 function (即使 function 被递归调用或作为构造函数) 的时候或者内置的 eval 函数工作的时候，这个堆栈都会被压入。</p>
<h2 id="全局代码"><a href="#全局代码" class="headerlink" title="全局代码"></a>全局代码</h2><p>这种类型的代码是在”程序”级处理的：例如加载外部的 js 文件或者本地标签内的代码。全局代码不包括任何 function 体内的代码。</p>
<p>在初始化（程序启动）阶段，ECStack 是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div></pre></td></tr></table></figure>
<h2 id="函数代码"><a href="#函数代码" class="headerlink" title="函数代码"></a>函数代码</h2><p>当进入 funtion 函数代码(所有类型的 funtions)的时候，ECStack 被压入新元素。需要注意的是，具体的函数代码不包括内部函数(inner functions)代码。如下所示，我们使函数自己调自己的方式递归一次：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function  foo(bar) &#123;</div><div class="line">  if (bar) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  foo(true);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>那么，ECStack 以如下方式被改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 第一次foo的激活调用</div><div class="line">ECStack = [</div><div class="line">  &lt;foo&gt; functionContext</div><div class="line">  globalContext</div><div class="line">];</div><div class="line">// foo的递归激活调用</div><div class="line">ECStack = [</div><div class="line">  &lt;foo&gt; functionContext – recursively</div><div class="line">  &lt;foo&gt; functionContext</div><div class="line">  globalContext</div><div class="line">];</div></pre></td></tr></table></figure>
<p>每次 return 的时候，都会退出当前执行上下文的，相应地 ECStack 就会弹出，栈指针会自动移动位置，这是一个典型的堆栈实现方式。一个抛出的异常如果没被截获的话也有可能从一个或多个执行上下文退出。相关代码执行完以后，ECStac k只会包含全局上下文(global context)，一直到整个应用程序结束。</p>
<h2 id="Eval-代码"><a href="#Eval-代码" class="headerlink" title="Eval 代码"></a>Eval 代码</h2><p>eval 代码有点儿意思。它有一个概念： 调用上下文(calling context),例如，eval 函数调用的时候产生的上下文。eval(变量或函数声明)活动会影响调用上下文(calling context)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eval(&apos;var x = 10&apos;);</div><div class="line">(function foo() &#123;</div><div class="line">  eval(&apos;var y = 20&apos;);</div><div class="line">&#125;)();</div><div class="line">alert(x); // 10</div><div class="line">alert(y); // &quot;y&quot; 提示没有声明</div></pre></td></tr></table></figure>
<p>ECStac k的变化过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">ECStack = [</div><div class="line">  globalContext</div><div class="line">];</div><div class="line">// eval(&apos;var x = 10&apos;);</div><div class="line">ECStack.push(</div><div class="line">  evalContext,</div><div class="line">  callingContext: globalContext</div><div class="line">);</div><div class="line">// eval exited context</div><div class="line">ECStack.pop();</div><div class="line">// foo funciton call</div><div class="line">ECStack.push(&lt;foo&gt; functionContext);</div><div class="line">// eval(&apos;var y = 20&apos;);</div><div class="line">ECStack.push(</div><div class="line">  evalContext,</div><div class="line">  callingContext: &lt;foo&gt; functionContext</div><div class="line">);</div><div class="line">// return from eval</div><div class="line">ECStack.pop();</div><div class="line">// return from foo</div><div class="line">ECStack.pop();</div></pre></td></tr></table></figure>
<p>也就是一个非常普通的逻辑调用堆栈。</p>
<p>在版本号 1.7 以上的 SpiderMonkey(内置于 Firefox，Thunderbird)的实现中，可以把调用上下文作为第二个参数传递给 eval。那么，如果这个上下文存在，就有可能影响“私有”(有人喜欢这样叫它)变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 1;</div><div class="line">  return function () &#123; alert(x); &#125;;</div><div class="line">&#125;;</div><div class="line">var bar = foo();</div><div class="line">bar(); // 1</div><div class="line">eval(&apos;x = 2&apos;, bar); // 传入上下文，影响了内部的var x 变量</div><div class="line">bar(); // 2</div></pre></td></tr></table></figure>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章是后面分析其他跟执行上下文相关的主题(例如变量对象，作用域链，等等)的最起码的理论基础，这些主题将在后续章节中讲到。</p>
<h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p>这篇文章的内容在 ECMA-262-3 标准规范中对应的章节<a href="http://bclary.com/2004/11/07/#a-10" target="_blank" rel="external">— 10. Execution Contexts</a>。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/01/15/深入理解javascript/14作用域链(Scope Chain)/"><span>作用域链(Scope Chain)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/01/15/深入理解javascript/14作用域链(Scope Chain)/" rel="bookmark">
        <time class="entry-date published" datetime="2016-01-15T09:02:02.000Z">
          2016-01-15
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>在第 12 章关于变量对象的描述中，我们已经知道一个执行上下文的数据（变量、函数声明和函数的形参）作为属性存储在变量对象中。</p>
<p>同时我们也知道变量对象在每次进入上下文时创建，并填入初始值，值的更新出现在代码执行阶段。</p>
<p>这一章专门讨论与执行上下文直接相关的更多细节，这次我们将提及一个议题——作用域链。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果要简要的描述并展示其重点，那么作用域链大多数与内部函数相关。</p>
<p>我们知道，ECMAScript 允许创建内部函数，我们甚至能从父函数中返回这些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123; </div><div class="line">  var y = 20; </div><div class="line">  function bar() &#123;</div><div class="line">    alert(x + y);</div><div class="line">  &#125; </div><div class="line">  return bar; </div><div class="line">&#125;</div><div class="line">foo()(); // 30</div></pre></td></tr></table></figure>
<p>这样，很明显每个上下文拥有自己的变量对象：对于全局上下文，它是全局对象自身；对于函数，它是活动对象。</p>
<p>作用域链正是内部上下文所有变量对象（包括父变量对象）的列表。此链用来变量查询。即在上面的例子中，“bar”上下文的作用域链包括 AO(bar)、AO(foo)和 VO(global)。</p>
<p>但是，让我们仔细研究这个问题。</p>
<p>让我们从定义开始，并进深一步的讨论示例。</p>
<blockquote>
<p>作用域链与一个执行上下文相关，变量对象的链用于在标识符解析中变量查找。</p>
</blockquote>
<p>函数上下文的作用域链在函数调用时创建的，包含活动对象和这个函数内部的[[scope]]属性。下面我们将更详细的讨论一个函数的[[scope]]属性。</p>
<p>在上下文中示意如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">activeExecutionContext = &#123;</div><div class="line">    VO: &#123;...&#125;, // or AO</div><div class="line">    this: thisValue,</div><div class="line">    Scope: [ // Scope chain</div><div class="line">      // 所有变量对象的列表</div><div class="line">      // for identifiers lookup</div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其 scope 定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = AO + [[Scope]]</div></pre></td></tr></table></figure>
<p>这种联合和标识符解析过程，我们将在下面讨论，这与函数的生命周期相关。</p>
<h2 id="函数的生命周期"><a href="#函数的生命周期" class="headerlink" title="函数的生命周期"></a>函数的生命周期</h2><p>函数的的生命周期分为创建和激活阶段（调用时），让我们详细研究它。</p>
<h3 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h3><p>众所周知，在进入上下文时函数声明放到变量/活动（VO/AO）对象中。让我们看看在全局上下文中的变量和函数声明（这里变量对象是全局对象自身，我们还记得，是吧？）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  alert(x + y);</div><div class="line">&#125;</div><div class="line">foo(); // 30</div></pre></td></tr></table></figure>
<p>在函数激活时，我们得到正确的（预期的）结果－－30。但是，有一个很重要的特点。</p>
<p>此前，我们仅仅谈到有关当前上下文的变量对象。这里，我们看到变量“y”在函数“foo”中定义（意味着它在 foo 上下文的 AO 中），但是变量“x”并未在“foo”上下文中定义，相应地，它也不会添加到“foo”的 AO 中。乍一看，变量“x”相对于函数“foo”根本就不存在；但正如我们在下面看到的——也仅仅是“一瞥”，我们发现，“foo”上下文的活动对象中仅包含一个属性－－“y”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fooContext.AO = &#123;</div><div class="line">  y: undefined // undefined – 进入上下文的时候是20 – at activation</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>函数“foo”如何访问到变量“x”？理论上函数应该能访问一个更高一层上下文的变量对象。实际上它正是这样，这种机制是通过函数内部的[[scope]]属性来实现的。</p>
<p>[[scope]]是所有父变量对象的层级链，处于当前函数上下文之上，在函数创建时存于其中。</p>
<p>注意这重要的一点－－[[scope]]在函数创建时被存储－－静态（不变的），永远永远，直至函数销毁。即：函数可以永不调用，但[[scope]]属性已经写入，并存储在函数对象中。</p>
<p>另外一个需要考虑的是－－与作用域链对比，[[scope]]是函数的一个属性而不是上下文。考虑到上面的例子，函数“foo”的[[scope]]如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.[[Scope]] = [</div><div class="line">  globalContext.VO // === Global</div><div class="line">];</div></pre></td></tr></table></figure>
<p>举例来说，我们用通常的 ECMAScript 数组展现作用域和[[scope]]。</p>
<p>继续，我们知道在函数调用时进入上下文，这时候活动对象被创建，this 和作用域（作用域链）被确定。让我们详细考虑这一时刻。</p>
<h3 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h3><p>正如在定义中说到的，进入上下文创建 AO/VO 之后，上下文的 Scope 属性（变量查找的一个作用域链）作如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = AO|VO + [[Scope]]</div></pre></td></tr></table></figure>
<p>上面代码的意思是：活动对象是作用域数组的第一个对象，即添加到作用域的前端。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = [AO].concat([[Scope]]);</div></pre></td></tr></table></figure>
<p>这个特点对于标示符解析的处理来说很重要。</p>
<p>标示符解析是一个处理过程，用来确定一个变量（或函数声明）属于哪个变量对象。</p>
<p>这个算法的返回值中，我们总有一个引用类型，它的 base 组件是相应的变量对象（或若未找到则为 null），属性名组件是向上查找的标示符的名称。引用类型的详细信息在第 13 章 .this 中已讨论。</p>
<p>标识符解析过程包含与变量名对应属性的查找，即作用域中变量对象的连续查找，从最深的上下文开始，绕过作用域链直到最上层。</p>
<p>这样一来，在向上查找中，一个上下文中的局部变量较之于父作用域的变量拥有较高的优先级。万一两个变量有相同的名称但来自不同的作用域，那么第一个被发现的是在最深作用域中。</p>
<p>我们用一个稍微复杂的例子描述上面讲到的这些。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  function bar() &#123;</div><div class="line">    var z = 30;</div><div class="line">    alert(x +  y + z);</div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">foo(); // 60</div></pre></td></tr></table></figure>
<p>对此，我们有如下的变量/活动对象，函数的的[[scope]]属性以及上下文的作用域链：</p>
<p>全局上下文的变量对象是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">globalContext.VO === Global = &#123;</div><div class="line">  x: 10</div><div class="line">  foo: &lt;reference to function&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在“foo”创建时，“foo”的[[scope]]属性是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">foo.[[Scope]] = [</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure>
<p>在“foo”激活时（进入上下文），“foo”上下文的活动对象是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fooContext.AO = &#123;</div><div class="line">  y: 20,</div><div class="line">  bar: &lt;reference to function&gt;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>“foo”上下文的作用域链为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">fooContext.Scope = fooContext.AO + foo.[[Scope]] // i.e.:</div><div class="line">fooContext.Scope = [</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure>
<p>内部函数“bar”创建时，其[[scope]]为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bar.[[Scope]] = [</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure>
<p>在“bar”激活时，“bar”上下文的活动对象为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">barContext.AO = &#123;</div><div class="line">  z: 30</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>“bar”上下文的作用域链为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">barContext.Scope = barContext.AO + bar.[[Scope]] // i.e.:</div><div class="line">barContext.Scope = [</div><div class="line">  barContext.AO,</div><div class="line">  fooContext.AO,</div><div class="line">  globalContext.VO</div><div class="line">];</div></pre></td></tr></table></figure>
<p>对“x”、“y”、“z”的标识符解析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- &quot;x&quot;</div><div class="line">-- barContext.AO // not found</div><div class="line">-- fooContext.AO // not found</div><div class="line">-- globalContext.VO // found - 10</div><div class="line">- &quot;y&quot;</div><div class="line">-- barContext.AO // not found</div><div class="line">-- fooContext.AO // found - 20</div><div class="line">- &quot;z&quot;</div><div class="line">-- barContext.AO // found - 30</div></pre></td></tr></table></figure>
<h2 id="作用域特征"><a href="#作用域特征" class="headerlink" title="作用域特征"></a>作用域特征</h2><p>让我们看看与作用域链和函数[[scope]]属性相关的一些重要特征。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>在 ECMAScript 中，闭包与函数的[[scope]]直接相关，正如我们提到的那样，[[scope]]在函数创建时被存储，与函数共存亡。实际上，闭包是函数代码和其[[scope]]的结合。因此，作为其对象之一，[[Scope]]包括在函数内创建的词法作用域（父变量对象）。当函数进一步激活时，在变量对象的这个词法链（静态的存储于创建时）中，来自较高作用域的变量将被搜寻。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">(function () &#123;</div><div class="line">  var x = 20;</div><div class="line">  foo(); // 10, but not 20</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>我们再次看到，在标识符解析过程中，使用函数创建时定义的词法作用域－－变量解析为 10，而不是 30。此外，这个例子也清晰的表明，一个函数（这个例子中为从函数“foo”返回的匿名函数）的[[scope]]持续存在，即使是在函数创建的作用域已经完成之后。</p>
<p>关于 ECMAScript 中闭包的理论和其执行机制的更多细节，阅读 16 章闭包。</p>
<h2 id="通过构造函数创建的函数的-scope"><a href="#通过构造函数创建的函数的-scope" class="headerlink" title="通过构造函数创建的函数的[[scope]]"></a>通过构造函数创建的函数的[[scope]]</h2><p>在上面的例子中，我们看到，在函数创建时获得函数的[[scope]]属性，通过该属性访问到所有父上下文的变量。但是，这个规则有一个重要的例外，它涉及到通过函数构造函数创建的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  var y = 20;</div><div class="line">  function barFD() &#123; // 函数声明</div><div class="line">    alert(x);</div><div class="line">    alert(y);</div><div class="line">  &#125;</div><div class="line">  var barFE = function () &#123; // 函数表达式</div><div class="line">    alert(x);</div><div class="line">    alert(y);</div><div class="line">  &#125;;</div><div class="line">  var barFn = Function(&apos;alert(x); alert(y);&apos;);</div><div class="line">  barFD(); // 10, 20</div><div class="line">  barFE(); // 10, 20</div><div class="line">  barFn(); // 10, &quot;y&quot; is not defined</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>我们看到，通过函数构造函数（Function constructor）创建的函数“bar”，是不能访问变量“y”的。但这并不意味着函数“barFn”没有[[scope]]属性（否则它不能访问到变量“x”）。问题在于通过函构造函数创建的函数的[[scope]]属性总是唯一的全局对象。考虑到这一点，如通过这种函数创建除全局之外的最上层的上下文闭包是不可能的。</p>
<h2 id="二维作用域链查找"><a href="#二维作用域链查找" class="headerlink" title="二维作用域链查找"></a>二维作用域链查找</h2><p>在作用域链中查找最重要的一点是变量对象的属性（如果有的话）须考虑其中－－源于 ECMAScript 的原型特性。如果一个属性在对象中没有直接找到，查询将在原型链中继续。即常说的二维链查找。（1）作用域链环节；（2）每个作用域链－－深入到原型链环节。如果在 Object.prototype 中定义了属性，我们能看到这种效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">Object.prototype.x = 10;</div><div class="line">foo(); // 10</div></pre></td></tr></table></figure>
<p>活动对象没有原型，我们可以在下面的例子中看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 20;</div><div class="line">  function bar() &#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">Object.prototype.x = 10;</div><div class="line">foo(); // 20</div></pre></td></tr></table></figure>
<p>如果函数“bar”上下文的激活对象有一个原型，那么“x”将在 Object.prototype 中被解析，因为它在 AO 中不被直接解析。但在上面的第一个例子中，在标识符解析中，我们到达全局对象（在一些执行中并不全是这样），它从 Object.prototype 继承而来，响应地，“x”解析为 10。</p>
<p>同样的情况出现在一些版本的 SpiderMokey 的命名函数表达式（缩写为 NFE）中，在那里特定的对象存储从 Object.prototype 继承而来的函数表达式的可选名称，在 Blackberry 中的一些版本中，执行时激活对象从 Object.prototype 继承。但是，关于该特色的更多细节在第 15 章函数讨论。</p>
<h2 id="全局和-eval-上下文中的作用域链"><a href="#全局和-eval-上下文中的作用域链" class="headerlink" title="全局和 eval 上下文中的作用域链"></a>全局和 eval 上下文中的作用域链</h2><p>这里不一定很有趣，但必须要提示一下。全局上下文的作用域链仅包含全局对象。代码 eval 的上下文与当前的调用上下文（calling context）拥有同样的作用域链。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">globalContext.Scope = [</div><div class="line">  Global</div><div class="line">];</div><div class="line">evalContext.Scope === callingContext.Scope;</div></pre></td></tr></table></figure>
<h2 id="代码执行时对作用域链的影响"><a href="#代码执行时对作用域链的影响" class="headerlink" title="代码执行时对作用域链的影响"></a>代码执行时对作用域链的影响</h2><p>在 ECMAScript 中，在代码执行阶段有两个声明能修改作用域链。这就是 with 声明和 catch 语句。它们添加到作用域链的最前端，对象须在这些声明中出现的标识符中查找。如果发生其中的一个，作用域链简要的作如下修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = withObject|catchObject + AO|VO + [[Scope]]</div></pre></td></tr></table></figure>
<p>在这个例子中添加对象，对象是它的参数（这样，没有前缀，这个对象的属性变得可以访问）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10, y: 20&#125;;</div><div class="line">with (foo) &#123;</div><div class="line">  alert(x); // 10</div><div class="line">  alert(y); // 20</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用域链修改成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Scope = foo + AO|VO + [[Scope]]</div></pre></td></tr></table></figure>
<p>我们再次看到，通过 with 语句，对象中标识符的解析添加到作用域链的最前端：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var x = 10, y = 10;</div><div class="line">with (&#123;x: 20&#125;) &#123;</div><div class="line">  var x = 30, y = 30;</div><div class="line">  alert(x); // 30</div><div class="line">  alert(y); // 30</div><div class="line">&#125;</div><div class="line">alert(x); // 10</div><div class="line">alert(y); // 30</div></pre></td></tr></table></figure>
<p>在进入上下文时发生了什么？标识符“x”和“y”已被添加到变量对象中。此外，在代码运行阶段作如下修改：</p>
<ol>
<li>x = 10, y = 10；</li>
<li>对象{x:20}添加到作用域的前端；</li>
<li>在 with 内部，遇到了 var 声明，当然什么也没创建，因为在进入上下文时，所有变量已被解析添加；</li>
<li>在第二步中，仅修改变量“x”，实际上对象中的“x”现在被解析，并添加到作用域链的最前端，“x”为20，变为 30；</li>
<li>同样也有变量对象“y”的修改，被解析后其值也相应的由 10 变为 30；</li>
<li>此外，在 with 声明完成后，它的特定对象从作用域链中移除（已改变的变量“x”－－30也从那个对象中移除），即作用域链的结构恢复到 with 得到加强以前的状态。</li>
<li>在最后两个 alert 中，当前变量对象的“x”保持同一，“y”的值现在等于30，在with声明运行中已发生改变。</li>
</ol>
<p>同样，catch 语句的异常参数变得可以访问，它创建了只有一个属性的新对象－－异常参数名。图示看起来像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">try &#123;</div><div class="line">  ...</div><div class="line">&#125; catch (ex) &#123;</div><div class="line">  alert(ex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>作用域链修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var catchObject = &#123;</div><div class="line">  ex: &lt;exception object&gt;</div><div class="line">&#125;;</div><div class="line">Scope = catchObject + AO|VO + [[Scope]]</div></pre></td></tr></table></figure>
<p>在 catch 语句完成运行之后，作用域链恢复到以前的状态。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在这个阶段，我们几乎考虑了与执行上下文相关的所有常用概念，以及与它们相关的细节。按照计划－－函数对象的详细分析：函数类型（函数声明，函数表达式）和闭包。顺便说一下，在这篇文章中，闭包直接与[[scope]]属性相关，但是，关于它将在合适的篇章中讨论。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://bclary.com/2004/11/07/#a-8.6.2" target="_blank" rel="external">[[Scope]]</a></li>
<li><a href="http://bclary.com/2004/11/07/#a-10.1.4" target="_blank" rel="external">Scope Chain and Identifier Resolution</a></li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/01/12/深入理解javascript/1编写高质量 JavaScript 代码的基本要点/"><span>编写高质量javascript代码</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/01/12/深入理解javascript/1编写高质量 JavaScript 代码的基本要点/" rel="bookmark">
        <time class="entry-date published" datetime="2016-01-12T07:02:02.000Z">
          2016-01-12
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>此摘要也包括一些与代码不太相关的习惯，但对整体代码的创建息息相关，包括撰写 API 文档、执行同行评审以及运行 JSLint。这些习惯和最佳做法可以帮助你写出更好的，更易于理解和维护的代码，这些代码在几个月或是几年之后再回过头看看也是会觉得很自豪的。</p>
<h2 id="书写可维护的代码-Writing-Maintainable-Code"><a href="#书写可维护的代码-Writing-Maintainable-Code" class="headerlink" title="书写可维护的代码(Writing Maintainable Code )"></a>书写可维护的代码(Writing Maintainable Code )</h2><p>软件 bug 的修复是昂贵的，并且随着时间的推移，这些 bug 的成本也会增加，尤其当这些 bug 潜伏并慢慢出现在已经发布的软件中时。当你发现 bug 的时候就立即修复它是最好的，此时你代码要解决的问题在你脑中还是很清晰的。否则，你转移到其他任务，忘了那个特定的代码，一段时间后再去查看这些代码就 需要：</p>
<ul>
<li>花时间学习和理解这个问题</li>
<li>花时间是了解应该解决的问题代码</li>
</ul>
<p>还有问题，特别对于大的项目或是公司，修复 bug 的这位伙计不是写代码的那个人（且发现 bug 和修复 bug 的不是同一个人）。因此，必须降低理解代码花费的时间，无论是一段时间前你自己写的代码还是团队中的其他成员写的代码。这关系到底线（营业收入）和开发人员的幸福，因为我们更应该去开发新的激动 人心的事物而不是花几小时几天的时间去维护遗留代码。</p>
<p>另一个相关软件开发生命的事实是，读代码花费的时间要比写来得多。有时候，当你专注并深入思考某个问题的时候，你可以坐下来，一个下午写大量的代码。</p>
<p>你的代码很能很快就工作了，但是，随着应用的成熟，还会有很多其他的事情发生，这就要求你的进行进行审查，修改，和调整。例如：</p>
<ul>
<li>bug 是暴露的</li>
<li>新功能被添加到应用程序</li>
<li>程序在新的环境下工作（例如，市场上出现新想浏览器）</li>
<li>代码改变用途</li>
<li>代码得完全从头重新，或移植到另一个架构上或者甚至使用另一种语言</li>
</ul>
<p>由于这些变化，很少人力数小时写的代码最终演变成花数周来阅读这些代码。这就是为什么创建可维护的代码对应用程序的成功至关重要。</p>
<p>可维护的代码意味着：</p>
<ul>
<li>可读的</li>
<li>一致的</li>
<li>可预测的</li>
<li>看上去就像是同一个人写的</li>
<li>已记录</li>
</ul>
<h2 id="最小全局变量-Minimizing-Globals"><a href="#最小全局变量-Minimizing-Globals" class="headerlink" title="最小全局变量(Minimizing Globals)"></a>最小全局变量(Minimizing Globals)</h2><p>JavaScript 通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p>
<p>每个 JavaScript 环境有一个全局对象，当你在任意的函数外面使用 this 的时候可以访问到。你创建的每一个全部变量都成了这个全局对象的属 性。在浏览器中，方便起见，该全局对象有个附加属性叫做 window，此 window(通常)指向该全局对象本身。下面的代码片段显示了如何在浏览器环境 中创建和访问的全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">myglobal = &quot;hello&quot;; // 不推荐写法</div><div class="line">console.log(myglobal); // &quot;hello&quot;</div><div class="line">console.log(window.myglobal); // &quot;hello&quot;</div><div class="line">console.log(window[&quot;myglobal&quot;]); // &quot;hello&quot;</div><div class="line">console.log(this.myglobal); // &quot;hello&quot;</div></pre></td></tr></table></figure>
<h2 id="全局变量的问题"><a href="#全局变量的问题" class="headerlink" title="全局变量的问题"></a>全局变量的问题</h2><p>全局变量的问题在于，你的 JavaScript 应用程序和 web 页面上的所有代码都共享了这些全局变量，他们住在同一个全局命名空间，所以当程序的两个不同部分定义同名但不同作用的全局变量的时候，命名冲突在所难免。</p>
<p>web 页面包含不是该页面开发者所写的代码也是比较常见的，例如：</p>
<ul>
<li>第三方的 JavaScript 库</li>
<li>广告方的脚本代码</li>
<li>第三方用户跟踪和分析脚本代码</li>
<li>不同类型的小组件，标志和按钮</li>
</ul>
<p>比方说，该第三方脚本定义了一个全局变量，叫做 result；接着，在你的函数中也定义一个名为 result 的全局变量。其结果就是后面的变量覆盖前面的，第三方脚本就一下子嗝屁啦！</p>
<p>因此，要想和其他脚本成为好邻居的话，尽可能少的使用全局变量是很重要的。在书中后面提到的一些减少全局变量的策略，例如命名空间模式或是函数立即自动执行，但是要想让全局变量少最重要的还是始终使用 var 来声明变量。</p>
<p>由于 JavaScript 的两个特征，不自觉地创建出全局变量是出乎意料的容易。首先，你可以甚至不需要声明就可以使用变量；第二，JavaScrip t有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。参考下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   // 不推荐写法: 隐式全局变量 </div><div class="line">   result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此段代码中的 result 没有声明。代码照样运作正常，但在调用函数后你最后的结果就多一个全局命名空间，这可以是一个问题的根源。</p>
<p>经验法则是始终使用 var 声明变量，正如改进版的 sum()函数所演示的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function sum(x, y) &#123;</div><div class="line">   var result = x + y;</div><div class="line">   return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另一个创建隐式全局变量的反例就是使用任务链进行部分 var 声明。下面的片段中，a 是本地变量但是 b 确实全局变量，这可能不是你希望发生的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 反例，勿使用 </div><div class="line">function foo() &#123;</div><div class="line">   var a = b = 0;</div><div class="line">   // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此现象发生的原因在于这个从右到左的赋值，首先，是赋值表达式 b = 0，此情况下 b 是未声明的。这个表达式的返回值是 0，然后这个 0 就分配给了通过 var 定义的这个局部变量 a。换句话说，就好比你输入了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var a = (b = 0);</div></pre></td></tr></table></figure>
<p>如果你已经准备好声明变量，使用链分配是比较好的做法，不会产生任何意料之外的全局变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">   var a, b;</div><div class="line">   // ... a = b = 0; // 两个均局部变量</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，另外一个避免全局变量的原因是可移植性。如果你想你的代码在不同的环境下（主机下）运行，使用全局变量如履薄冰，因为你会无意中覆盖你最初环境下不存在的主机对象（所以你原以为名称可以放心大胆地使用，实际上对于有些情况并不适用）。</p>
<h2 id="忘记-var-的副作用-Side-Effects-When-Forgetting-var"><a href="#忘记-var-的副作用-Side-Effects-When-Forgetting-var" class="headerlink" title="忘记 var 的副作用(Side Effects When Forgetting var)"></a>忘记 var 的副作用(Side Effects When Forgetting var)</h2><p>隐式全局变量和明确定义的全局变量间有些小的差异，就是通过 delete 操作符让变量未定义的能力。</p>
<ul>
<li>通过 var 创建的全局变量（任何函数之外的程序中创建）是不能被删除的。</li>
<li>无var创建的隐式全局变量（无视是否在函数中创建）是能被删除的。</li>
</ul>
<p>这表明，在技术上，隐式全局变量并不是真正的全局变量，但它们是全局对象的属性。属性是可以通过 delete 操作符删除的，而变量是不能的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 定义三个全局变量</div><div class="line">var global_var = 1;</div><div class="line">global_novar = 2; // 反面教材</div><div class="line">(function () &#123;</div><div class="line">   global_fromfunc = 3; // 反面教材</div><div class="line">&#125;());</div><div class="line">// 试图删除</div><div class="line">delete global_var; // false</div><div class="line">delete global_novar; // true</div><div class="line">delete global_fromfunc; // true</div><div class="line">// 测试该删除</div><div class="line">typeof global_var; // &quot;number&quot;</div><div class="line">typeof global_novar; // &quot;undefined&quot;</div><div class="line">typeof global_fromfunc; // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>在 ES5 严格模式下，未声明的变量（如在前面的代码片段中的两个反面教材）工作时会抛出一个错误。</p>
<h2 id="访问全局对象-Access-to-the-Global-Object"><a href="#访问全局对象-Access-to-the-Global-Object" class="headerlink" title="访问全局对象(Access to the Global Object)"></a>访问全局对象(Access to the Global Object)</h2><p>在浏览器中，全局对象可以通过 window 属性在代码的任何位置访问（除非你做了些比较出格的事情，像是声明了一个名为 window 的局部变量）。但是在其他环境下，这个方便的属性可能被叫做其他什么东西（甚至在程序中不可用）。如果你需要在没有硬编码的 window 标识符下访问全局对象，你可以在任何层级的函数作用域中做如下操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var global = (function () &#123;</div><div class="line">   return this;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>这种方法可以随时获得全局对象，因为其在函数中被当做函数调用了（不是通过 new 构造），this 总 是指向全局对象。实际上这个病不适用于 ECMAScript 5 严格模式，所以，在严格模式下时，你必须采取不同的形式。例如，你正在开发一个 JavaScript 库，你可以将你的代码包裹在一个即时函数中，然后从 全局作用域中，传递一个引用指向 this 作为你即时函数的参数。</p>
<h2 id="单-var-形式（Single-var-Pattern）"><a href="#单-var-形式（Single-var-Pattern）" class="headerlink" title="单 var 形式（Single var Pattern）"></a>单 var 形式（Single var Pattern）</h2><p>在函数顶部使用单 var 语句是比较有用的一种形式，其好处在于：</p>
<ul>
<li>提供了一个单一的地方去寻找功能所需要的所有局部变量</li>
<li>防止变量在定义之前使用的逻辑错误</li>
<li>帮助你记住声明的全局变量，因此较少了全局变量//zxx:此处我自己是有点晕乎的…</li>
<li>少代码（类型啊传值啊单线完成）</li>
</ul>
<p>单 var 形式长得就像下面这个样子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   var a = 1,</div><div class="line">       b = 2,</div><div class="line">       sum = a + b,</div><div class="line">       myobject = &#123;&#125;,</div><div class="line">       i,</div><div class="line">       j;</div><div class="line">   // function body...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>您可以使用一个 var 语句声明多个变量，并以逗号分隔。像这种初始化变量同时初始化值的做法是很好的。这样子可以防止逻辑错误（所有未初始化但声明的变量的初始值是 undefined）和增加代码的可读性。在你看到代码后，你可以根据初始化的值知道这些变量大致的用途，例如是要当作对象呢还是当作整数来使。</p>
<p>你也可以在声明的时候做一些实际的工作，例如前面代码中的 sum = a + b 这个情况，另外一个例子就是当你使用 DOM（文档对象模型）引用时，你可以使用单一的 var 把 DOM 引用一起指定为局部变量，就如下面代码所示的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function updateElement() &#123;</div><div class="line">   var el = document.getElementById(&quot;result&quot;),</div><div class="line">       style = el.style;</div><div class="line">   // 使用el和style干点其他什么事...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars"><a href="#预解析：var散布的问题-Hoisting-A-Problem-with-Scattered-vars" class="headerlink" title="预解析：var散布的问题(Hoisting: A Problem with Scattered vars)"></a>预解析：var散布的问题(Hoisting: A Problem with Scattered vars)</h2><p>JavaScript 中，你可以在函数的任何位置声明多个 var 语句，并且它们就好像是在函数顶部声明一样发挥作用，这种行为称为 hoisting（悬置/置顶解析/预解析）。当你使用了一个变量，然后不久在函数中又重新声明的话，就可能产生逻辑错误。对于 JavaScript，只 要你的变量是在同一个作用域中（同一函数），它都被当做是声明的，即使是它在 var 声明前使用的时候。看下面这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 反例</div><div class="line">myname = &quot;global&quot;; // 全局变量</div><div class="line">function func() &#123;</div><div class="line">    alert(myname); // &quot;undefined&quot;</div><div class="line">    var myname = &quot;local&quot;;</div><div class="line">    alert(myname); // &quot;local&quot;</div><div class="line">&#125;</div><div class="line">func();</div></pre></td></tr></table></figure>
<p>在这个例子中，你可能会以为第一个 alert 弹出的是”global”，第二个弹出”loacl”。这种期许是可以理解的，因为在第一个 alert 的时候，myname 未声明，此时函数肯定很自然而然地看全局变量 myname，但是，实际上并不是这么工作的。第一个 alert 会弹 出”undefined”是因为 myname 被当做了函数的局部变量（尽管是之后声明的），所有的变量声明当被悬置到函数的顶部了。因此，为了避免这种混 乱，最好是预先声明你想使用的全部变量。</p>
<p>上面的代码片段执行的行为可能就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">myname = &quot;global&quot;; // global variable</div><div class="line">function func() &#123;</div><div class="line">   var myname; // 等同于 -&gt; var myname = undefined;</div><div class="line">   alert(myname); // &quot;undefined&quot;</div><div class="line">   myname = &quot;local&quot;;</div><div class="line">   alert(myname); // &quot;local&quot;&#125;</div><div class="line">func();</div></pre></td></tr></table></figure>
<p>为了完整，我们再提一提执行层面的稍微复杂点的东西。代码处理分两个阶段，第一阶段是变量，函数声明，以及正常格式的参数创建，这是一个解析和进入上下文 的阶段。第二个阶段是代码执行，函数表达式和不合格的标识符（为声明的变量）被创建。但是，出于实用的目的，我们就采用了“hoisting”这个概念， 这种 ECMAScript 标准中并未定义，通常用来描述行为。</p>
<h2 id="for-循环-for-Loops"><a href="#for-循环-for-Loops" class="headerlink" title="for 循环(for Loops)"></a>for 循环(for Loops)</h2><p>在 for 循环中，你可以循环取得数组或是数组类似对象的值，譬如 arguments 和 HTMLCollection 对象。通常的循环形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 次佳的循环</div><div class="line">for (var i = 0; i &lt; myarray.length; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种形式的循环的不足在于每次循环的时候数组的长度都要去获取下。这回降低你的代码，尤其当 myarray 不是数组，而是一个 HTMLCollection 对象的时候。</p>
<p>HTMLCollections 指的是 DOM 方法返回的对象，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">document.getElementsByName()</div><div class="line">document.getElementsByClassName()</div><div class="line">document.getElementsByTagName()</div></pre></td></tr></table></figure>
<p>还有其他一些 HTMLCollections，这些是在 DOM 标准之前引进并且现在还在使用的。有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">document.images: 页面上所有的图片元素</div><div class="line">document.links : 所有a标签元素</div><div class="line">document.forms : 所有表单</div><div class="line">document.forms[0].elements : 页面上第一个表单中的所有域</div></pre></td></tr></table></figure>
<p>集合的麻烦在于它们实时查询基本文档（HTML 页面）。这意味着每次你访问任何集合的长度，你要实时查询 DOM，而 DOM 操作一般都是比较昂贵的。</p>
<p>这就是为什么当你循环获取值时，缓存数组(或集合)的长度是比较好的形式，正如下面代码显示的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for (var i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，在这个循环过程中，你只检索了一次长度值。</p>
<p>在所有浏览器下，循环获取内容时缓存 HTMLCollection s 的长度是更快的，2 倍(Safari3)到 190 倍(IE7)之间。//zxx:此数据貌似很老，仅供参考</p>
<p>注意到，当你明确想要修改循环中的集合的时候（例如，添加更多的 DOM 元素），你可能更喜欢长度更新而不是常量。</p>
<p>伴随着单 var 形式，你可以把变量从循环中提出来，就像下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function looper() &#123;</div><div class="line">   var i = 0,</div><div class="line">        max,</div><div class="line">        myarray = [];</div><div class="line">   // ...</div><div class="line">   for (i = 0, max = myarray.length; i &lt; max; i++) &#123;</div><div class="line">      // 使用myarray[i]做点什么</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种形式具有一致性的好处，因为你坚持了单一 var 形式。不足在于当重构代码的时候，复制和粘贴整个循环有点困难。例如，你从一个函数复制了一个循环到另一个函数，你不得不去确定你能够把 i 和 max 引入新的函数（如果在这里没有用的话，很有可能你要从原函数中把它们删掉）。</p>
<p>最后一个需要对循环进行调整的是使用下面表达式之一来替换 i++。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">i = i + 1</div><div class="line">i += 1</div></pre></td></tr></table></figure>
<p>JSLint 提示您这样做，原因是++和–-促进了“过分棘手(excessive trickiness)”。//zxx:这里比较难翻译，我想本意应该是让代码变得更加的棘手</p>
<p>如果你直接无视它，JSLint 的 plusplus 选项会是 false（默认是 default）。</p>
<p>还有两种变化的形式，其又有了些微改进，因为：</p>
<ul>
<li>少了一个变量(无 max)</li>
<li>向下数到 0，通常更快，因为和 0 做比较要比和数组长度或是其他不是 0 的东西作比较更有效率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//第一种变化的形式：</div><div class="line">var i, myarray = [];</div><div class="line">for (i = myarray.length; i–-;) &#123;</div><div class="line">   // 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//第二种使用while循环：</div><div class="line">var myarray = [],</div><div class="line">    i = myarray.length;</div><div class="line">while (i–-) &#123;</div><div class="line">// 使用myarray[i]做点什么</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这些小的改进只体现在性能上，此外 JSLint 会对使用 i–-加以抱怨。</p>
<h2 id="for-in-循环-for-in-Loops"><a href="#for-in-循环-for-in-Loops" class="headerlink" title="for-in 循环(for-in Loops)"></a>for-in 循环(for-in Loops)</h2><p>for-in 循环应该用在非数组对象的遍历上，使用 for-in 进行循环也被称为“枚举”。</p>
<p>从技术上将，你可以使用 for-in 循环数组（因为 JavaScript 中数组也是对象），但这是不推荐的。因为如果数组对象已被自定义的功能增强，就可能发生逻辑错误。另外，在 for-in 中，属性列表的顺序（序列）是不能保证的。所以最好数组使用正常的 for 循环，对象使用 for-in 循环。</p>
<p>有个很重要的 hasOwnProperty()方法，当遍历对象属性的时候可以过滤掉从原型链上下来的属性。</p>
<p>思考下面一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 对象</div><div class="line">var man = &#123;</div><div class="line">   hands: 2,</div><div class="line">   legs: 2,</div><div class="line">   heads: 1</div><div class="line">&#125;;</div><div class="line">// 在代码的某个地方</div><div class="line">// 一个方法添加给了所有对象</div><div class="line">if (typeof Object.prototype.clone === &quot;undefined&quot;) &#123;</div><div class="line">   Object.prototype.clone = function () &#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中，我们有一个使用对象字面量定义的名叫 man 的对象。在 man 定义完成后的某个地方，在对象原型上增加了一个很有用的名叫 clone()的方法。此原型链是实时的，这就意味着所有的对象自动可以访问新的方法。为了避免枚举 man 的时候出现 clone()方法，你需要应用 hasOwnProperty()方法过滤原型属性。如果不做过滤，会导致 clone()函数显示出来，在大多数情况下这是不希望出现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 1.</div><div class="line">// for-in 循环</div><div class="line">for (var i in man) &#123;</div><div class="line">   if (man.hasOwnProperty(i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line">/* 控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">*/</div><div class="line">// 2.</div><div class="line">// 反面例子:</div><div class="line">// for-in loop without checking hasOwnProperty()</div><div class="line">for (var i in man) &#123;</div><div class="line">   console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">控制台显示结果</div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line">clone: function()</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>另外一种使用 hasOwnProperty()的形式是取消 Object.prototype 上的方法。像是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for (var i in man) &#123;</div><div class="line">   if (Object.prototype.hasOwnProperty.call(man, i)) &#123; // 过滤</div><div class="line">      console.log(i, &quot;:&quot;, man[i]);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其好处在于在 man 对象重新定义 hasOwnProperty 情况下避免命名冲突。也避免了长属性查找对象的所有方法，你可以使用局部变量“缓存”它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) &#123;</div><div class="line">    if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">        console.log(i, &quot;:&quot;, man[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>严格来说，不使用 hasOwnProperty()并不是一个错误。根据任务以及你对代码的自信程度，你可以跳过它以提高些许的循环速度。但是当你对当前对象内容（和其原型链）不确定的时候，添加 hasOwnProperty()更加保险些。</p>
<p>格式化的变化（通不过 JSLint）会直接忽略掉花括号，把 if 语句放到同一行上。其优点在于循环语句读起来就像一个完整的想法（每个元素都有一个自己的属性”X”，使用”X”干点什么）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 警告： 通不过JSLint检测</div><div class="line">var i, hasOwn = Object.prototype.hasOwnProperty;</div><div class="line">for (i in man) if (hasOwn.call(man, i)) &#123; // 过滤</div><div class="line">    console.log(i, &quot;:&quot;, man[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes"><a href="#（不）扩展内置原型-Not-Augmenting-Built-in-Prototypes" class="headerlink" title="（不）扩展内置原型((Not) Augmenting Built-in Prototypes)"></a>（不）扩展内置原型((Not) Augmenting Built-in Prototypes)</h2><p>扩增构造函数的 prototype 属性是个很强大的增加功能的方法，但有时候它太强大了。</p>
<p>增加内置的构造函数原型（如 Object()， Array(),，或Function()）挺诱人的，但是这严重降低了可维护性，因为它让你的代码变得难以预测。使用你代码的其他开发人员很可能更期望使用内置的 JavaScript 方法来持续不断地工作，而不是你另加的方法。</p>
<p>另外，属性添加到原型中，可能会导致不使用 hasOwnProperty 属性时在循环中显示出来，这会造成混乱。</p>
<p>因此，不增加内置原型是最好的。你可以指定一个规则，仅当下面的条件均满足时例外：</p>
<ul>
<li>可以预期将来的 ECMAScript 版本或是 JavaScript 实现将一直将此功能当作内置方法来实现。例如，你可以添加 ECMAScript 5 中描述的方法，一直到各个浏览器都迎头赶上。这种情况下，你只是提前定义了有用的方法。</li>
<li>如果您检查您的自定义属性或方法已不存在——也许已经在代码的其他地方实现或已经是你支持的浏览器 JavaScript 引擎部分。</li>
<li>你清楚地文档记录并和团队交流了变化。</li>
</ul>
<p>如果这三个条件得到满足，你可以给原型进行自定义的添加，形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if (typeof Object.protoype.myMethod !== &quot;function&quot;) &#123;</div><div class="line">   Object.protoype.myMethod = function () &#123;</div><div class="line">      // 实现...</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="switch-模式-switch-Pattern"><a href="#switch-模式-switch-Pattern" class="headerlink" title="switch 模式(switch Pattern)"></a>switch 模式(switch Pattern)</h2><p>你可以通过类似下面形式的 switch 语句增强可读性和健壮性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var inspect_me = 0,</div><div class="line">    result = &apos;&apos;;</div><div class="line">switch (inspect_me) &#123;</div><div class="line">case 0:</div><div class="line">   result = &quot;zero&quot;;</div><div class="line">   break;</div><div class="line">case 1:</div><div class="line">   result = &quot;one&quot;;</div><div class="line">   break;</div><div class="line">default:</div><div class="line">   result = &quot;unknown&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个简单的例子中所遵循的风格约定如下：</p>
<ul>
<li>每个 case 和 switch 对齐（花括号缩进规则除外）</li>
<li>每个 case 中代码缩进</li>
<li>每个 case 以 break 清除结束</li>
<li>避免贯穿（故意忽略 break）。如果你非常确信贯穿是最好的方法，务必记录此情况，因为对于有些阅读人而言，它们可能看起来是错误的。</li>
<li>以 default 结束 switch：确保总有健全的结果，即使无情况匹配。</li>
</ul>
<h2 id="避免隐式类型转换-Avoiding-Implied-Typecasting"><a href="#避免隐式类型转换-Avoiding-Implied-Typecasting" class="headerlink" title="避免隐式类型转换(Avoiding Implied Typecasting"></a>避免隐式类型转换(Avoiding Implied Typecasting</h2><p>JavaScript 的变量在比较的时候会隐式类型转换。这就是为什么一些诸如：false == 0 或 “” == 0 返回的结果是 true。为避免引起混乱的隐含类型转换，在你比较值和表达式类型的时候始终使用===和!==操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var zero = 0;</div><div class="line">if (zero === false) &#123;</div><div class="line">   // 不执行，因为zero为0, 而不是false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">if (zero == false) &#123;</div><div class="line">   // 执行了...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有另外一种思想观点认为==就足够了===是多余的。例如，当你使用 typeof 你就知道它会返回一个字符串，所以没有使用严格相等的理由。然而，JSLint 要求严格相等，它使代码看上去更有一致性，可以降低代码阅读时的精力消耗。（“==是故意的还是一个疏漏？”）</p>
<h2 id="避免-Avoiding-eval"><a href="#避免-Avoiding-eval" class="headerlink" title="避免(Avoiding) eval()"></a>避免(Avoiding) eval()</h2><p>如果你现在的代码中使用了 eval()，记住该咒语“eval()是魔鬼”。此方法接受任意的字符串，并当作 JavaScript 代码来处理。当有 问题的代码是事先知道的（不是运行时确定的），没有理由使用 eval()。如果代码是在运行时动态生成，有一个更好的方式不使用 eval 而达到同样的目标。例如，用方括号表示法来访问动态属性会更好更简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(eval(&quot;obj.&quot; + property));</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 更好的</div><div class="line">var property = &quot;name&quot;;</div><div class="line">alert(obj[property]);</div></pre></td></tr></table></figure>
<p>使用 eval()也带来了安全隐患，因为被执行的代码（例如从网络来）可能已被篡改。这是个很常见的反面教材，当处理 Ajax 请求得到的 JSON 相应的时候。在这些情况下，最好使用 JavaScript 内置方法来解析 JSON 相应，以确保安全和有效。若浏览器不支持 JSON.parse()，你可 以使用来自 JSON.org的库。</p>
<p>同样重要的是要记住，给 setInterval()， setTimeout()和 Function()构造函数传递字符串，大部分情况下，与使用 eval()是类似的，因此要避免。在幕后，JavaScrip t仍需要评估和执行你给程序传递的字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 反面示例</div><div class="line">setTimeout(&quot;myFunc()&quot;, 1000);</div><div class="line">setTimeout(&quot;myFunc(1, 2, 3)&quot;, 1000);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 更好的</div><div class="line">setTimeout(myFunc, 1000);</div><div class="line">setTimeout(function () &#123;</div><div class="line">   myFunc(1, 2, 3);</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>使用新的 Function()构造就类似于 eval()，应小心接近。这可能是一个强大的构造，但往往被误用。如果你绝对必须使用 eval()，你 可以考虑使用 new Function()代替。有一个小的潜在好处，因为在新 Function()中作代码评估是在局部函数作用域中运行，所以代码中任何被评估的通过 var 定义的变量都不会自动变成全局变量。另一种方法来阻止自动全局变量是封装 eval()调用到一个即时函数中。</p>
<p>考虑下面这个例子，这里仅 un 作为全局变量污染了命名空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">console.log(typeof un);    // &quot;undefined&quot;</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div><div class="line">var jsstring = &quot;var un = 1; console.log(un);&quot;;</div><div class="line">eval(jsstring); // logs &quot;1&quot;</div><div class="line">jsstring = &quot;var deux = 2; console.log(deux);&quot;;</div><div class="line">new Function(jsstring)(); // logs &quot;2&quot;</div><div class="line">jsstring = &quot;var trois = 3; console.log(trois);&quot;;</div><div class="line">(function () &#123;</div><div class="line">   eval(jsstring);</div><div class="line">&#125;()); // logs &quot;3&quot;</div><div class="line">console.log(typeof un); // number</div><div class="line">console.log(typeof deux); // &quot;undefined&quot;</div><div class="line">console.log(typeof trois); // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>另一间 eval()和 Function 构造不同的是 eval()可以干扰作用域链，而Function()更安分守己些。不管你在哪里执行 Function()，它只看到全局作用域。所以其能很好的避免本地变量污染。在下面这个例子中，eval()可以访问和修改它外部作用域中的变量，这是 Function做不来的（注意到使用 Function 和 new Function 是相同的）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   eval(&quot;local = 3; console.log(local)&quot;); // logs &quot;3&quot;</div><div class="line">   console.log(local); // logs &quot;3&quot;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   var local = 1;</div><div class="line">   Function(&quot;console.log(typeof local);&quot;)(); // logs undefined</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h2 id="parseInt-下的数值转换-Number-Conversions-with-parseInt"><a href="#parseInt-下的数值转换-Number-Conversions-with-parseInt" class="headerlink" title="parseInt()下的数值转换(Number Conversions with parseInt())"></a>parseInt()下的数值转换(Number Conversions with parseInt())</h2><p>使用 parseInt()你可以从字符串中获取数值，该方法接受另一个基数参数，这经常省略，但不应该。当字符串以”0″开头的时候就有可能会出问 题，例如，部分时间进入表单域，在 ECMAScript 3 中，开头为”0″的字符串被当做8进制处理了，但这已在 ECMAScript 5 中改变了。为了避免矛盾和意外的结果，总是指定基数参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var month = &quot;06&quot;,</div><div class="line">    year = &quot;09&quot;;</div><div class="line">month = parseInt(month, 10);</div><div class="line">year = parseInt(year, 10);</div></pre></td></tr></table></figure>
<p>此例中，如果你忽略了基数参数，如 parseInt(year)，返回的值将是 0，因为“09”被当做 8 进制（好比执行 parseInt( year, 8 )），而 09 在 8 进制中不是个有效数字。</p>
<p>替换方法是将字符串转换成数字，包括：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+&quot;08&quot; // 结果是 8</div><div class="line">Number(&quot;08&quot;) // 8</div></pre></td></tr></table></figure>
<p>这些通常快于 parseInt()，因为 parseInt()方法，顾名思意，不是简单地解析与转换。但是，如果你想输入例如“08 hello”，parseInt()将返回数字，而其它以 NaN 告终。</p>
<h2 id="编码规范-Coding-Conventions"><a href="#编码规范-Coding-Conventions" class="headerlink" title="编码规范(Coding Conventions)"></a>编码规范(Coding Conventions)</h2><p>建立和遵循编码规范是很重要的，这让你的代码保持一致性，可预测，更易于阅读和理解。一个新的开发者加入这个团队可以通读规范，理解其它团队成员书写的代码，更快上手干活。</p>
<p>许多激烈的争论发生会议上或是邮件列表上，问题往往针对某些代码规范的特定方面（例如代码缩进，是 Tab 制表符键还是 space 空格键）。如果你是 你组织中建议采用规范的，准备好面对各种反对的或是听起来不同但很强烈的观点。要记住，建立和坚定不移地遵循规范要比纠结于规范的细节重要的多。</p>
<h2 id="缩进-Indentation"><a href="#缩进-Indentation" class="headerlink" title="缩进(Indentation)"></a>缩进(Indentation)</h2><p>代码没有缩进基本上就不能读了。唯一糟糕的事情就是不一致的缩进，因为它看上去像是遵循了规范，但是可能一路上伴随着混乱和惊奇。重要的是规范地使用缩进。</p>
<p>一些开发人员更喜欢用 tab 制表符缩进，因为任何人都可以调整他们的编辑器以自己喜欢的空格数来显示 Tab。有些人喜欢空格——通常四个，这都无所谓，只要团队每个人都遵循同一个规范就好了。这本书，例如，使用四个空格缩进，这也是 JSLint 中默认的缩进。</p>
<p>什么应该缩进呢？规则很简单——花括号里面的东西。这就意味着函数体，循环 (do，while，for， for-in)，if，switch，以及对象字面量中的对象属性。下面的代码就是使用缩进的示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function outer(a, b) &#123;</div><div class="line">    var c = 1,</div><div class="line">        d = 2,</div><div class="line">        inner;</div><div class="line">    if (a &gt; b) &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c - d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125; else &#123;</div><div class="line">        inner = function () &#123;</div><div class="line">            return &#123;</div><div class="line">                r: c + d</div><div class="line">            &#125;;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="花括号-Curly-Braces"><a href="#花括号-Curly-Braces" class="headerlink" title="花括号{}(Curly Braces)"></a>花括号{}(Curly Braces)</h2><p>花括号（亦称大括号，下同）应总被使用，即使在它们为可选的时候。技术上将，在 in 或是 for 中如果语句仅一条，花括号是不需要的，但是你还是应该总是使用它们，这会让代码更有持续性和易于更新。</p>
<p>想象下你有一个只有一条语句的 for 循环，你可以忽略花括号，而没有解析的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div></pre></td></tr></table></figure>
<p>但是，如果，后来，主体循环部分又增加了行代码？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 糟糕的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1)</div><div class="line">   alert(i);</div><div class="line">   alert(i + &quot; is &quot; + (i % 2 ? &quot;odd&quot; : &quot;even&quot;));</div></pre></td></tr></table></figure>
<p>第二个 alert 已经在循环之外，缩进可能欺骗了你。为了长远打算，最好总是使用花括号，即时值一行代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 好的实例</div><div class="line">for (var i = 0; i &lt; 10; i += 1) &#123;</div><div class="line">   alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>if条件类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 坏</div><div class="line">if (true)</div><div class="line">   alert(1);</div><div class="line">else</div><div class="line">   alert(2);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 好</div><div class="line">if (true) &#123;</div><div class="line">   alert(1);</div><div class="line">&#125; else &#123;</div><div class="line">   alert(2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="左花括号的位置-Opening-Brace-Location"><a href="#左花括号的位置-Opening-Brace-Location" class="headerlink" title="左花括号的位置(Opening Brace Location)"></a>左花括号的位置(Opening Brace Location)</h2><p>开发人员对于左大括号的位置有着不同的偏好——在同一行或是下一行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div><div class="line">//或</div><div class="line">if (true)</div><div class="line">&#123;</div><div class="line">   alert(&quot;It&apos;s TRUE!&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个实例中，仁者见仁智者见智，但也有个案，括号位置不同会有不同的行为表现。这是因为分号插入机制(semicolon insertion mechanism)——JavaScript 是不挑剔的，当你选择不使用分号结束一行代码时 JavaScript 会自己帮你补上。这种行为可能会导致麻 烦，如当你返回对象字面量，而左括号却在下一行的时候：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果你希望函数返回一个含有 name 属性的对象，你会惊讶。由于隐含分号，函数返回 undefined。前面的代码等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 警告： 意外的返回值</div><div class="line">function func() &#123;</div><div class="line">   return undefined;</div><div class="line">  // 下面代码不执行</div><div class="line">   &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总之，总是使用花括号，并始终把在与之前的语句放在同一行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function func() &#123;</div><div class="line">   return &#123;</div><div class="line">      name : &quot;Batman&quot;</div><div class="line">   &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>关于分号注：就像使用花括号，你应该总是使用分号，即使他们可由 JavaScript 解析器隐式创建。这不仅促进更科学和更严格的代码，而且有助于解决存有疑惑的地方，就如前面的例子显示。</p>
</blockquote>
<h2 id="空格-White-Space"><a href="#空格-White-Space" class="headerlink" title="空格(White Space)"></a>空格(White Space)</h2><p>空格的使用同样有助于改善代码的可读性和一致性。在写英文句子的时候，在逗号和句号后面会使用间隔。在 JavaScript 中，你可以按照同样的逻辑在列表模样表达式（相当于逗号）和结束语句（相对于完成了“想法”）后面添加间隔。</p>
<p>适合使用空格的地方包括：</p>
<ul>
<li>for循环分号分开后的的部分：如 for (var i = 0; i &lt; 10; i += 1) {…}；</li>
<li>for 循环中初始化的多变量(i 和 max)：for (var i = 0, max = 10; i &lt; max; i += 1) {…}；</li>
<li>分隔数组项的逗号的后面：var a = [1, 2, 3]；</li>
<li>对象属性逗号的后面以及分隔属性名和属性值的冒号的后面：var o = {a: 1, b: 2}；</li>
<li>限定函数参数：myFunc(a, b, c)；</li>
<li>函数声明的花括号的前面：function myFunc() {}；</li>
<li>匿名函数表达式function的后面：var myFunc = function () {}；</li>
</ul>
<p>使用空格分开所有的操作符和操作对象是另一个不错的使用，这意味着在+，-，*，=，&lt;，&gt;，&lt;=，&gt;=，===，!==，&amp;&amp;，||，+=等前后都需要空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 宽松一致的间距</div><div class="line">// 使代码更易读</div><div class="line">// 使得更加“透气”</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a &amp;&amp; b &amp;&amp; c) &#123;</div><div class="line">    d = a % c;</div><div class="line">    a += d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 反面例子</div><div class="line">// 缺失或间距不一</div><div class="line">// 使代码变得疑惑</div><div class="line">var d = 0,</div><div class="line">    a = b + 1;</div><div class="line">if (a&amp;&amp;b&amp;&amp;c) &#123;</div><div class="line">    d=a % c;</div><div class="line">    a+= d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后需要注意的一个空格——花括号间距。最好使用空格：</p>
<ul>
<li>函数、if-else 语句、循环、对象字面量的左花括号的前面({)</li>
<li>else 或 while 之间的右花括号(})</li>
</ul>
<p>空格使用的一点不足就是增加了文件的大小，但是压缩无此问题。</p>
<p>有一个经常被忽略的代码可读性方面是垂直空格的使用。你可以使用空行来分隔代码单元，就像是文学作品中使用段落分隔一样。</p>
<h2 id="命名规范-Naming-Conventions"><a href="#命名规范-Naming-Conventions" class="headerlink" title="命名规范(Naming Conventions)"></a>命名规范(Naming Conventions)</h2><p>另一种方法让你的代码更具可预测性和可维护性是采用命名规范。这就意味着你需要用同一种形式给你的变量和函数命名。</p>
<p>下面是建议的一些命名规范，你可以原样采用，也可以根据自己的喜好作调整。同样，遵循规范要比规范是什么更重要。</p>
<h2 id="以大写字母写构造函数-Capitalizing-Constructors"><a href="#以大写字母写构造函数-Capitalizing-Constructors" class="headerlink" title="以大写字母写构造函数(Capitalizing Constructors)"></a>以大写字母写构造函数(Capitalizing Constructors)</h2><p>JavaScript 并没有类，但有 new 调用的构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var adam = new Person();</div></pre></td></tr></table></figure>
<p>因为构造函数仍仅仅是函数，仅看函数名就可以帮助告诉你这应该是一个构造函数还是一个正常的函数。</p>
<p>命名构造函数时首字母大写具有暗示作用，使用小写命名的函数和方法不应该使用new调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function MyConstructor() &#123;...&#125;</div><div class="line">function myFunction() &#123;...&#125;</div></pre></td></tr></table></figure>
<h2 id="分隔单词-Separating-Words"><a href="#分隔单词-Separating-Words" class="headerlink" title="分隔单词(Separating Words)"></a>分隔单词(Separating Words)</h2><p>当你的变量或是函数名有多个单词的时候，最好单词的分离遵循统一的规范，有一个常见的做法被称作“驼峰(Camel)命名法”，就是单词小写，每个单词的首字母大写。</p>
<p>对于构造函数，可以使用大驼峰式命名法(upper camel case)，如MyConstructor()。对于函数和方法名称，你可以使用小驼峰式命名法(lower camel case)，像是 myFunction()， calculateArea()和 getFirstName()。</p>
<p>要是变量不是函数呢？开发者通常使用小驼峰式命名法，但还有另外一种做法就是所有单词小写以下划线连接：例如，first_name， favorite_bands，和 old_company_name，这种标记法帮你直观地区分函数和其他标识——原型和对象。</p>
<p>ECMAScript 的属性和方法均使用 Camel标记法，尽管多字的属性名称是罕见的（正则表达式对象的 lastIndex 和 ignoreCase 属性）。</p>
<h2 id="其它命名形式-Other-Naming-Patterns"><a href="#其它命名形式-Other-Naming-Patterns" class="headerlink" title="其它命名形式(Other Naming Patterns)"></a>其它命名形式(Other Naming Patterns)</h2><p>有时，开发人员使用命名规范来弥补或替代语言特性。</p>
<p>例如，JavaScript 中没有定义常量的方法（尽管有些内置的像 Number，MAX_VALUE），所以开发者都采用全部单词大写的规范来命名这个程序生命周期中都不会改变的变量，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 珍贵常数，只可远观</div><div class="line">var PI = 3.14,</div><div class="line">    MAX_WIDTH = 800;</div></pre></td></tr></table></figure>
<p>还有另外一个完全大写的惯例：全局变量名字全部大写。全部大写命名全局变量可以加强减小全局变量数量的实践，同时让它们易于区分。</p>
<p>另外一种使用规范来模拟功能的是私有成员。虽然可以在 JavaScript 中实现真正的私有，但是开发者发现仅仅使用一个下划线前缀来表示一个私有属性或方法会更容易些。考虑下面的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">    getName: function () &#123;</div><div class="line">        return this._getFirst() + &apos; &apos; + this._getLast();</div><div class="line">    &#125;,</div><div class="line">    _getFirst: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;,</div><div class="line">    _getLast: function () &#123;</div><div class="line">        // ...</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在此例中，getName()就表示公共方法，部分稳定的 API。而_getFirst()和_getLast()则表明了私有。它们仍然是正常的公共方法，但是使用下划线前缀来警告 person 对象的使用者这些方法在下一个版本中时不能保证工作的，是不能直接使用的。注意，JSLint有些不鸟下划线前缀，除非你设置了 noman 选项为:false。</p>
<p>下面是一些常见的_private 规范：</p>
<ul>
<li>使用尾下划线表示私有，如 name<em>和 getElements\</em>()</li>
<li>使用一个下划线前缀表<em>protected（保护）属性，两个下划线前缀表示\</em>_private （私有）属性</li>
<li>Firefox 中一些内置的变量属性不属于该语言的技术部分，使用两个前下划线和两个后下划线表示，如<strong>proto</strong>和<strong>parent</strong>。</li>
</ul>
<h2 id="注释-Writing-Comments"><a href="#注释-Writing-Comments" class="headerlink" title="注释(Writing Comments)"></a>注释(Writing Comments)</h2><p>你必须注释你的代码，即使不会有其他人向你一样接触它。通常，当你深入研究一个问题，你会很清楚的知道这个代码是干嘛用的，但是，当你一周之后再回来看的时候，想必也要耗掉不少脑细胞去搞明白到底怎么工作的。</p>
<p>很显然，注释不能走极端：每个单独变量或是单独一行。但是，你通常应该记录所有的函数，它们的参数和返回值，或是任何不寻常的技术和方法。要想到注 释可以给你代码未来的阅读者以诸多提示；阅读者需要的是（不要读太多的东西）仅注释和函数属性名来理解你的代码。例如，当你有五六行程序执行特定的任务， 如果你提供了一行代码目的以及为什么在这里的描述的话，阅读者就可以直接跳过这段细节。没有硬性规定注释代码比，代码的某些部分（如正则表达式）可能注释 要比代码多。</p>
<blockquote>
<p>最重要的习惯，然而也是最难遵守的，就是保持注释的及时更新，因为过时的注释比没有注释更加的误导人。</p>
</blockquote>
<h2 id="关于作者（About-the-Author）"><a href="#关于作者（About-the-Author）" class="headerlink" title="关于作者（About the Author）"></a>关于作者（About the Author）</h2><p>Stoyan Stefanov 是 Yahoo!web 开发人员，多个O’Reilly书籍的作者、投稿者和技术评审。他经常在会议和他的博客<a href="http://wiki.jikexueyuan.com/project/javascript-depth-understanding/www.phpied.com" target="_blank" rel="external">www.phpied.com</a>上发表 web 开发主题的演讲。Stoyan 还是 smush.it 图片优化工具的创造者，YUI 贡献者，雅虎性能优化工具 YSlow 2.0 的架构设计师</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/12/13/深入理解javascript/44设计模式之桥接模式/"><span>揭秘命名函数表达式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/12/13/深入理解javascript/44设计模式之桥接模式/" rel="bookmark">
        <time class="entry-date published" datetime="2015-12-13T14:02:02.000Z">
          2015-12-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>桥接模式最常用在事件监控上，先看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">addEvent(element, &apos;click&apos;, getBeerById);</div><div class="line">function getBeerById(e) &#123;</div><div class="line">var id = this.id;</div><div class="line">asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">// Callback response.</div><div class="line">console.log(&apos;Requested Beer: &apos; + resp.responseText);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码，有个问题就是 getBeerById 必须要有浏览器的上下文才能使用，因为其内部使用了 this.id 这个属性，如果没用上下文，那就歇菜了。所以说一般稍微有经验的程序员都会将程序改造成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function getBeerById(id, callback) &#123;</div><div class="line">// 通过ID发送请求，然后返回数据</div><div class="line">asyncRequest(&apos;GET&apos;, &apos;beer.uri?id=&apos; + id, function(resp) &#123;</div><div class="line">// callback response</div><div class="line">callback(resp.responseText);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实用多了，对吧？首先 ID 可以随意传入，而且还提供了一个 callback 函数用于自定义处理函数。但是这个和桥接有什么关系呢？这就是下段代码所要体现的了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">addEvent(element, &apos;click&apos;, getBeerByIdBridge);</div><div class="line">　　function getBeerByIdBridge (e) &#123;</div><div class="line">　　　　getBeerById(this.id, function(beer) &#123;</div><div class="line">　　　　　　console.log(&apos;Requested Beer: &apos;+beer);</div><div class="line">　　&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的 getBeerByIdBridge 就是我们定义的桥，用于将抽象的 click 事件和 getBeerById 连接起来，同时将事件源的 ID，以及自定义的 call 函数（console.log 输出）作为参数传入到 getBeerById 函数里。</p>
<p>这个例子看起来有些简单，我们再来一个复杂点的实战例子。</p>
<h2 id="实战-XHR-连接队列"><a href="#实战-XHR-连接队列" class="headerlink" title="实战 XHR 连接队列"></a>实战 XHR 连接队列</h2><p>我们要构建一个队列，队列里存放了很多 ajax 请求，使用队列（queue）主要是因为要确保先加入的请求先被处理。任何时候，我们可以暂停请求、删除请求、重试请求以及支持对各个请求的订阅事件。</p>
<h3 id="基础核心函数"><a href="#基础核心函数" class="headerlink" title="基础核心函数"></a>基础核心函数</h3><p>在正式开始之前，我们先定义一下核心的几个封装函数，首先第一个是异步请求的函数封装：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">var asyncRequest = (function () &#123;</div><div class="line">    function handleReadyState(o, callback) &#123;</div><div class="line">        var poll = window.setInterval(</div><div class="line">                    function () &#123;</div><div class="line">                        if (o &amp;&amp; o.readyState == 4) &#123;</div><div class="line">                            window.clearInterval(poll);</div><div class="line">                            if (callback) &#123;</div><div class="line">                                callback(o);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;,</div><div class="line">                    50</div><div class="line">                    );</div><div class="line">    &#125;</div><div class="line">    var getXHR = function () &#123;</div><div class="line">        var http;</div><div class="line">        try &#123;</div><div class="line">            http = new XMLHttpRequest;</div><div class="line">            getXHR = function () &#123;</div><div class="line">                return new XMLHttpRequest;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        catch (e) &#123;</div><div class="line">            var msxml = [</div><div class="line">                        &apos;MSXML2.XMLHTTP.3.0&apos;,</div><div class="line">                        &apos;MSXML2.XMLHTTP&apos;,</div><div class="line">                        &apos;Microsoft.XMLHTTP&apos;</div><div class="line">                        ];</div><div class="line">            for (var i = 0, len = msxml.length; i &lt; len; ++i) &#123;</div><div class="line">                try &#123;</div><div class="line">                    http = new ActiveXObject(msxml[i]);</div><div class="line">                    getXHR = function () &#123;</div><div class="line">                        return new ActiveXObject(msxml[i]);</div><div class="line">                    &#125;;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                catch (e) &#123; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return http;</div><div class="line">    &#125;;</div><div class="line">    return function (method, uri, callback, postData) &#123;</div><div class="line">        var http = getXHR();</div><div class="line">        http.open(method, uri, true);</div><div class="line">        handleReadyState(http, callback);</div><div class="line">        http.send(postData || null);</div><div class="line">        return http;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>上述封装的自执行函数是一个通用的 Ajax 请求函数，相信属性 Ajax 的人都能看懂了。</p>
<p>接下来我们定义一个通用的添加方法（函数）的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function (name, fn) &#123;</div><div class="line">    this.prototype[name] = fn;</div><div class="line">    return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后再添加关于数组的 2 个方法，一个用于遍历，一个用于筛选：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">if (!Array.prototype.forEach) &#123;</div><div class="line">    Array.method(&apos;forEach&apos;, function (fn, thisObj) &#123;</div><div class="line">        var scope = thisObj || window;</div><div class="line">        for (var i = 0, len = this.length; i &lt; len; ++i) &#123;</div><div class="line">            fn.call(scope, this[i], i, this);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line">if (!Array.prototype.filter) &#123;</div><div class="line">    Array.method(&apos;filter&apos;, function (fn, thisObj) &#123;</div><div class="line">        var scope = thisObj || window;</div><div class="line">        var a = [];</div><div class="line">        for (var i = 0, len = this.length; i &lt; len; ++i) &#123;</div><div class="line">            if (!fn.call(scope, this[i], i, this)) &#123;</div><div class="line">                continue;</div><div class="line">            &#125;</div><div class="line">            a.push(this[i]);</div><div class="line">        &#125;</div><div class="line">        return a;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为有的新型浏览器已经支持了这两种功能（或者有些类库已经支持了），所以要先判断，如果已经支持的话，就不再处理了。</p>
<h3 id="观察者系统"><a href="#观察者系统" class="headerlink" title="观察者系统"></a>观察者系统</h3><p>观察者在队列里的事件过程中扮演着重要的角色，可以队列处理时（成功、失败、挂起）订阅事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">window.DED = window.DED || &#123;&#125;;</div><div class="line">DED.util = DED.util || &#123;&#125;;</div><div class="line">DED.util.Observer = function () &#123;</div><div class="line">    this.fns = [];</div><div class="line">&#125;</div><div class="line">DED.util.Observer.prototype = &#123;</div><div class="line">    subscribe: function (fn) &#123;</div><div class="line">        this.fns.push(fn);</div><div class="line">    &#125;,</div><div class="line">    unsubscribe: function (fn) &#123;</div><div class="line">        this.fns = this.fns.filter(</div><div class="line">            function (el) &#123;</div><div class="line">                if (el !== fn) &#123;</div><div class="line">                    return el;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            );</div><div class="line">            &#125;,</div><div class="line">    fire: function (o) &#123;</div><div class="line">        this.fns.forEach(</div><div class="line">            function (el) &#123;</div><div class="line">                el(o);</div><div class="line">            &#125;</div><div class="line">            );</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="队列主要实现代码"><a href="#队列主要实现代码" class="headerlink" title="队列主要实现代码"></a>队列主要实现代码</h2><p>首先订阅了队列的主要属性和事件委托：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">DED.Queue = function () &#123;</div><div class="line">    // 包含请求的队列.</div><div class="line"> this.queue = [];</div><div class="line">    // 使用Observable对象在3个不同的状态上，以便可以随时订阅事件</div><div class="line"> this.onComplete = new DED.util.Observer;</div><div class="line">    this.onFailure = new DED.util.Observer;</div><div class="line">    this.onFlush = new DED.util.Observer;</div><div class="line">    // 核心属性，可以在外部调用的时候进行设置</div><div class="line"> this.retryCount = 3;</div><div class="line">    this.currentRetry = 0;</div><div class="line">    this.paused = false;</div><div class="line">    this.timeout = 5000;</div><div class="line">    this.conn = &#123;&#125;;</div><div class="line">    this.timer = &#123;&#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后通过 DED.Queue.method 的链式调用，则队列上添加了很多可用的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line">DED.Queue.</div><div class="line">    method(&apos;flush&apos;, function () &#123;</div><div class="line">        // flush方法</div><div class="line"> if (!this.queue.length &gt; 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (this.paused) &#123;</div><div class="line">            this.paused = false;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        var that = this;</div><div class="line">        this.currentRetry++;</div><div class="line">        var abort = function () &#123;</div><div class="line">            that.conn.abort();</div><div class="line">            if (that.currentRetry == that.retryCount) &#123;</div><div class="line">                that.onFailure.fire();</div><div class="line">                that.currentRetry = 0;</div><div class="line">            &#125; else &#123;</div><div class="line">                that.flush();</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        this.timer = window.setTimeout(abort, this.timeout);</div><div class="line">        var callback = function (o) &#123;</div><div class="line">            window.clearTimeout(that.timer);</div><div class="line">            that.currentRetry = 0;</div><div class="line">            that.queue.shift();</div><div class="line">            that.onFlush.fire(o.responseText);</div><div class="line">            if (that.queue.length == 0) &#123;</div><div class="line">                that.onComplete.fire();</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">            // recursive call to flush</div><div class="line"> that.flush();</div><div class="line">        &#125;;</div><div class="line">        this.conn = asyncRequest(</div><div class="line">            this.queue[0][&apos;method&apos;],</div><div class="line">            this.queue[0][&apos;uri&apos;],</div><div class="line">            callback,</div><div class="line">            this.queue[0][&apos;params&apos;]</div><div class="line">            );</div><div class="line">    &#125;).</div><div class="line">    method(&apos;setRetryCount&apos;, function (count) &#123;</div><div class="line">        this.retryCount = count;</div><div class="line">    &#125;).</div><div class="line">    method(&apos;setTimeout&apos;, function (time) &#123;</div><div class="line">        this.timeout = time;</div><div class="line">    &#125;).</div><div class="line">    method(&apos;add&apos;, function (o) &#123;</div><div class="line">        this.queue.push(o);</div><div class="line">    &#125;).</div><div class="line">    method(&apos;pause&apos;, function () &#123;</div><div class="line">        this.paused = true;</div><div class="line">    &#125;).</div><div class="line">    method(&apos;dequeue&apos;, function () &#123;</div><div class="line">        this.queue.pop();</div><div class="line">    &#125;).</div><div class="line">    method(&apos;clear&apos;, function () &#123;</div><div class="line">        this.queue = [];</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>代码看起来很多，折叠以后就可以发现，其实就是在队列上定义了 flush，setRetryCount， setTimeout，add，pause，dequeue，和 clear 方法。</p>
<h3 id="简单调用"><a href="#简单调用" class="headerlink" title="简单调用"></a>简单调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var q = new DED.Queue;</div><div class="line">// 设置重试次数高一点，以便应付慢的连接</div><div class="line">q.setRetryCount(5);</div><div class="line">// 设置timeout时间</div><div class="line">q.setTimeout(1000);</div><div class="line">// 添加2个请求.</div><div class="line">q.add(&#123;</div><div class="line">    method: &apos;GET&apos;,</div><div class="line">    uri: &apos;/path/to/file.php?ajax=true&apos;</div><div class="line">&#125;);</div><div class="line">q.add(&#123;</div><div class="line">    method: &apos;GET&apos;,</div><div class="line">    uri: &apos;/path/to/file.php?ajax=true&amp;woe=me&apos;</div><div class="line">&#125;);</div><div class="line">// flush队列</div><div class="line">q.flush();</div><div class="line">// 暂停队列，剩余的保存</div><div class="line">q.pause();</div><div class="line">// 清空.</div><div class="line">q.clear();</div><div class="line">// 添加2个请求.</div><div class="line">q.add(&#123;</div><div class="line">    method: &apos;GET&apos;,</div><div class="line">    uri: &apos;/path/to/file.php?ajax=true&apos;</div><div class="line">&#125;);</div><div class="line">q.add(&#123;</div><div class="line">    method: &apos;GET&apos;,</div><div class="line">    uri: &apos;/path/to/file.php?ajax=true&amp;woe=me&apos;</div><div class="line">&#125;);</div><div class="line">// 从队列里删除最后一个请求.</div><div class="line">q.dequeue();</div><div class="line">// 再次Flush</div><div class="line">q.flush();</div></pre></td></tr></table></figure>
<h3 id="桥接呢？"><a href="#桥接呢？" class="headerlink" title="桥接呢？"></a>桥接呢？</h3><p>上面的调用代码里并没有桥接，那桥呢？看一下下面的完整示例，就可以发现处处都有桥哦：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot;</div><div class="line">&quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</div><div class="line">&lt;html&gt;</div><div class="line">\&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Ajax Connection Queue&lt;/title&gt;</div><div class="line">    &lt;script src=&quot;utils.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script src=&quot;queue.js&quot;&gt;&lt;/script&gt;</div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        addEvent(window, &apos;load&apos;, function () &#123;</div><div class="line">            // 实现.</div><div class="line">var q = new DED.Queue;</div><div class="line">            q.setRetryCount(5);</div><div class="line">            q.setTimeout(3000);</div><div class="line">            var items = $(&apos;items&apos;);</div><div class="line">            var results = $(&apos;results&apos;);</div><div class="line">            var queue = $(&apos;queue-items&apos;);</div><div class="line">            // 在客户端保存跟踪自己的请求</div><div class="line">var requests = [];</div><div class="line">            // 每个请求flush以后，订阅特殊的处理步骤</div><div class="line">            q.onFlush.subscribe(function (data) &#123;</div><div class="line">                results.innerHTML = data;</div><div class="line">                requests.shift();</div><div class="line">                queue.innerHTML = requests.toString();</div><div class="line">            &#125;);</div><div class="line">            // 订阅时间处理步骤</div><div class="line">            q.onFailure.subscribe(function () &#123;</div><div class="line">                results.innerHTML += &apos; &lt;span style=&quot;color:red;&quot;&gt;Connection Error!&lt;/span&gt;&apos;;</div><div class="line">            &#125;);</div><div class="line">            // 订阅全部成功的处理步骤x</div><div class="line">            q.onComplete.subscribe(function () &#123;</div><div class="line">                results.innerHTML += &apos; &lt;span style=&quot;color:green;&quot;&gt;Completed!&lt;/span&gt;&apos;;</div><div class="line">            &#125;);</div><div class="line">            var actionDispatcher = function (element) &#123;</div><div class="line">                switch (element) &#123;</div><div class="line">                    case &apos;flush&apos;:</div><div class="line">                        q.flush();</div><div class="line">                        break;</div><div class="line">                    case &apos;dequeue&apos;:</div><div class="line">                        q.dequeue();</div><div class="line">                        requests.pop();</div><div class="line">                        queue.innerHTML = requests.toString();</div><div class="line">                        break;</div><div class="line">                    case &apos;pause&apos;:</div><div class="line">                        q.pause();</div><div class="line">                        break;</div><div class="line">                    case &apos;clear&apos;:</div><div class="line">                        q.clear();</div><div class="line">                        requests = [];</div><div class="line">                        queue.innerHTML = &apos;&apos;;</div><div class="line">                        break;</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            var addRequest = function (request) &#123;</div><div class="line">                var data = request.split(&apos;-&apos;)[1];</div><div class="line">                q.add(&#123;</div><div class="line">                    method: &apos;GET&apos;,</div><div class="line">                    uri: &apos;bridge-connection-queue.php?ajax=true&amp;s=&apos; + data,</div><div class="line">                    params: null</div><div class="line">                &#125;);</div><div class="line">                requests.push(data);</div><div class="line">                queue.innerHTML = requests.toString();</div><div class="line">            &#125;;</div><div class="line">            addEvent(items, &apos;click&apos;, function (e) &#123;</div><div class="line">                var e = e || window.event;</div><div class="line">                var src = e.target || e.srcElement;</div><div class="line">                try &#123;</div><div class="line">                    e.preventDefault();</div><div class="line">                &#125;</div><div class="line">                catch (ex) &#123;</div><div class="line">                    e.returnValue = false;</div><div class="line">                &#125;</div><div class="line">                actionDispatcher(src.id);</div><div class="line">            &#125;);</div><div class="line">            var adders = $(&apos;adders&apos;);</div><div class="line">            addEvent(adders, &apos;click&apos;, function (e) &#123;</div><div class="line">                var e = e || window.event;</div><div class="line">                var src = e.target || e.srcElement;</div><div class="line">                try &#123;</div><div class="line">                    e.preventDefault();</div><div class="line">                &#125;</div><div class="line">                catch (ex) &#123;</div><div class="line">                    e.returnValue = false;</div><div class="line">                &#125;</div><div class="line">                addRequest(src.id);</div><div class="line">            &#125;);</div><div class="line">        &#125;);</div><div class="line">    &lt;/script&gt;</div><div class="line">    &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;</div><div class="line">        body</div><div class="line">        &#123;</div><div class="line">            font: 100% georgia,times,serif;</div><div class="line">        &#125;</div><div class="line">        h1, h2</div><div class="line">        &#123;</div><div class="line">            font-weight: normal;</div><div class="line">        &#125;</div><div class="line">        #queue-items</div><div class="line">        &#123;</div><div class="line">            height: 1.5em;</div><div class="line">        &#125;</div><div class="line">        #add-stuff</div><div class="line">        &#123;</div><div class="line">            padding: .5em;</div><div class="line">            background: #ddd;</div><div class="line">            border: 1px solid #bbb;</div><div class="line">        &#125;</div><div class="line">        #results-area</div><div class="line">        &#123;</div><div class="line">            padding: .5em;</div><div class="line">            border: 1px solid #bbb;</div><div class="line">        &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body id=&quot;example&quot;&gt;</div><div class="line">    &lt;div id=&quot;doc&quot;&gt;</div><div class="line">        &lt;h1&gt;</div><div class="line">            异步联接请求&lt;/h1&gt;</div><div class="line">        &lt;div id=&quot;queue-items&quot;&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;div id=&quot;add-stuff&quot;&gt;</div><div class="line">            &lt;h2&gt;向队列里添加新请求&lt;/h2&gt;</div><div class="line">            &lt;ul id=&quot;adders&quot;&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;action-01&quot;&gt;添加 &quot;01&quot; 到队列&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;action-02&quot;&gt;添加 &quot;02&quot; 到队列&lt;/a&gt;&lt;/li&gt;</div><div class="line">                &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;action-03&quot;&gt;添加 &quot;03&quot; 到队列&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;/ul&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;h2&gt;队列控制&lt;/h2&gt;</div><div class="line">        &lt;ul id=&apos;items&apos;&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;flush&quot;&gt;Flush&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;dequeue&quot;&gt;出列Dequeue&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;pause&quot;&gt;暂停Pause&lt;/a&gt;&lt;/li&gt;</div><div class="line">            &lt;li&gt;&lt;a href=&quot;#&quot; id=&quot;clear&quot;&gt;清空Clear&lt;/a&gt;&lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">        &lt;div id=&quot;results-area&quot;&gt;</div><div class="line">            &lt;h2&gt;</div><div class="line">                结果:</div><div class="line">            &lt;/h2&gt;</div><div class="line">            &lt;div id=&quot;results&quot;&gt;</div><div class="line">            &lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>在这个示例里，你可以做 flush 队列，暂停队列，删除队列里的请求，清空队列等各种动作，同时相信大家也体会到了桥接的威力了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桥接模式的优点也很明显，我们只列举主要几个优点：</p>
<ol>
<li>分离接口和实现部分，一个实现未必不变地绑定在一个接口上，抽象类（函数）的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现，同将抽象和实现也进行了充分的解耦，也有利于分层，从而产生更好的结构化系统。</li>
<li>提高可扩充性</li>
<li>实现细节对客户透明，可以对客户隐藏实现细节。</li>
</ol>
<p>同时桥接模式也有自己的缺点：</p>
<p>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/11/23/深入理解javascript/42设计模式之原型模式/"><span>设计模式之原型模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/11/23/深入理解javascript/42设计模式之原型模式/" rel="bookmark">
        <time class="entry-date published" datetime="2015-11-23T05:02:02.000Z">
          2015-11-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>对于原型模式，我们可以利用 JavaScript 特有的原型继承特性去创建对象的方式，也就是创建的一个对象作为另外一个对象的 prototype 属性值。原型对象本身就是有效地利用了每个构造器创建的对象，例如，如果一个构造函数的原型包含了一个 name 属性（见后面的例子），那通过这个构造函数创建的对象都会有这个属性。</p>
<p>在现有的文献里查看原型模式的定义，没有针对 JavaScript 的，你可能发现很多讲解的都是关于类的，但是现实情况是基于原型继承的 JavaScript 完全避免了类（class）的概念。我们只是简单从现有的对象进行拷贝来创建对象。</p>
<p>真正的原型继承是作为最新版的 ECMAScript5 标准提出的，使用 Object.create 方法来创建这样的对象，该方法创建指定的对象，其对象的 prototype 有指定的对象（也就是该方法传进的第一个参数对象），也可以包含其他可选的指定属性。例如 Object.create(prototype, optionalDescriptorObjects)，下面的例子里也可以看到这个用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 因为不是构造函数，所以不用大写</div><div class="line">var someCar = &#123;</div><div class="line">    drive: function () &#123; &#125;,</div><div class="line">    name: &apos;马自达 3&apos;</div><div class="line">&#125;;</div><div class="line">// 使用Object.create创建一个新车x</div><div class="line">var anotherCar = Object.create(someCar);</div><div class="line">anotherCar.name = &apos;丰田佳美&apos;;</div></pre></td></tr></table></figure>
<p>Object.create 运行你直接从其它对象继承过来，使用该方法的第二个参数，你可以初始化额外的其它属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var vehicle = &#123;</div><div class="line">    getModel: function () &#123;</div><div class="line">        console.log(&apos;车辆的模具是：&apos; + this.model);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var car = Object.create(vehicle, &#123;</div><div class="line">    &apos;id&apos;: &#123;</div><div class="line">        value: MY_GLOBAL.nextId(),</div><div class="line">        enumerable: true // 默认writable:false, configurable:false</div><div class="line"> &#125;,</div><div class="line">    &apos;model&apos;: &#123;</div><div class="line">        value: &apos;福特&apos;,</div><div class="line">        enumerable: true</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里，可以在 Object.create 的第二个参数里使用对象字面量传入要初始化的额外属性，其语法与 Object.defineProperties 或 Object.defineProperty 方法类型。它允许您设定属性的特性，例如 enumerable，writable 或 configurable。</p>
<p>如果你希望自己去实现原型模式，而不直接使用 Object.create。你可以使用像下面这样的代码为上面的例子来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var vehiclePrototype = &#123;</div><div class="line">    init: function (carModel) &#123;</div><div class="line">        this.model = carModel;</div><div class="line">    &#125;,</div><div class="line">    getModel: function () &#123;</div><div class="line">        console.log(&apos;车辆模具是：&apos; + this.model);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">function vehicle(model) &#123;</div><div class="line">    function F() &#123; &#125;;</div><div class="line">    F.prototype = vehiclePrototype;</div><div class="line">    var f = new F();</div><div class="line">    f.init(model);</div><div class="line">    return f;</div><div class="line">&#125;</div><div class="line">var car = vehicle(&apos;福特Escort&apos;);</div><div class="line">car.getModel();</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型模式在 JavaScript 里的使用简直是无处不在，其它很多模式有很多也是基于 prototype 的，就不多说了，这里大家要注意的依然是浅拷贝和深拷贝的问题，免得出现引用问题。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/10/23/深入理解javascript/30设计模式之外观模式/"><span>设计模式之外观模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/10/23/深入理解javascript/30设计模式之外观模式/" rel="bookmark">
        <time class="entry-date published" datetime="2015-10-23T04:34:23.000Z">
          2015-10-23
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>外观模式（Facade）为子系统中的一组接口提供了一个一致的界面，此模块定义了一个高层接口，这个接口值得这一子系统更加容易使用。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>外观模式不仅简化类中的接口，而且对接口与调用者也进行了解耦。外观模式经常被认为开发者必备，它可以将一些复杂操作封装起来，并创建一个简单的接口用于调用。</p>
<p>外观模式经常被用于 JavaScript 类库里，通过它封装一些接口用于兼容多浏览器，外观模式可以让我们间接调用子系统，从而避免因直接访问子系统而产生不必要的错误。</p>
<p>外观模式的优势是易于使用，而且本身也比较轻量级。但也有缺点 外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性。</p>
<p>下面是一段未优化过的代码，我们使用了外观模式通过检测浏览器特性的方式来创建一个跨浏览器的使用方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var addMyEvent = function (el, ev, fn) &#123;</div><div class="line">    if (el.addEventListener) &#123;</div><div class="line">        el.addEventListener(ev, fn, false);</div><div class="line">    &#125; else if (el.attachEvent) &#123;</div><div class="line">        el.attachEvent(&apos;on&apos; + ev, fn);</div><div class="line">    &#125; else &#123;</div><div class="line">        el[&apos;on&apos; + ev] = fn;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>再来一个简单的例子，说白了就是用一个接口封装其它的接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var mobileEvent = &#123;</div><div class="line">    // ...</div><div class="line">    stop: function (e) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">        e.stopPropagation();</div><div class="line">    &#125;</div><div class="line">    // ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>那么何时使用外观模式呢？一般来说分三个阶段：</p>
<p><strong>首先</strong>，在设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade。</p>
<p><strong>其次</strong>，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。</p>
<p><strong>第三</strong>，在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade 与遗留代码交互所有的复杂工作。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2015/10/19/深入理解javascript/40设计模式之组合模式/"><span>设计模式之组合模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2015/10/19/深入理解javascript/40设计模式之组合模式/" rel="bookmark">
        <time class="entry-date published" datetime="2015-10-19T12:02:02.000Z">
          2015-10-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>组合模式（Composite）将对象组合成树形结构以表示“部分-整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<p>常见的场景有 asp.net 里的控件机制（即 control 里可以包含子 control，可以递归操作、添加、删除子 control），类似的还有 DOM 的机制，一个 DOM 节点可以包含子节点，不管是父节点还是子节点都有添加、删除、遍历子节点的通用功能。所以说组合模式的关键是要有一个抽象类，它既可以表示子元素，又可以表示父元素。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>举个例子，有家餐厅提供了各种各样的菜品，每个餐桌都有一本菜单，菜单上列出了该餐厅所偶的菜品，有早餐糕点、午餐、晚餐等等，每个餐都有各种各样的菜单项，假设不管是菜单项还是整个菜单都应该是可以打印的，而且可以添加子项，比如午餐可以添加新菜品，而菜单项咖啡也可以添加糖啊什么的。</p>
<p>这种情况，我们就可以利用组合的方式将这些内容表示为层次结构了。我们来逐一分解一下我们的实现步骤。</p>
<h3 id="第一步，先实现我们的“抽象类”函数-MenuComponent"><a href="#第一步，先实现我们的“抽象类”函数-MenuComponent" class="headerlink" title="第一步，先实现我们的“抽象类”函数 MenuComponent"></a>第一步，先实现我们的“抽象类”函数 MenuComponent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">var MenuComponent = function () &#123;</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getName = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getDescription = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getPrice = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.isVegetarian = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.print = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.add = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.remove = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div><div class="line">MenuComponent.prototype.getChild = function () &#123;</div><div class="line">    throw new Error(&quot;该方法必须重写!&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该函数提供了 2 种类型的方法，一种是获取信息的，比如价格，名称等，另外一种是通用操作方法，比如打印、添加、删除、获取子菜单。</p>
<h3 id="第二步，创建基本的菜品项"><a href="#第二步，创建基本的菜品项" class="headerlink" title="第二步，创建基本的菜品项"></a>第二步，创建基本的菜品项</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var MenuItem = function (sName, sDescription, bVegetarian, nPrice) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.bVegetarian = bVegetarian;</div><div class="line">    this.nPrice = nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype = new MenuComponent();</div><div class="line">MenuItem.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.getPrice = function () &#123;</div><div class="line">    return this.nPrice;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.isVegetarian = function () &#123;</div><div class="line">    return this.bVegetarian;</div><div class="line">&#125;;</div><div class="line">MenuItem.prototype.print = function () &#123;</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription() + &quot;, &quot; + this.getPrice() + &quot;euros&quot;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>由代码可以看出，我们只重新了原型的 4 个获取信息的方法和 print 方法，没有重载其它3个操作方法，因为基本菜品不包含添加、删除、获取子菜品的方式。</p>
<h3 id="第三步，创建菜品"><a href="#第三步，创建菜品" class="headerlink" title="第三步，创建菜品"></a>第三步，创建菜品</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">var Menu = function (sName, sDescription) &#123;</div><div class="line">    MenuComponent.apply(this);</div><div class="line">    this.aMenuComponents = [];</div><div class="line">    this.sName = sName;</div><div class="line">    this.sDescription = sDescription;</div><div class="line">    this.createIterator = function () &#123;</div><div class="line">        throw new Error(&quot;This method must be overwritten!&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">Menu.prototype = new MenuComponent();</div><div class="line">Menu.prototype.add = function (oMenuComponent) &#123;</div><div class="line">    // 添加子菜品</div><div class="line">    this.aMenuComponents.push(oMenuComponent);</div><div class="line">&#125;;</div><div class="line">Menu.prototype.remove = function (oMenuComponent) &#123;</div><div class="line">    // 删除子菜品</div><div class="line">    var aMenuItems = [];</div><div class="line">    var nMenuItem = 0;</div><div class="line">    var nLenMenuItems = this.aMenuComponents.length;</div><div class="line">    var oItem = null;</div><div class="line">    for (; nMenuItem &lt; nLenMenuItems; ) &#123;</div><div class="line">        oItem = this.aMenuComponents[nMenuItem];</div><div class="line">        if (oItem !== oMenuComponent) &#123;</div><div class="line">            aMenuItems.push(oItem);</div><div class="line">        &#125;</div><div class="line">        nMenuItem = nMenuItem + 1;</div><div class="line">    &#125;</div><div class="line">    this.aMenuComponents = aMenuItems;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getChild = function (nIndex) &#123;</div><div class="line">    //获取指定的子菜品</div><div class="line">    return this.aMenuComponents[nIndex];</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getName = function () &#123;</div><div class="line">    return this.sName;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.getDescription = function () &#123;</div><div class="line">    return this.sDescription;</div><div class="line">&#125;;</div><div class="line">Menu.prototype.print = function () &#123;</div><div class="line">    // 打印当前菜品以及所有的子菜品</div><div class="line">    console.log(this.getName() + &quot;: &quot; + this.getDescription());</div><div class="line">    console.log(&quot;--------------------------------------------&quot;);</div><div class="line">    var nMenuComponent = 0;</div><div class="line">    var nLenMenuComponents = this.aMenuComponents.length;</div><div class="line">    var oMenuComponent = null;</div><div class="line">    for (; nMenuComponent &lt; nLenMenuComponents; ) &#123;</div><div class="line">        oMenuComponent = this.aMenuComponents[nMenuComponent];</div><div class="line">        oMenuComponent.print();</div><div class="line">        nMenuComponent = nMenuComponent + 1;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>注意上述代码，除了实现了添加、删除、获取方法外，打印 print 方法是首先打印当前菜品信息，然后循环遍历打印所有子菜品信息。</p>
<h3 id="第四步，创建指定的菜品"><a href="#第四步，创建指定的菜品" class="headerlink" title="第四步，创建指定的菜品"></a>第四步，创建指定的菜品</h3><p>我们可以创建几个真实的菜品，比如晚餐、咖啡、糕点等等，其都是用 Menu 作为其原型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var DinnerMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">DinnerMenu.prototype = new Menu();</div><div class="line">var CafeMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">CafeMenu.prototype = new Menu();</div><div class="line">var PancakeHouseMenu = function () &#123;</div><div class="line">    Menu.apply(this);</div><div class="line">&#125;;</div><div class="line">PancakeHouseMenu.prototype = new Menu();</div></pre></td></tr></table></figure>
<h3 id="第五步，创建最顶级的菜单容器——菜单本"><a href="#第五步，创建最顶级的菜单容器——菜单本" class="headerlink" title="第五步，创建最顶级的菜单容器——菜单本"></a>第五步，创建最顶级的菜单容器——菜单本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var Mattress = function (aMenus) &#123;</div><div class="line">    this.aMenus = aMenus;</div><div class="line">&#125;;</div><div class="line">Mattress.prototype.printMenu = function () &#123;</div><div class="line">    this.aMenus.print();</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该函数接收一个菜单数组作为参数，并且值提供了 printMenu 方法用于打印所有的菜单内容。</p>
<h3 id="第六步，调用方式"><a href="#第六步，调用方式" class="headerlink" title="第六步，调用方式"></a>第六步，调用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var oPanCakeHouseMenu = new Menu(&quot;Pancake House Menu&quot;, &quot;Breakfast&quot;);</div><div class="line">var oDinnerMenu = new Menu(&quot;Dinner Menu&quot;, &quot;Lunch&quot;);</div><div class="line">var oCoffeeMenu = new Menu(&quot;Cafe Menu&quot;, &quot;Dinner&quot;);</div><div class="line">var oAllMenus = new Menu(&quot;ALL MENUS&quot;, &quot;All menus combined&quot;);</div><div class="line">oAllMenus.add(oPanCakeHouseMenu);</div><div class="line">oAllMenus.add(oDinnerMenu);</div><div class="line">oDinnerMenu.add(new MenuItem(&quot;Pasta&quot;, &quot;Spaghetti with Marinara Sauce, and a slice of sourdough bread&quot;, true, 3.89));</div><div class="line">oDinnerMenu.add(oCoffeeMenu);</div><div class="line">oCoffeeMenu.add(new MenuItem(&quot;Express&quot;, &quot;Coffee from machine&quot;, false, 0.99));</div><div class="line">var oMattress = new Mattress(oAllMenus);</div><div class="line">console.log(&quot;---------------------------------------------&quot;);</div><div class="line">oMattress.printMenu();</div><div class="line">console.log(&quot;---------------------------------------------&quot;);</div></pre></td></tr></table></figure>
<p>熟悉 asp.net 控件开发的同学，是不是看起来很熟悉？</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组合模式的使用场景非常明确：</p>
<ol>
<li>你想表示对象的部分-整体层次结构时；</li>
<li>你希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</li>
</ol>
<p>另外该模式经常和装饰者一起使用，它们通常有一个公共的父类（也就是原型），因此装饰必须支持具有 add、remove、getChild 操作的 component 接口。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/3/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/5/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/xuhongbo" target="_blank">Xuhongbo</a>
    </br>
    
    &copy; 2017 John Doe
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>