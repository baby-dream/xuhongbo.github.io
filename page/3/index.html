<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 3 页 | Hexo</title>

  
  <meta name="author" content="John Doe">
  

  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="Hexo"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Hexo</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/19/深入理解javascript/22S.O.L.I.D 五大原则之依赖倒置原则 DIP/"><span>S.O.L.I.D 五大原则之依赖倒置原则 DIP</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/19/深入理解javascript/22S.O.L.I.D 五大原则之依赖倒置原则 DIP/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-19T09:23:07.000Z">
          2016-03-19
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第5篇，依赖倒置原则 LSP（The Dependency Inversion Principle ）。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>依赖倒置原则的描述是：</p>
<ul>
<li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li>
<li>抽象不应该依赖于细节，细节应该依赖于抽象</li>
</ul>
<p>依赖倒置原则的最重要问题就是确保应用程序或框架的主要组件从非重要的底层组件实现细节解耦出来，这将确保程序的最重要的部分不会因为低层次组件的变化修改而受影响。</p>
<p>该原则的第一部分是关于高层模块和低层模块之间的耦合方式，在传统的分成架构中，高层模块（封装了程序的核心业务逻辑）总依赖于低层的一些模块（一些基础点）。当应用依赖倒置原则的时候，关系就反过来了。和高层模块依赖于低层模块不同，依赖倒置是让低层模块依赖于高层模块里定义的接口。举例来说，如果要给程序进行数据持久化，传统的设计是核心模块依赖于一个持久化模块的API，而根据依赖倒置原则重构以后，则是核心模块需要定义持久化的 API 接口，然后持久化的实现实例需要实现核心模块定义的这个 API 接口。</p>
<p>该原则的第二部分描述的是抽象和细节之间的正确关系。理解这一部分，通过了解 C++ 语言比较有帮助，因为他的适用性比较明显。</p>
<p>不像一些静态类型的语言，C++没有提供一个语言级别的概念来定义接口，那类定义和类实现之间到底是怎么样的呢，在 C++里，类通过头文件的形式来定义，其中定义了源文件需要实现的类成员方法和变量。因为所有的变量和私有方法都定义在头文件里，所以可以用来抽象以便和实现细节之前解耦出来。通过定只定义抽象方法来实现（C++里是抽象基类）接口这个概念用于实现类来实现。</p>
<h2 id="DIP-and-JavaScript"><a href="#DIP-and-JavaScript" class="headerlink" title="DIP and JavaScript"></a>DIP and JavaScript</h2><p>因为 JavaScript 是动态语言，所以不需要去为了解耦而抽象。所以抽象不应依赖于细节这个改变在 JavaScript 里没有太大的影响，但高层模块不应依赖于低层模块却有很大的影响。</p>
<p>在当静态类型语言的上下文里讨论依赖倒置原则的时候，耦合的概念包括语义（semantic）和物理（physical）两种。这就是说，如果一个高层模块依赖于一个低层模块，也就是不仅耦合了语义接口，也耦合了在底层模块里定义的物理接口。也就是说高层模块不仅要从第三方类库解耦出来，也需要从原生的低层模块里解耦出来。</p>
<p>为了解释这一点，想象一个.NET程序可能包含一个非常有用的高层模块，而该模块依赖于一个低层的持久化模块。当作者需要在持久化 API 里增加一个类似的接口的时候，不管依赖倒置原则有没有使用，高层模块在不重新实现这个低层模块的新接口之前是没有办法在其它的程序里得到重用的。</p>
<p>在 JavaScript 里，依赖倒置原则的适用性仅仅限于高层模块和低层模块之间的语义耦合，比如，DIP 可以根据需要去增加接口而不是耦合低层模块定义的隐式接口。</p>
<p>为了来理解这个，我们看一下如下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">$.fn.trackMap = function(options) &#123;</div><div class="line">    var defaults = &#123;</div><div class="line">        /* defaults */</div><div class="line">    &#125;;</div><div class="line">    options = $.extend(&#123;&#125;, defaults, options);</div><div class="line">    var mapOptions = &#123;</div><div class="line">        center: new google.maps.LatLng(options.latitude,options.longitude),</div><div class="line">        zoom: 12,</div><div class="line">        mapTypeId: google.maps.MapTypeId.ROADMAP</div><div class="line">    &#125;,</div><div class="line">        map = new google.maps.Map(this[0], mapOptions),</div><div class="line">        pos = new google.maps.LatLng(options.latitude,options.longitude);</div><div class="line">    var marker = new google.maps.Marker(&#123;</div><div class="line">        position: pos,</div><div class="line">        title: options.title,</div><div class="line">        icon: options.icon</div><div class="line">    &#125;);</div><div class="line">    marker.setMap(map);</div><div class="line">    options.feed.update(function(latitude, longitude) &#123;</div><div class="line">        marker.setMap(null);</div><div class="line">        var newLatLng = new google.maps.LatLng(latitude, longitude);</div><div class="line">        marker.position = newLatLng;</div><div class="line">        marker.setMap(map);</div><div class="line">        map.setCenter(newLatLng);</div><div class="line">    &#125;);</div><div class="line">    return this;</div><div class="line">&#125;;</div><div class="line">var updater = (function() &#123;</div><div class="line">    // private properties</div><div class="line">    return &#123;</div><div class="line">        update: function(callback) &#123;</div><div class="line">            updateMap = callback;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">$(&quot;#map_canvas&quot;).trackMap(&#123;</div><div class="line">    latitude: 35.044640193770725,</div><div class="line">    longitude: -89.98193264007568,</div><div class="line">    icon: &apos;http://bit.ly/zjnGDe&apos;,</div><div class="line">    title: &apos;Tracking Number: 12345&apos;,</div><div class="line">    feed: updater</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上述代码里，有个小型的 JS 类库将一个 DIV 转化成 Map 以便显示当前跟踪的位置信息。trackMap 函数有 2 个依赖：第三方的 Google Maps API 和 Location feed。该 feed 对象的职责是当 icon 位置更新的时候调用一个 callback 回调（在初始化的时候提供的）并且传入纬度 latitude 和精度 longitude。Google Maps API 是用来渲染界面的。</p>
<p>feed 对象的接口可能按照装，也可能没有照装 trackMap 函数的要求去设计，事实上，他的角色很简单，着重在简单的不同实现，不需要和 Google Maps 这么依赖。介于 trackMap 语义上耦合了 Google Maps API，如果需要切换不同的地图提供商的话那就不得不对 trackMap 函数进行重写以便可以适配不同的 provider。</p>
<p>为了将于 Google maps 类库的语义耦合翻转过来，我们需要重写设计 trackMap 函数，以便对一个隐式接口（抽象出地图提供商 provider 的接口）进行语义耦合，我们还需要一个适配 Google Maps API 的一个实现对象，如下是重构后的 trackMap 函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$.fn.trackMap = function(options) &#123;</div><div class="line">    var defaults = &#123;</div><div class="line">        /* defaults */</div><div class="line">    &#125;;</div><div class="line">    options = $.extend(&#123;&#125;, defaults, options);</div><div class="line">    options.provider.showMap(</div><div class="line">        this[0],</div><div class="line">        options.latitude,</div><div class="line">        options.longitude,</div><div class="line">        options.icon,</div><div class="line">        options.title);</div><div class="line">    options.feed.update(function(latitude, longitude) &#123;</div><div class="line">        options.provider.updateMap(latitude, longitude);</div><div class="line">    &#125;);</div><div class="line">    return this;</div><div class="line">&#125;;</div><div class="line">$(&quot;#map_canvas&quot;).trackMap(&#123;</div><div class="line">    latitude: 35.044640193770725,</div><div class="line">    longitude: -89.98193264007568,</div><div class="line">    icon: &apos;http://bit.ly/zjnGDe&apos;,</div><div class="line">    title: &apos;Tracking Number: 12345&apos;,</div><div class="line">    feed: updater,</div><div class="line">    provider: trackMap.googleMapsProvider</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在该版本里，我们重新设计了 trackMap 函数以及需要的一个地图提供商接口，然后将实现的细节挪到了一个单独的 googleMapsProvider 组件，该组件可能独立封装成一个单独的 JavaScript 模块。如下是我的 googleMapsProvider 实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">trackMap.googleMapsProvider = (function() &#123;</div><div class="line">    var marker, map;</div><div class="line">    return &#123;</div><div class="line">        showMap: function(element, latitude, longitude, icon, title) &#123;</div><div class="line">            var mapOptions = &#123;</div><div class="line">                center: new google.maps.LatLng(latitude, longitude),</div><div class="line">                zoom: 12,</div><div class="line">                mapTypeId: google.maps.MapTypeId.ROADMAP</div><div class="line">            &#125;,</div><div class="line">                pos = new google.maps.LatLng(latitude, longitude);</div><div class="line">            map = new google.maps.Map(element, mapOptions);</div><div class="line">            marker = new google.maps.Marker(&#123;</div><div class="line">                position: pos,</div><div class="line">                title: title,</div><div class="line">                icon: icon</div><div class="line">            &#125;);</div><div class="line">            marker.setMap(map);</div><div class="line">        &#125;,</div><div class="line">        updateMap: function(latitude, longitude) &#123;</div><div class="line">            marker.setMap(null);</div><div class="line">            var newLatLng = new google.maps.LatLng(latitude,longitude);</div><div class="line">            marker.position = newLatLng;</div><div class="line">            marker.setMap(map);</div><div class="line">            map.setCenter(newLatLng);</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>做了上述这些改变以后，trackMap 函数将变得非常有弹性了，不必依赖于 Google Maps API，相反可以任意替换其它的地图提供商，那就是说可以按照程序的需求去适配任何地图提供商。</p>
<h2 id="何时依赖注入？"><a href="#何时依赖注入？" class="headerlink" title="何时依赖注入？"></a>何时依赖注入？</h2><p>有点不太相关，其实依赖注入的概念经常和依赖倒置原则混在一起，为了澄清这个不同，我们有必要来解释一下：</p>
<p>依赖注入是控制反转的一个特殊形式，反转的意思一个组件如何获取它的依赖。依赖注入的意思就是：依赖提供给组件，而不是组件去获取依赖，意思是创建一个依赖的实例，通过工厂去请求这个依赖，通过 Service Locator 或组件自身的初始化去请求这个依赖。依赖倒置原则和依赖注入都是关注依赖，并且都是用于反转。不过，依赖倒置原则没有关注组件如何获取依赖，而是只关注高层模块如何从低层模块里解耦出来。某种意义上说，依赖倒置原则是控制反转的另外一种形式，这里反转的是哪个模块定义接口（从低层里定义，反转到高层里定义）。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是五大原则的最后一篇了，在这 5 篇文字里我们看到了 SOLID 如何在 JavaScript 里实现的，不同的原则在 JavaScript 里通过不同的角度来说明的。（大叔注：其实大叔觉得虽然是有点不伦不类，但从另外一个层面上说，大体的原则在各种语言上其实还是一样的。）</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/18/深入理解javascript/21S.O.L.I.D 五大原则之接口隔离原则 ISP/"><span>S.O.L.I.D 五大原则之接口隔离原则 ISP</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/18/深入理解javascript/21S.O.L.I.D 五大原则之接口隔离原则 ISP/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-18T05:01:34.000Z">
          2016-03-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章我们要讲解的是 S.O.L.I.D 五大原则 JavaScript 语言实现的第4篇，接口隔离原则 ISP（The Interface Segregation Principle）。</p>
<p>接口隔离原则的描述是：</p>
<blockquote>
<p>Clients should not be forced to depend on methods they do not use.<br>不应该强迫客户依赖于它们不用的方法。</p>
</blockquote>
<p>当用户依赖的接口方法即便只被别的用户使用而自己不用，那它也得实现这些接口，换而言之，一个用户依赖了未使用但被其他用户使用的接口，当其他用户修改该接口时，依赖该接口的所有用户都将受到影响。这显然违反了开闭原则，也不是我们所期望的。</p>
<p>接口隔离原则 ISP 和单一职责有点类似，都是用于聚集功能职责的，实际上 ISP 可以被理解才具有单一职责的程序转化到一个具有公共接口的对象。</p>
<h2 id="JavaScript-接口"><a href="#JavaScript-接口" class="headerlink" title="JavaScript 接口"></a>JavaScript 接口</h2><p>JavaScript 下我们改如何遵守这个原则呢？毕竟 JavaScript 没有接口的特性，如果接口就是我们所想的通过某种语言提供的抽象类型来建立 contract 和解耦的话，那可以说还行，不过 JavaScript 有另外一种形式的接口。在 <a href="http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612" target="_blank" rel="external">Design Patterns – Elements of Reusable Object-Oriented Software</a> 一书中我们找到了接口的定义：</p>
<blockquote>
<p>一个对象声明的任意一个操作都包含一个操作名称，参数对象和操作的返回值。我们称之为操作符的签名（signature）。<br>一个对象里声明的所有的操作被称为这个对象的接口（interface）。一个对象的接口描绘了所有发生在这个对象上的请求信息。</p>
</blockquote>
<p>不管一种语言是否提供一个单独的构造来表示接口，所有的对象都有一个由该对象所有属性和方法组成的隐式接口。参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">var exampleBinder = &#123;&#125;;</div><div class="line">exampleBinder.modelObserver = (function() &#123;</div><div class="line">    /* 私有变量 */</div><div class="line">    return &#123;</div><div class="line">        observe: function(model) &#123;</div><div class="line">            /* 代码 */</div><div class="line">            return newModel;</div><div class="line">        &#125;,</div><div class="line">        onChange: function(callback) &#123;</div><div class="line">            /* 代码 */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line">exampleBinder.viewAdaptor = (function() &#123;</div><div class="line">    /* 私有变量 */</div><div class="line">    return &#123;</div><div class="line">        bind: function(model) &#123;</div><div class="line">            /* 代码 */</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line">exampleBinder.bind = function(model) &#123;</div><div class="line">    /* 私有变量 */</div><div class="line">    exampleBinder.modelObserver.onChange(/* 回调callback */);</div><div class="line">    var om = exampleBinder.modelObserver.observe(model);</div><div class="line">    exampleBinder.viewAdaptor.bind(om);</div><div class="line">    return om;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的 exampleBinder 类库实现的功能是双向绑定。该类库暴露的公共接口是 bind 方法，其中 bind 里用到的关于 change 通知和 view 交互的功能分别是由单独的对象 modelObserver 和 viewAdaptor 来实现的，这些对象从某种意义上来说就是公共接口 bind 方法的具体实现。</p>
<p>尽管 JavaScript 没有提供接口类型来支持对象的 contract，但该对象的隐式接口依然能当做一个 contract 提供给程序用户。</p>
<h2 id="ISP-与-JavaScript"><a href="#ISP-与-JavaScript" class="headerlink" title="ISP 与 JavaScript"></a>ISP 与 JavaScript</h2><p>我们下面讨论的一些小节是 JavaScript 里关于违反接口隔离原则的影响。正如上面看到的，JavaScript 程序里实现接口隔离原则虽然可惜，但是不像静态类型语言那样强大，JavaScript 的语言特性有时候会使得所谓的接口搞得有点不粘性。</p>
<h3 id="堕落的实现"><a href="#堕落的实现" class="headerlink" title="堕落的实现"></a>堕落的实现</h3><p>在静态类型语言语言里，导致违反 ISP 原则的一个原因是堕落的实现。在 Java 和 C#里所有的接口里定义的方法都必须实现，如果你只需要其中几个方法，那其他的方法也必须实现（可以通过空实现或者抛异常的方式）。在 JavaScript 里，如果只需要一个对象里的某一些接口的话，他也解决不了堕落实现这个问题，虽然不用强制实现上面的接口。但是这种实现依然违反了里氏替换原则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var rectangle = &#123;</div><div class="line">    area: function() &#123;</div><div class="line">        /* 代码 */</div><div class="line">    &#125;,</div><div class="line">    draw: function() &#123;</div><div class="line">        /* 代码 */</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var geometryApplication = &#123;</div><div class="line">    getLargestRectangle: function(rectangles) &#123;</div><div class="line">        /* 代码 */</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var drawingApplication = &#123;</div><div class="line">    drawRectangles: function(rectangles) &#123;</div><div class="line">       /* 代码 */</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>当一个 rectangle 替代品为了满足新对象 geometryApplication 的 getLargestRectangle 的时候，它仅仅需要 rectangl e的 area()方法，但它却违反了 LSP（因为他根本用不到其中 drawRectangles 方法才能用到的 draw 方法）。</p>
<h3 id="静态耦合"><a href="#静态耦合" class="headerlink" title="静态耦合"></a>静态耦合</h3><p>静态类型语言里的另外一个导致违反 ISP 的原因是静态耦合，在静态类型语言里，接口在一个松耦合设计程序里扮演了重大角色。不管是在动态语言还是在静态语言，有时候一个对象都可能需要在多个客户端用户进行通信（比如共享状态），对静态类型语言，最好的解决方案是使用 <a href="http://martinfowler.com/bliki/RoleInterface.html" target="_blank" rel="external">Role Interfaces</a>，它允许用户和该对象进行交互（而该对象可能需要在多个角色）作为它的实现来对用户和无关的行为进行解耦。在 JavaScript 里就没有这种问题了，因为对象都被动态语言所特有的优点进行解耦了。</p>
<h3 id="语义耦合"><a href="#语义耦合" class="headerlink" title="语义耦合"></a>语义耦合</h3><p>导致违反 ISP 的一个通用原因，动态语言和静态类型语言都有，那就是语义耦合，所谓语义耦合就是互相依赖，也就是一个对象的行为依赖于另外一个对象，那就意味着，如果一个用户改变了其中一个行为，很有可能会影响另外一个使用用户。这也违反单一职责原则了。可以通过继承和对象替代来解决这个问题。</p>
<h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>另外一个导致问题的原因是关于可扩展性，很多人在举例的时候都会举关于 callback 的例子用来展示可扩展性（比如 ajax 里成功以后的回调设置）。如果想这样的接口需要一个实现并且这个实现的对象里有很多熟悉或方法的话，ISP 就会变得很重要了，也就是说当一个接口 interface 变成了一个需求实现很多方法的时候，他的实现将会变得异常复杂，而且有可能导致这些接口承担一个没有粘性的职责，这就是我们经常提到的胖接口。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JavaScript 里的动态语言特性，使得我们实现非粘性接口的影响力比静态类型语言小，但接口隔离原则在 JavaScript 程序设计模式里依然有它发挥作用的地方。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/11/深入理解javascript/9根本没有“JSON 对象”这回事！/"><span>根本没有“JSON 对象”这回事！</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/11/深入理解javascript/9根本没有“JSON 对象”这回事！/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-11T14:02:02.000Z">
          2016-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>写这篇文章的目的是经常看到开发人员说：把字符串转化为 JSON 对象，把 JSON 对象转化成字符串等类似的话题，所以把之前收藏的一篇老外的文章整理翻译了一下，供大家讨论，如有错误，请大家指出，多谢。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>本文的主题是基于 ECMAScript262-3 来写的，2011 年的 262-5 新规范增加了 JSON 对象，和我们平时所说的 JSON 有关系，但是不是同一个东西，文章最后一节会讲到新增加的 JSON 对象。</p>
<p>我想给大家澄清一下一个非常普遍的误解，我认为很多 JavaScript 开发人员都错误地把 JavaScript <code>对象字面量</code>（Object Literals）称为 <code>JSON 对象</code>（JSON Objects），因为他的语法和<a href="http://json.org/" target="_blank" rel="external">JSON规范</a>里描述的一样，但是该规范里也明确地说了 JSON 只是一个<code>数据交换语言</code>，只有我们将之用在 string 上下文的时候它才叫 JSON。</p>
<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>2 个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用 string 字符串因为 string 在很多语言里解析的方式都差不多。复杂的数据结构经常需要用到，并且通过各种各样的中括号{}，小括号()，叫括号<code>&lt;&gt;</code>和空格来组成，这个字符串仅仅是按照要求规范好的字符。</p>
<p>为此，我们为了描述这些复杂的数据结构作为一个 string 字符串，制定了标准的规则和语法。JSON 只是其中一种语法，它可以在 string 上下文里描述对象，数组，字符串，数字，布尔型和 null，然后通过程序间传输，并且反序列化成所需要的格式。<a href="http://en.wikipedia.org/wiki/YAML" target="_blank" rel="external">YAML</a> 和<a href="https://en.wikipedia.org/wiki/XML" target="_blank" rel="external"> XML</a>（甚至 <a href="http://benalman.com/news/2009/12/jquery-14-param-demystified/" target="_blank" rel="external">request params</a>）也是流行的数据交换格式，但是，我们喜欢 JSON，谁叫我们是 JavaScript 开发人员呢！</p>
<h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><p>引用 Mozilla Developer Center 里的几句话，供大家参考：</p>
<ol>
<li>他们是固定的值，不是变量，让你从“字面上”理解脚本。 (<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Literals" target="_blank" rel="external">Literals</a>)</li>
<li>字符串字面量是由双引号（”）或单引号（’）包围起来的零个或多个字符组成的。(<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#String_Literals" target="_blank" rel="external">Strings Literals</a>)</li>
<li>对象字面量是由大括号（{}）括起来的零个或多个对象的属性名-值对。(<a href="https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Object_Literalshttps://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Object_Literals" target="_blank" rel="external">Object Literals</a>)</li>
</ol>
<h2 id="何时是-JSON，何时不是-JSON？"><a href="#何时是-JSON，何时不是-JSON？" class="headerlink" title="何时是 JSON，何时不是 JSON？"></a>何时是 JSON，何时不是 JSON？</h2><p>JSON 是设计成描述数据交换格式的，他也有自己的语法，这个语法是 JavaScript 的一个子集。 { “prop”: “val” } 这样的声明有可能是 JavaScript 对象字面量也有可能是 JSON 字符串，取决于什么上下文使用它，如果是用在 string 上下文（用单引号或双引号引住，或者从 text 文件读取）的话，那它就是 JSON 字符串，如果是用在对象字面量上下文中，那它就是对象字面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这是JSON字符串</div><div class="line">var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这是对象字面量</div><div class="line">var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;;</div></pre></td></tr></table></figure>
<p>而且要注意，JSON 有非常严格的语法，在 string 上下文里{ “prop”: “val” } 是个合法的 JSON，但{ prop: “val” }和{ ‘prop’: ‘val’ }却是不合法的。所有属性名称和它的值都必须用双引号引住，不能使用单引号。另外，即便你用了转义以后的单引号也是不合法的，详细的语法规则可以到<a href="http://json.org/" target="_blank" rel="external">这里查看</a>。</p>
<h2 id="放到上下文里来看"><a href="#放到上下文里来看" class="headerlink" title="放到上下文里来看"></a>放到上下文里来看</h2><p>大家伙可能嗤之以鼻：难道 JavaScript 代码不是一个大的字符串？</p>
<p>当然是，所有的 JavaScrip t代码和 HTML（可能还有其他东西）都是字符串，直到浏览器对他们进行解析。这时候 .jf 文件或者 inline 的 JavaScript 代码已经不是字符串了，而是被当成真正的 JavaScript 源代码了，就像页面里的 innterHTML 一样，这时候也不是字符串了，而是被解析成 DOM 结构了。</p>
<p>再次说一下，这取决于上下文，在 string 上下文里使用带有大括号的 JavaScript 对象，那它就是 JSON 字符串，而如果在对象字面量上下文里使用的话，那它就是对象字面量。</p>
<h2 id="真正的-JSON-对象"><a href="#真正的-JSON-对象" class="headerlink" title="真正的 JSON 对象"></a>真正的 JSON 对象</h2><p>开头已经提到，对象字面量不是 JSON 对象，但是有<a href="https://developer.mozilla.org/en/Using_native_JSON" target="_blank" rel="external">真正的 JSON 对象</a>。但是两者完全不一样概念，在新版的浏览器里 JSON 对象已经被原生的内置对象了，目前有 2 个静态方法：<code>JSON.parse</code> 用来将 JSON 字符串反序列化成对象，<code>JSON.stringify</code> 用来将对象序列化成 JSON 字符串。老版本的浏览器不支持这个对象，但你可以通过 <a href="http://json.org/" target="_blank" rel="external">json2.js</a> 来实现同样的功能。</p>
<p>如果还不理解，别担心，参考一下的例子就知道了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 这是JSON字符串，比如从AJAX获取字符串信息</div><div class="line">var my_json_string = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 将字符串反序列化成对象</div><div class="line">var my_obj = JSON.parse( my_json_string );</div><div class="line">alert( my_obj.prop == &apos;val&apos; ); //  提示 true, 和想象的一样!</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 将对象序列化成JSON字符串</div><div class="line">var my_other_json_string = JSON.stringify( my_obj );</div></pre></td></tr></table></figure>
<p>另外，<a href="http://paulirish.com/" target="_blank" rel="external">Paul Irish</a>提到 Douglas Crockford 在 <a href="http://www.ietf.org/rfc/rfc4627.txt?number=4627" target="_blank" rel="external">JSON RFC </a>里用到了“JSON object”，但是在那个上下文里，他的意思是“对象描述成 JSON 字符串”不是“对象字面量”。</p>
<h2 id="更多资料"><a href="#更多资料" class="headerlink" title="更多资料"></a>更多资料</h2><p>如果你想了解更多关于 JSON 的资料，下面的连接对你绝对有用：</p>
<ul>
<li><a href="http://json.org/" target="_blank" rel="external">JSON specification</a></li>
<li><a href="http://www.ietf.org/rfc/rfc4627.txt?number=4627" target="_blank" rel="external">JSON RFC</a></li>
<li><a href="http://en.wikipedia.org/wiki/JSON" target="_blank" rel="external">JSON on Wikipedia</a></li>
<li><a href="http://www.jsonlint.com/" target="_blank" rel="external">JSONLint - The JSON Validator</a></li>
<li><a href="http://james.padolsey.com/javascript/json-is-not-the-same-as-json/" target="_blank" rel="external">JSON is not the same as JSON</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/11/深入理解javascript/18面向对象编程之 ECMAScript 实现/"><span>面向对象编程之 ECMAScript 实现</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/11/深入理解javascript/18面向对象编程之 ECMAScript 实现/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-11T11:03:02.000Z">
          2016-03-11
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章是关于 ECMAScript 面向对象实现的第 2 篇，第 1 篇我们讨论的是概论和 CEMAScript 的比较，如果你还没有读第1篇，在进行本章之前，我强烈建议你先读一下第1篇，因为本篇实在太长了（35页）。</p>
<p>注：由于篇幅太长了，难免出现错误，时刻保持修正中。</p>
<p>在概论里，我们延伸到了ECMAScript，现在，当我们知道它OOP实现时，我们再来准确定义一下：</p>
<blockquote>
<p>ECMAScript是一种面向对象语言，支持基于原型的委托式继承。</p>
</blockquote>
<p>我们将从最基本的数据类型来分析，首先要了解的是 ECMAScript 用原始值（primitive values）和对象（objects）来区分实体，因此有些文章里说的“在 JavaScript 里，一切都是对象”是错误的（不完全对），原始值就是我们这里要讨论的一些数据类型。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>虽然 ECMAScript 是可以动态转化类型的动态弱类型语言，它还是有数据类型的。也就是说，一个对象要属于一个实实在在的类型。标准规范里定义了 9 种数据类型，但只有 6 种是在 ECMAScript 程序里可以直接访问的，它们是：Undefined、Null、Boolean、String、Number、Object。</p>
<p>另外 3 种类型只能在实现级别访问（ECMAScript 对象是不能使用这些类型的）并用于规范来解释一些操作行为、保存中间值。这 3 种类型是：Reference、List 和 Completion。</p>
<p>因此，Reference 是用来解释 delete、typeof、this 这样的操作符，并且包含一个基对象和一个属性名称；List 描述的是参数列表的行为（在 new 表达式和函数调用的时候）；Completion 是用来解释行为 break、continue、return 和 throw 语句的。</p>
<h3 id="原始值类型"><a href="#原始值类型" class="headerlink" title="原始值类型"></a>原始值类型</h3><p>回头来看 6 中用于 ECMAScript 程序的数据类型，前5种是原始值类型，包括 Undefined、Null、Boolean、String、Number、Object。 原始值类型例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = undefined;</div><div class="line">var b = null;</div><div class="line">var c = true;</div><div class="line">var d = &apos;test&apos;;</div><div class="line">var e = 10;</div></pre></td></tr></table></figure>
<p>这些值是在底层上直接实现的，他们不是 object，所以没有原型，没有构造函数。</p>
<p><code>大叔注：这些原生值和我们平时用的(Boolean、String、Number、Object)虽然名字上相似，但不是同一个东西。所以 typeof(true)和 typeof(Boolean)结果是不一样的，因为 typeof(Boolean)的结果是 function，所以函数 Boolean、String、Number 是有原型的（下面的读写属性章节也会提到）。</code></p>
<p>想知道数据是哪种类型用 typeof 是最好不过了，有个例子需要注意一下，如果用 typeof 来判断 null 的类型，结果是 object，为什么呢？因为 null 的类型是定义为 Null 的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(typeof null); // &quot;object&quot;</div></pre></td></tr></table></figure>
<p>显示”object”原因是因为规范就是这么规定的：对于 Null 值的 typeof 字符串值返回”object“。</p>
<p>规范没有想象解释这个，但是 Brendan Eich (JavaScript 发明人)注意到 null 相对于 undefined 大多数都是用于对象出现的地方，例如设置一个对象为空引用。但是有些文档里有些气人将之归结为 bug，而且将该 bug 放在 Brendan Eich 也参与讨论的 bug 列表里，结果就是任其自然，还是把 typeof null 的结果设置为 object（尽管 262-3 的标准是定义 null 的类型是 Null，262-5 已经将标准修改为 null 的类型是 object 了）。</p>
<h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><p>接着，Object 类型（不要和 Object 构造函数混淆了，现在只讨论抽象类型）是描述 ECMAScript 对象的唯一一个数据类型。</p>
<blockquote>
<p>对象是一个包含key-value对的无序集合</p>
</blockquote>
<p>对象的 key 值被称为属性，属性是原始值和其他对象的容器。如果属性的值是函数我们称它为方法 。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var x = &#123; // 对象&quot;x&quot;有3个属性: a, b, c</div><div class="line">  a: 10, // 原始值</div><div class="line">  b: &#123;z: 100&#125;, // 对象&quot;b&quot;有一个属性z</div><div class="line">  c: function () &#123; // 函数(方法)</div><div class="line">    alert(&apos;method x.c&apos;);</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line">alert(x.a); // 10</div><div class="line">alert(x.b); // [object Object]</div><div class="line">alert(x.b.z); // 100</div><div class="line">x.c(); // &apos;method x.c&apos;</div></pre></td></tr></table></figure>
<h3 id="动态性"><a href="#动态性" class="headerlink" title="动态性"></a>动态性</h3><p>正如我们在第 17 章中指出的，ES 中的对象是完全动态的。这意味着，在程序执行的时候我们可以任意地添加，修改或删除对象的属性。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10&#125;;</div><div class="line">// 添加新属性</div><div class="line">foo.y = 20;</div><div class="line">console.log(foo); // &#123;x: 10, y: 20&#125;  </div><div class="line">// 将属性值修改为函数</div><div class="line">foo.x = function () &#123;</div><div class="line">  console.log(&apos;foo.x&apos;);</div><div class="line">&#125;;  </div><div class="line">foo.x(); // &apos;foo.x&apos;  </div><div class="line">// 删除属性</div><div class="line">delete foo.x;</div><div class="line">console.log(foo); // &#123;y: 20&#125;</div></pre></td></tr></table></figure>
<p>有些属性不能被修改——（只读属性、已删除属性或不可配置的属性）。 我们将稍后在属性特性里讲解。</p>
<p>另外，ES5 规范规定，静态对象不能扩展新的属性，并且它的属性页不能删除或者修改。他们是所谓的冻结对象，可以通过应用 Object.freeze(o)方法得到。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10&#125;;  </div><div class="line">// 冻结对象</div><div class="line">Object.freeze(foo);</div><div class="line">console.log(Object.isFrozen(foo)); // true  </div><div class="line">// 不能修改</div><div class="line">foo.x = 100;  </div><div class="line">// 不能扩展</div><div class="line">foo.y = 200;  </div><div class="line">// 不能删除</div><div class="line">delete foo.x;  </div><div class="line">console.log(foo); // &#123;x: 10&#125;</div></pre></td></tr></table></figure>
<p>在 ES5 规范里，也使用 Object.preventExtensions(o)方法防止扩展，或者使用 Object.defineProperty(o)方法来定义属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x : 10&#125;;  </div><div class="line">Object.defineProperty(foo, &quot;y&quot;, &#123;</div><div class="line">  value: 20,</div><div class="line">  writable: false, // 只读</div><div class="line">  configurable: false // 不可配置</div><div class="line">&#125;);  </div><div class="line">// 不能修改</div><div class="line">foo.y = 200;  </div><div class="line">// 不能删除</div><div class="line">delete foo.y; // false  </div><div class="line">// 防治扩展</div><div class="line">Object.preventExtensions(foo);</div><div class="line">console.log(Object.isExtensible(foo)); // false  </div><div class="line">// 不能添加新属性</div><div class="line">foo.z = 30;  </div><div class="line">console.log(foo); &#123;x: 10, y: 20&#125;</div></pre></td></tr></table></figure>
<h3 id="内置对象、原生对象及宿主对象"><a href="#内置对象、原生对象及宿主对象" class="headerlink" title="内置对象、原生对象及宿主对象"></a>内置对象、原生对象及宿主对象</h3><p>有必要需要注意的是规范还区分了这内置对象、元素对象和宿主对象。</p>
<p>内置对象和元素对象是被 ECMAScript 规范定义和实现的，两者之间的差异微不足道。所有 ECMAScript 实现的对象都是原生对象（其中一些是内置对象、一些在程序执行的时候创建，例如用户自定义对象）。内置对象是原生对象的一个子集、是在程序开始之前内置到 ECMAScript 里的（例如，parseInt， Match 等）。所有的宿主对象是由宿主环境提供的，通常是浏览器，并可能包括如 window、alert 等。</p>
<p>注意，宿主对象可能是 ES 自身实现的，完全符合规范的语义。从这点来说，他们能称为“原生宿主”对象（尽快很理论），不过规范没有定义“原生宿主”对象的概念。</p>
<h3 id="Boolean，String-和-Number-对象"><a href="#Boolean，String-和-Number-对象" class="headerlink" title="Boolean，String 和 Number 对象"></a>Boolean，String 和 Number 对象</h3><p>另外，规范也定义了一些原生的特殊包装类，这些对象是：</p>
<ol>
<li>布尔对象</li>
<li>字符串对象</li>
<li>数字对象</li>
</ol>
<p>这些对象的创建，是通过相应的内置构造器创建，并且包含原生值作为其内部属性，这些对象可以转换省原始值，反之亦然。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var c = new Boolean(true);</div><div class="line">var d = new String(&apos;test&apos;);</div><div class="line">var e = new Number(10);  </div><div class="line">// 转换成原始值</div><div class="line">// 使用不带new关键字的函数</div><div class="line">с = Boolean(c);</div><div class="line">d = String(d);</div><div class="line">e = Number(e);  </div><div class="line">// 重新转换成对象</div><div class="line">с = Object(c);</div><div class="line">d = Object(d);</div><div class="line">e = Object(e);</div></pre></td></tr></table></figure>
<p>此外，也有对象是由特殊的内置构造函数创建：Function（函数对象构造器）、Array（数组构造器） RegExp（正则表达式构造器）、Math（数学模块）、 Date（日期的构造器）等等，这些对象也是 Object 对象类型的值，他们彼此的区别是由内部属性管理的，我们在下面讨论这些内容。</p>
<h3 id="字面量-Literal"><a href="#字面量-Literal" class="headerlink" title="字面量 Literal"></a>字面量 Literal</h3><p>对于三个对象的值：对象（object）,数组（array）和正则表达式（regular expression），他们分别有简写的标示符称为：对象初始化器、数组初始化器、和正则表达式初始化器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 等价于new Array(1, 2, 3);</div><div class="line">// 或者array = new Array();</div><div class="line">// array[0] = 1;</div><div class="line">// array[1] = 2;</div><div class="line">// array[2] = 3;</div><div class="line">var array = [1, 2, 3];  </div><div class="line">// 等价于</div><div class="line">// var object = new Object();</div><div class="line">// object.a = 1;</div><div class="line">// object.b = 2;</div><div class="line">// object.c = 3;</div><div class="line">var object = &#123;a: 1, b: 2, c: 3&#125;;  </div><div class="line">// 等价于new RegExp(&quot;^\\d+$&quot;, &quot;g&quot;)</div><div class="line">var re = /^\d+$/g;</div></pre></td></tr></table></figure>
<p>注意，如果上述三个对象进行重新赋值名称到新的类型上的话，那随后的实现语义就是按照新赋值的类型来使用，例如在当前的 Rhino 和老版本 SpiderMonkey 1.7 的实现上，会成功以 new 关键字的构造器来创建对象，但有些实现（当前 Spider/TraceMonkey）字面量的语义在类型改变以后却不一定改变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var getClass = Object.prototype.toString;  </div><div class="line">Object = Number;  </div><div class="line">var foo = new Object;</div><div class="line">alert([foo, getClass.call(foo)]); // 0, &quot;[object Number]&quot;  </div><div class="line">var bar = &#123;&#125;;  </div><div class="line">// Rhino, SpiderMonkey 1.7中 - 0, &quot;[object Number]&quot;</div><div class="line">// 其它: still &quot;[object Object]&quot;, &quot;[object Object]&quot;</div><div class="line">alert([bar, getClass.call(bar)]);  </div><div class="line">// Array也是一样的效果</div><div class="line">Array = Number;  </div><div class="line">foo = new Array;</div><div class="line">alert([foo, getClass.call(foo)]); // 0, &quot;[object Number]&quot;  </div><div class="line">bar = [];  </div><div class="line">// Rhino, SpiderMonkey 1.7中 - 0, &quot;[object Number]&quot;</div><div class="line">// 其它: still &quot;&quot;, &quot;[object Object]&quot;</div><div class="line">alert([bar, getClass.call(bar)]);  </div><div class="line">// 但对RegExp,字面量的语义是不被改变的。 semantics of the literal</div><div class="line">// isn&apos;t being changed in all tested implementations  </div><div class="line">RegExp = Number;  </div><div class="line">foo = new RegExp;</div><div class="line">alert([foo, getClass.call(foo)]); // 0, &quot;[object Number]&quot;  </div><div class="line">bar = /(?!)/g;</div><div class="line">alert([bar, getClass.call(bar)]); // /(?!)/g, &quot;[object RegExp]&quot;</div></pre></td></tr></table></figure>
<p>正则表达式字面量和 RegExp 对象</p>
<p>注意，下面 2 个例子在第三版的规范里，正则表达式的语义都是等价的，regexp 字面量只在一句里存在，并且再解析阶段创建，但 RegExp 构造器创建的却是新对象，所以这可能会导致出一些问题，如 lastIndex 的值在测试的时候结果是错误的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for (var k = 0; k &lt; 4; k++) &#123;</div><div class="line">  var re = /ecma/g;</div><div class="line">  alert(re.lastIndex); // 0, 4, 0, 4</div><div class="line">  alert(re.test(&quot;ecmascript&quot;)); // true, false, true, false</div><div class="line">&#125;  </div><div class="line">// 对比  </div><div class="line">for (var k = 0; k &lt; 4; k++) &#123;</div><div class="line">  var re = new RegExp(&quot;ecma&quot;, &quot;g&quot;);</div><div class="line">  alert(re.lastIndex); // 0, 0, 0, 0</div><div class="line">  alert(re.test(&quot;ecmascript&quot;)); // true, true, true, true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注：不过这些问题在第 5 版的 ES 规范都已经修正了，不管是基于字面量的还是构造器的，正则都是创建新对象。</p>
<h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p>各种文字静态讨论，JavaScript 对象（经常是用对象初始化器{}来创建）被称为哈希表哈希表或其它简单的称谓：哈希（Ruby 或 Perl 里的概念）， 管理数组（PHP 里的概念），词典 （Python 里的概念）等。</p>
<p>只有这样的术语，主要是因为他们的结构都是相似的，就是使用“键-值”对来存储对象，完全符合“关联数组 ”或“哈希表 ”理论定义的数据结构。 此外，哈希表抽象数据类型通常是在实现层面使用。</p>
<p>但是，尽管术语上来描述这个概念，但实际上这个是错误，从 ECMAScript 来看：ECMAScript 只有一个对象以及类型以及它的子类型，这和“键-值”对存储没有什么区别，因此在这上面没有特别的概念。 因为任何对象的内部属性都可以存储为键-值”对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = &#123;x: 10&#125;;</div><div class="line">a[&apos;y&apos;] = 20;</div><div class="line">a.z = 30;  </div><div class="line">var b = new Number(1);</div><div class="line">b.x = 10;</div><div class="line">b.y = 20;</div><div class="line">b[&apos;z&apos;] = 30;  </div><div class="line">var c = new Function(&apos;&apos;);</div><div class="line">c.x = 10;</div><div class="line">c.y = 20;</div><div class="line">c[&apos;z&apos;] = 30;  </div><div class="line">// 等等，任意对象的子类型&quot;subtype&quot;</div></pre></td></tr></table></figure>
<p>此外，由于在 ECMAScript 中对象可以是空的，所以”hash”的概念在这里也是不正确的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;  </div><div class="line">var a = &#123;&#125;; // 创建空&quot;hash&quot;  </div><div class="line">alert(a[&quot;x&quot;]); // 10, 但不为空</div><div class="line">alert(a.toString); // function  </div><div class="line">a[&quot;y&quot;] = 20; // 添加新的键值对到 &quot;hash&quot;</div><div class="line">alert(a[&quot;y&quot;]); // 20  </div><div class="line">Object.prototype.y = 20; // 添加原型属性  </div><div class="line">delete a[&quot;y&quot;]; // 删除</div><div class="line">alert(a[&quot;y&quot;]); // 但这里key和value依然有值 – 20</div></pre></td></tr></table></figure>
<p>请注意，ES5 标准可以让我们创建没原型的对象（使用 Object.create(null)方法实现）对，从这个角度来说，这样的对象可以称之为哈希表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var aHashTable = Object.create(null);</div><div class="line">console.log(aHashTable.toString); // 未定义</div></pre></td></tr></table></figure>
<p>此外，一些属性有特定的 getter/setter 方法​​，所以也可能导致混淆这个概念：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var a = new String(&quot;foo&quot;);</div><div class="line">a[&apos;length&apos;] = 10;</div><div class="line">alert(a[&apos;length&apos;]); // 3</div></pre></td></tr></table></figure>
<p>然而，即使认为“哈希”可能有一个“原型”（例如，在 Ruby 或 Python 里委托哈希对象的类），在 ECMAScript 里，这个术语也是不对的，因为 2 个表示法之间没有语义上的区别（即用点表示法 a.b 和 a[“b”]表示法）。</p>
<p>在 ECMAScript 中的“property 属性”的概念语义上和”key”、数组索引、方法没有分开的，这里所有对象的属性读写都要遵循统一的规则：检查原型链。</p>
<p>在下面 Ruby 的例子中，我们可以看到语义上的区别：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">a = &#123;&#125;</div><div class="line">a.class # Hash</div><div class="line">a.length # 0  </div><div class="line">\# new &quot;key-value&quot; pair</div><div class="line">a[&apos;length&apos;] = 10;</div><div class="line">\# 语义上，用点访问的是属性或方法，而不是key  </div><div class="line">a.length # 1  </div><div class="line">\# 而索引器访问访问的是hash里的key  </div><div class="line">a[&apos;length&apos;] # 10  </div><div class="line">\# 就类似于在现有对象上动态声明Hash类</div><div class="line">\# 然后声明新属性或方法  </div><div class="line">class Hash</div><div class="line">  def z</div><div class="line">    100</div><div class="line">  end</div><div class="line">end</div><div class="line">\# 新属性可以访问  </div><div class="line">a.z # 100  </div><div class="line">\# 但不是&quot;key&quot;  </div><div class="line">a[&apos;z&apos;] # nil</div></pre></td></tr></table></figure>
<p>ECMA-262-3标准并没有定义“哈希”（以及类似）的概念。但是，有这样的结构理论的话，那可能以此命名的对象。</p>
<h3 id="对象转换"><a href="#对象转换" class="headerlink" title="对象转换"></a>对象转换</h3><p>将对象转化成原始值可以用 valueOf 方法，正如我们所说的，当函数的构造函数调用做为 function（对于某些类型的），但如果不用 new 关键字就是将对象转化成原始值，就相当于隐式的 valueOf 方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = new Number(1);</div><div class="line">var primitiveA = Number(a); // 隐式&quot;valueOf&quot;调用</div><div class="line">var alsoPrimitiveA = a.valueOf(); // 显式调用  </div><div class="line">alert([</div><div class="line">  typeof a, // &quot;object&quot;</div><div class="line">  typeof primitiveA, // &quot;number&quot;</div><div class="line">  typeof alsoPrimitiveA // &quot;number&quot;</div><div class="line">]);</div></pre></td></tr></table></figure>
<p>这种方式允许对象参与各种操作，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var a = new Number(1);</div><div class="line">var b = new Number(2);  </div><div class="line">alert(a + b); // 3  </div><div class="line">// 甚至  </div><div class="line">var c = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20,</div><div class="line">  valueOf: function () &#123;</div><div class="line">    return this.x + this.y;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line">var d = &#123;</div><div class="line">  x: 30,</div><div class="line">  y: 40,</div><div class="line">  // 和c的valueOf功能一样</div><div class="line">  valueOf: c.valueOf</div><div class="line">&#125;;  </div><div class="line">alert(c + d); // 100</div></pre></td></tr></table></figure>
<p>valueOf 的默认值会根据根据对象的类型改变（如果不被覆盖的话），对某些对象，他返回的是 this——例如：Object.prototype.valueOf()，还有计算型的值：Date.prototype.valueOf()返回的是日期时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = &#123;&#125;;</div><div class="line">alert(a.valueOf() === a); // true, &quot;valueOf&quot;返回this  </div><div class="line">var d = new Date();</div><div class="line">alert(d.valueOf()); // time</div><div class="line">alert(d.valueOf() === d.getTime()); // true</div></pre></td></tr></table></figure>
<p>此外，对象还有一个更原始的代表性——字符串展示。 这个 toString 方法是可靠的，它在某些操作上是自动使用的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var a = &#123;</div><div class="line">  valueOf: function () &#123;</div><div class="line">    return 100;</div><div class="line">  &#125;,</div><div class="line">  toString: function () &#123;</div><div class="line">    return &apos;__test&apos;;</div><div class="line">  &#125;</div><div class="line">&#125;;  </div><div class="line">// 这个操作里，toString方法自动调用</div><div class="line">alert(a); // &quot;__test&quot;  </div><div class="line">// 但是这里，调用的却是valueOf()方法</div><div class="line">alert(a + 10); // 110  </div><div class="line">// 但，一旦valueOf删除以后</div><div class="line">// toString又可以自动调用了</div><div class="line">delete a.valueOf;</div><div class="line">alert(a + 10); // &quot;_test10&quot;</div></pre></td></tr></table></figure>
<p>Object.prototype 上定义的 toString 方法具有特殊意义，它返回的我们下面将要讨论的内部[[Class]]属性值。</p>
<p>和转化成原始值（ToPrimitive）相比，将值转化成对象类型也有一个转化规范（ToObject）。</p>
<p>一个显式方法是使用内置的 Object 构造函数作为 function 来调用 ToObject（有些类似通过 new 关键字也可以）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var n = Object(1); // [object Number]</div><div class="line">var s = Object(&apos;test&apos;); // [object String]  </div><div class="line">// 一些类似，使用new操作符也可以</div><div class="line">var b = new Object(true); // [object Boolean]  </div><div class="line">// 应用参数new Object的话创建的是简单对象</div><div class="line">var o = new Object(); // [object Object]  </div><div class="line">// 如果参数是一个现有的对象</div><div class="line">// 那创建的结果就是简单返回该对象</div><div class="line">var a = [];</div><div class="line">alert(a === new Object(a)); // true</div><div class="line">alert(a === Object(a)); // true</div></pre></td></tr></table></figure>
<p>关于调用内置构造函数，使用还是不适用 new 操作符没有通用规则，取决于构造函数。 例如 Array 或 Function 当使用 new 操作符的构造函数或者不使用 new 操作符的简单函数使用产生相同的结果的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = Array(1, 2, 3); // [object Array]</div><div class="line">var b = new Array(1, 2, 3); // [object Array]</div><div class="line">var c = [1, 2, 3]; // [object Array]  </div><div class="line">var d = Function(&apos;&apos;); // [object Function]</div><div class="line">var e = new Function(&apos;&apos;); // [object Function]</div></pre></td></tr></table></figure>
<p>有些操作符使用的时候，也有一些显示和隐式转化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">var b = 2;   </div><div class="line">// 隐式</div><div class="line">var c = a + b; // 3, number</div><div class="line">var d = a + b + &apos;5&apos; // &quot;35&quot;, string  </div><div class="line">// 显式</div><div class="line">var e = &apos;10&apos;; // &quot;10&quot;, string</div><div class="line">var f = +e; // 10, number</div><div class="line">var g = parseInt(e, 10); // 10, number  </div><div class="line">// 等等</div></pre></td></tr></table></figure>
<h3 id="属性的特性"><a href="#属性的特性" class="headerlink" title="属性的特性"></a>属性的特性</h3><p>所有的属性（property） 都可以有很多特性（attributes）。</p>
<ol>
<li>{ReadOnly}——忽略向属性赋值的写操作尝，但只读属性可以由宿主环境行为改变——也就是说不是“恒定值” ；</li>
<li>{DontEnum}——属性不能被 for.in 循环枚举；</li>
<li>{DontDelete}——糊了 delete 操作符的行为被忽略（即删不掉）；</li>
<li>{Internal}——内部属性，没有名字（仅在实现层面使用），ECMAScript 里无法访问这样的属性。</li>
</ol>
<p>注意，在 ES5 里{ReadOnly}，{DontEnum}和{DontDelete}被重新命名为[[Writable]]，[[Enumerable]]和[[Configurable]]，可以手工通过 Object.defineProperty 或类似的方法来管理这些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;&#125;;  </div><div class="line">Object.defineProperty(foo, &quot;x&quot;, &#123;</div><div class="line">  value: 10,</div><div class="line">  writable: true, // 即&#123;ReadOnly&#125; = false</div><div class="line">  enumerable: false, // 即&#123;DontEnum&#125; = true</div><div class="line">  configurable: true // 即&#123;DontDelete&#125; = false</div><div class="line">&#125;);  </div><div class="line">console.log(foo.x); // 10  </div><div class="line">// 通过descriptor获取特性集attributes</div><div class="line">var desc = Object.getOwnPropertyDescriptor(foo, &quot;x&quot;);  </div><div class="line">console.log(desc.enumerable); // false</div><div class="line">console.log(desc.writable); // true</div><div class="line">// 等等</div></pre></td></tr></table></figure>
<h3 id="内部属性和方法"><a href="#内部属性和方法" class="headerlink" title="内部属性和方法"></a>内部属性和方法</h3><p>对象也可以有内部属性（实现层面的一部分），并且 ECMAScript 程序无法直接访问（但是下面我们将看到，一些实现允许访问一些这样的属性）。 这些属性通过嵌套的中括号[[ ]]进行访问。我们来看其中的一些，这些属性的描述可以到规范里查阅到。</p>
<p>每个对象都应该实现如下内部属性和方法：</p>
<ol>
<li>[[Prototype]]——对象的原型（将在下面详细介绍）</li>
<li>[[Class]]——字符串对象的一种表示（例如，Object Array ，Function Object，Function等）;用来区分对象</li>
<li>[[Get]]——获得属性值的方法</li>
<li>[[Put]]——设置属性值的方法</li>
<li>[[CanPut]]——检查属性是否可写</li>
<li>[[HasProperty]]——检查对象是否已经拥有该属性</li>
<li>[[Delete]]——从对象删除该属性</li>
<li>[[DefaultValue]]返回对象对于的原始值（调用 valueOf 方法，某些对象可能会抛出 TypeError 异常）。</li>
</ol>
<p>通过 Object.prototype.toString()方法可以间接得到内部属性[[Class]]的值，该方法应该返回下列字符串： “[object “ + [[Class]] + “]” 。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var getClass = Object.prototype.toString;  </div><div class="line">getClass.call(&#123;&#125;); // [object Object]</div><div class="line">getClass.call([]); // [object Array]</div><div class="line">getClass.call(new Number(1)); // [object Number]</div><div class="line">// 等等</div></pre></td></tr></table></figure>
<p>这个功能通常是用来检查对象用的，但规范上说宿主对象的[[Class]]可以为任意值，包括内置对象的[[Class]]属性的值，所以理论上来看是不能 100%来保证准确的。例如，document.childNodes.item(…)方法的[[Class]]属性，在IE里返回”String”，但其它实现里返回的确实”Function”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// in IE - &quot;String&quot;, in other - &quot;Function&quot;</div><div class="line">alert(getClass.call(document.childNodes.item));</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>因此，正如我们上面提到的，在 ECMAScript 中的对象是通过所谓的构造函数来创建的。</p>
<blockquote>
<p>Constructor is a function that creates and initializes the newly created object.<br>构造函数是一个函数，用来创建并初始化新创建的对象。</p>
</blockquote>
<p>对象创建（内存分配）是由构造函数的内部方法[[Construct]]负责的。该内部方法的行为是定义好的，所有的构造函数都是使用该方法来为新对象分配内存的。</p>
<p>而初始化是通过新建对象上下上调用该函数来管理的，这是由构造函数的内部方法[[Call]]来负责任的。</p>
<p>注意，用户代码只能在初始化阶段访问，虽然在初始化阶段我们可以返回不同的对象（忽略第一阶段创建的 tihs 对象）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">  // 更新新创建的对象</div><div class="line">  this.x = 10;</div><div class="line">  // 但返回的是不同的对象</div><div class="line">  return [1, 2, 3];</div><div class="line">&#125;  </div><div class="line">var a = new A();</div><div class="line">console.log(a.x, a); undefined, [1, 2, 3]</div></pre></td></tr></table></figure>
<p>引用 15 章函数——创建函数的算法小节，我们可以看到该函数是一个原生对象，包含[[Construct]] ]和[[Call]] ]属性以及显示的 prototype 原型属性——未来对象的原型（注：NativeObject 是对于 native object 原生对象的约定，在下面的伪代码中使用）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">F = new NativeObject();  </div><div class="line">F.[[Class]] = &quot;Function&quot;  </div><div class="line">.... // 其它属性  </div><div class="line">F.[[Call]] = &lt;reference to function&gt; // function自身  </div><div class="line">F.[[Construct]] = internalConstructor // 普通的内部构造函数  </div><div class="line">.... // 其它属性  </div><div class="line">// F构造函数创建的对象原型</div><div class="line">__objectPrototype = &#123;&#125;;</div><div class="line">__objectPrototype.constructor = F // &#123;DontEnum&#125;</div><div class="line">F.prototype = __objectPrototype</div></pre></td></tr></table></figure>
<p>[[Call]] ]是除[[Class]]属性（这里等同于”Function” ）之外区分对象的主要方式，因此，对象的内部[[Call]]属性作为函数调用。 这样的对象用 typeof 运算操作符的话返回的是”function”。然而它主要是和原生对象有关，有些情况的实现在用 typeof 获取值的是不一样的，例如：window.alert (…)在 IE 中的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// IE浏览器中 - &quot;Object&quot;, &quot;object&quot;, 其它浏览器 - &quot;Function&quot;, &quot;function&quot;</div><div class="line">alert(Object.prototype.toString.call(window.alert));</div><div class="line">alert(typeof window.alert); // &quot;Object&quot;</div></pre></td></tr></table></figure>
<p>内部方法[[Construct]]是通过使用带new运算符的构造函数来激活的，正如我们所说的这个方法是负责内存分配和对象创建的。如果没有参数，调用构造函数的括号也可以省略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function A(x) &#123; // constructor А</div><div class="line">  this.x = x || 10;</div><div class="line">&#125;  </div><div class="line">// 不传参数的话，括号也可以省略</div><div class="line">var a = new A; // or new A();</div><div class="line">alert(a.x); // 10  </div><div class="line">// 显式传入参数x</div><div class="line">var b = new A(20);</div><div class="line">alert(b.x); // 20</div></pre></td></tr></table></figure>
<p>我们也知道，构造函数（初始化阶段）里的 this 被设置为新创建的对象 。</p>
<p>让我们研究一下对象创建的算法。</p>
<h3 id="对象创建的算法"><a href="#对象创建的算法" class="headerlink" title="对象创建的算法"></a>对象创建的算法</h3><p>内部方法[[Construct]] 的行为可以描述成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">F.[[Construct]](initialParameters):   </div><div class="line">O = new NativeObject();  </div><div class="line">// 属性[[Class]]被设置为&quot;Object&quot;</div><div class="line">O.[[Class]] = &quot;Object&quot;  </div><div class="line">// 引用F.prototype的时候获取该对象g</div><div class="line">var __objectPrototype = F.prototype;  </div><div class="line">// 如果__objectPrototype是对象，就:</div><div class="line">O.[[Prototype]] = __objectPrototype</div><div class="line">// 否则:</div><div class="line">O.[[Prototype]] = Object.prototype;</div><div class="line">// 这里O.[[Prototype]]是Object对象的原型  </div><div class="line">// 新创建对象初始化的时候应用了F.[[Call]]</div><div class="line">// 将this设置为新创建的对象O</div><div class="line">// 参数和F里的initialParameters是一样的</div><div class="line">R = F.[[Call]](initialParameters); this === O;</div><div class="line">// 这里R是[[Call]]的返回值</div><div class="line">// 在JS里看，像这样:</div><div class="line">// R = F.apply(O, initialParameters);  </div><div class="line">// 如果R是对象</div><div class="line">return R</div><div class="line">// 否则</div><div class="line">return O</div></pre></td></tr></table></figure>
<p>请注意两个主要特点：</p>
<ol>
<li>首先，新创建对象的原型是从当前时刻函数的 prototype 属性获取的（这意味着同一个构造函数创建的两个创建对象的原型可以不同是因为函数的 prototype 属性也可以不同）。</li>
<li>其次，正如我们上面提到的，如果在对象初始化的时候，[[Call]]返回的是对象，这恰恰是用于整个 new 操作符的结果：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10 – 从原型上得到  </div><div class="line">// 设置.prototype属性为新对象</div><div class="line">// 为什么显式声明.constructor属性将在下面说明</div><div class="line">A.prototype = &#123;</div><div class="line">  constructor: A,</div><div class="line">  y: 100</div><div class="line">&#125;;  </div><div class="line">var b = new A();</div><div class="line">// 对象&quot;b&quot;有了新属性</div><div class="line">alert(b.x); // undefined</div><div class="line">alert(b.y); // 100 – 从原型上得到  </div><div class="line">// 但a对象的原型依然可以得到原来的结果</div><div class="line">alert(a.x); // 10 - 从原型上得到  </div><div class="line">function B() &#123;</div><div class="line">  this.x = 10;</div><div class="line">  return new Array();</div><div class="line">&#125;  </div><div class="line">// 如果&quot;B&quot;构造函数没有返回（或返回this）</div><div class="line">// 那么this对象就可以使用，但是下面的情况返回的是array</div><div class="line">var b = new B();</div><div class="line">alert(b.x); // undefined</div><div class="line">alert(Object.prototype.toString.call(b)); // [object Array]</div></pre></td></tr></table></figure>
<p>让我们来详细了解一下原型</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>每个对象都有一个原型（一些系统对象除外）。原型通信是通过内部的、隐式的、不可直接访问[[Prototype]]原型属性来进行的，原型可以是一个对象，也可以是 null 值。</p>
<h3 id="属性构造函数-Property-constructor"><a href="#属性构造函数-Property-constructor" class="headerlink" title="属性构造函数(Property constructor)"></a>属性构造函数(Property constructor)</h3><p>上面的例子有有 2 个重要的知识点，第一个是关于函数的 constructor 属性的 prototype 属性，在函数创建的算法里，我们知道 constructor 属性在函数创建阶段被设置为函数的 prototype 属性，constructor 属性的值是函数自身的重要引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">var a = new A();</div><div class="line">alert(a.constructor); // function A() &#123;&#125;, by delegation</div><div class="line">alert(a.constructor === A); // true</div></pre></td></tr></table></figure>
<p>通常在这种情况下，存在着一个误区：constructor 构造属性作为新创建对象自身的属性是错误的，但是，正如我们所看到的的，这个属性属于原型并且通过继承来访问对象。</p>
<p>通过继承 constructor 属性的实例，可以间接得到的原型对象的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = new Number(10);</div><div class="line">var a = new A();</div><div class="line">alert(a.constructor.prototype); // [object Object]  </div><div class="line">alert(a.x); // 10, 通过原型</div><div class="line">// 和a.[[Prototype]].x效果一样</div><div class="line">alert(a.constructor.prototype.x); // 10  </div><div class="line">alert(a.constructor.prototype.x === a.x); // true</div></pre></td></tr></table></figure>
<p>但请注意，函数的 constructor 和 prototype 属性在对象创建以后都可以重新定义的。在这种情况下，对象失去上面所说的机制。如果通过函数的 prototype 属性去编辑元素的 prototype 原型的话（添加新对象或修改现有对象），实例上将看到新添加的属性。</p>
<p>然而，如果我们彻底改变函数的 prototype 属性（通过分配一个新的对象），那原始构造函数的引用就是丢失，这是因为我们创建的对象不包括 constructor 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype = &#123;</div><div class="line">  x: 10</div><div class="line">&#125;;   </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.constructor === A); // false!</div></pre></td></tr></table></figure>
<p>因此，对函数的原型引用需要手工恢复：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype = &#123;</div><div class="line">  constructor: A,</div><div class="line">  x: 10</div><div class="line">&#125;;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.constructor === A); // true</div></pre></td></tr></table></figure>
<p>注意虽然手动恢复了 constructor 属性，和原来丢失的原型相比，{DontEnum}特性没有了，也就是说 A.prototype 里的 for..in 循环语句不支持了，不过第 5 版规范里，通过[[Enumerable]] 特性提供了控制可枚举状态 enumerable 的能力。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10&#125;;  </div><div class="line">Object.defineProperty(foo, &quot;y&quot;, &#123;</div><div class="line">  value: 20,</div><div class="line">  enumerable: false // aka &#123;DontEnum&#125; = true</div><div class="line">&#125;);  </div><div class="line">console.log(foo.x, foo.y); // 10, 20  </div><div class="line">for (var k in foo) &#123;</div><div class="line">  console.log(k); // only &quot;x&quot;</div><div class="line">&#125;  </div><div class="line">var xDesc = Object.getOwnPropertyDescriptor(foo, &quot;x&quot;);</div><div class="line">var yDesc = Object.getOwnPropertyDescriptor(foo, &quot;y&quot;);  </div><div class="line">console.log(</div><div class="line">  xDesc.enumerable, // true</div><div class="line">  yDesc.enumerable  // false</div><div class="line">);</div></pre></td></tr></table></figure>
<p>显式 prototype 和隐式[[Prototype]]属性</p>
<p>通常，一个对象的原型通过函数的 prototype 属性显式引用是不正确的，他引用的是同一个对象，对象的[[Prototype]]属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype</div></pre></td></tr></table></figure>
<p>此外， 实例的[[Prototype]]值确实是在构造函数的 prototype 属性上获取的。</p>
<p>然而，提交 prototype 属性不会影响已经创建对象的原型（只有在构造函数的 prototype 属性改变的时候才会影响到)，就是说新创建的对象才有有新的原型，而已创建对象还是引用到原来的旧原型（这个原型已经不能被再被修改了）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在修改A.prototype原型之前的情况</div><div class="line">a.[[Prototype]] ----&gt; Prototype &lt;---- A.prototype  </div><div class="line">// 修改之后</div><div class="line">A.prototype ----&gt; New prototype // 新对象会拥有这个原型</div><div class="line">a.[[Prototype]] ----&gt; Prototype // 引导的原来的原型上</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10  </div><div class="line">A.prototype = &#123;</div><div class="line">  constructor: A,</div><div class="line">  x: 20</div><div class="line">  y: 30</div><div class="line">&#125;;  </div><div class="line">// 对象a是通过隐式的[[Prototype]]引用从原油的prototype上获取的值</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.y) // undefined  </div><div class="line">var b = new A();  </div><div class="line">// 但新对象是从新原型上获取的值</div><div class="line">alert(b.x); // 20</div><div class="line">alert(b.y) // 30</div></pre></td></tr></table></figure>
<p>因此，有的文章说“动态修改原型将影响所有的对象都会拥有新的原型”是错误的，新原型仅仅在原型修改以后的新创建对象上生效。</p>
<p>这里的主要规则是：对象的原型是对象的创建的时候创建的，并且在此之后不能修改为新的对象，如果依然引用到同一个对象，可以通过构造函数的显式 prototype 引用，对象创建以后，只能对原型的属性进行添加或修改。</p>
<h2 id="非标准的proto属性"><a href="#非标准的proto属性" class="headerlink" title="非标准的proto属性"></a>非标准的<strong>proto</strong>属性</h2><p>然而，有些实现（例如 SpiderMonkey），提供了不标准的<strong>proto</strong>显式属性来引用对象的原型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10  </div><div class="line">var __newPrototype = &#123;</div><div class="line">  constructor: A,</div><div class="line">  x: 20,</div><div class="line">  y: 30</div><div class="line">&#125;;  </div><div class="line">// 引用到新对象</div><div class="line">A.prototype = __newPrototype;  </div><div class="line">var b = new A();</div><div class="line">alert(b.x); // 20</div><div class="line">alert(b.y); // 30  </div><div class="line">// &quot;a&quot;对象使用的依然是旧的原型</div><div class="line">alert(a.x); // 10</div><div class="line">alert(a.y); // undefined  </div><div class="line">// 显式修改原型</div><div class="line">a.__proto__ = __newPrototype;  </div><div class="line">// 现在&quot;а&quot;对象引用的是新对象</div><div class="line">alert(a.x); // 20</div><div class="line">alert(a.y); // 30</div></pre></td></tr></table></figure>
<p>注意，ES5 提供了 Object.getPrototypeOf(O)方法，该方法直接返回对象的[[Prototype]]属性——实例的初始原型。 然而，和<strong>proto</strong>相比，它只是 getter，它不允许 set 值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;&#125;;</div><div class="line">Object.getPrototypeOf(foo) == Object.prototype; // true</div></pre></td></tr></table></figure>
<h3 id="对象独立于构造函数"><a href="#对象独立于构造函数" class="headerlink" title="对象独立于构造函数"></a>对象独立于构造函数</h3><p>因为实例的原型独立于构造函数和构造函数的 prototype 属性，构造函数完成了自己的主要工作（创建对象）以后可以删除。原型对象通过引用[[Prototype]]属性继续存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10  </div><div class="line">// 设置A为null - 显示引用构造函数</div><div class="line">A = null;  </div><div class="line">// 但如果.constructor属性没有改变的话，</div><div class="line">// 依然可以通过它创建对象</div><div class="line">var b = new a.constructor();</div><div class="line">alert(b.x); // 10  </div><div class="line">// 隐式的引用也删除掉</div><div class="line">delete a.constructor.prototype.constructor;</div><div class="line">delete b.constructor.prototype.constructor;  </div><div class="line">// 通过A的构造函数再也不能创建对象了</div><div class="line">// 但这2个对象依然有自己的原型</div><div class="line">alert(a.x); // 10</div><div class="line">alert(b.x); // 10</div></pre></td></tr></table></figure>
<h3 id="instanceof-操作符的特性"><a href="#instanceof-操作符的特性" class="headerlink" title="instanceof 操作符的特性"></a>instanceof 操作符的特性</h3><p>我们是通过构造函数的 prototype 属性来显示引用原型的，这和 instanceof 操作符有关。该操作符是和原型链一起工作的，而不是构造函数，考虑到这一点，当检测对象的时候往往会有误解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (foo instanceof Foo) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不是用来检测对象 foo 是否是用 Foo 构造函数创建的，所有 instanceof 运算符只需要一个对象属性—— foo.[[Prototype]]，在原型链中从 Foo.prototype 开始检查其是否存在。instanceof 运算符是通过构造函数里的内部方法[[HasInstance]]来激活的。</p>
<p>让我们来看看这个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A();</div><div class="line">alert(a.x); // 10  </div><div class="line">alert(a instanceof A); // true  </div><div class="line">// 如果设置原型为null</div><div class="line">A.prototype = null;  </div><div class="line">// ...&quot;a&quot;依然可以通过a.[[Prototype]]访问原型</div><div class="line">alert(a.x); // 10  </div><div class="line">// 不过，instanceof操作符不能再正常使用了</div><div class="line">// 因为它是从构造函数的prototype属性来实现的</div><div class="line">alert(a instanceof A); // 错误，A.prototype不是对象</div></pre></td></tr></table></figure>
<p>另一方面，可以由构造函数来创建对象，但如果对象的[[Prototype]]属性和构造函数的 prototype 属性的值设置的是一样的话，instanceof 检查的时候会返回 true：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function B() &#123;&#125;</div><div class="line">var b = new B();  </div><div class="line">alert(b instanceof B); // true  </div><div class="line">function C() &#123;&#125;  </div><div class="line">var __proto = &#123;</div><div class="line">  constructor: C</div><div class="line">&#125;;  </div><div class="line">C.prototype = __proto;</div><div class="line">b.__proto__ = __proto;  </div><div class="line">alert(b instanceof C); // true</div><div class="line">alert(b instanceof B); // false</div></pre></td></tr></table></figure>
<h3 id="原型可以存放方法并共享属性"><a href="#原型可以存放方法并共享属性" class="headerlink" title="原型可以存放方法并共享属性"></a>原型可以存放方法并共享属性</h3><p>大部分程序里使用原型是用来存储对象的方法、默认状态和共享对象的属性。</p>
<p>事实上，对象可以拥有自己的状态 ，但方法通常是一样的。 因此，为了内存优化，方法通常是在原型里定义的。 这意味着，这个构造函数创建的所有实例都可以共享找个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">function A(x) &#123;</div><div class="line">  this.x = x || 100;</div><div class="line">&#125;   </div><div class="line">A.prototype = (function () &#123;  </div><div class="line">  // 初始化上下文</div><div class="line">  // 使用额外的对象  </div><div class="line">  var _someSharedVar = 500;  </div><div class="line">  function _someHelper() &#123;</div><div class="line">    alert(&apos;internal helper: &apos; + _someSharedVar);</div><div class="line">  &#125;  </div><div class="line">  function method1() &#123;</div><div class="line">    alert(&apos;method1: &apos; + this.x);</div><div class="line">  &#125;  </div><div class="line">  function method2() &#123;</div><div class="line">    alert(&apos;method2: &apos; + this.x);</div><div class="line">    _someHelper();</div><div class="line">  &#125;  </div><div class="line">  // 原型自身</div><div class="line">  return &#123;</div><div class="line">    constructor: A,</div><div class="line">    method1: method1,</div><div class="line">    method2: method2</div><div class="line">  &#125;;  </div><div class="line">&#125;)();  </div><div class="line">var a = new A(10);</div><div class="line">var b = new A(20);  </div><div class="line">a.method1(); // method1: 10</div><div class="line">a.method2(); // method2: 10, internal helper: 500  </div><div class="line">b.method1(); // method1: 20</div><div class="line">b.method2(); // method2: 20, internal helper: 500  </div><div class="line">// 2个对象使用的是原型里相同的方法</div><div class="line">alert(a.method1 === b.method1); // true</div><div class="line">alert(a.method2 === b.method2); // true</div></pre></td></tr></table></figure>
<h2 id="读写属性"><a href="#读写属性" class="headerlink" title="读写属性"></a>读写属性</h2><p>正如我们提到，读取和写入属性值是通过内部的[[Get]]和[[Put]]方法。这些内部方法是通过属性访问器激活的：点标记法或者索引标记法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 写入</div><div class="line">foo.bar = 10; // 调用了[[Put]]  </div><div class="line">console.log(foo.bar); // 10, 调用了[[Get]]</div><div class="line">console.log(foo[&apos;bar&apos;]); // 效果一样</div></pre></td></tr></table></figure>
<p>让我们用伪代码来看一下这些方法是如何工作的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[[Get]]方法</div><div class="line">[[Get]]也会从原型链中查询属性，所以通过对象也可以访问原型中的属性。  </div><div class="line">O.[[Get]](P):  </div><div class="line">// 如果是自己的属性，就返回</div><div class="line">if (O.hasOwnProperty(P)) &#123;</div><div class="line">  return O.P;</div><div class="line">&#125;  </div><div class="line">// 否则，继续分析原型</div><div class="line">var __proto = O.[[Prototype]];  </div><div class="line">// 如果原型是null，返回undefined</div><div class="line">// 这是可能的：最顶层Object.prototype.[[Prototype]]是null</div><div class="line">if (__proto === null) &#123;</div><div class="line">  return undefined;</div><div class="line">&#125;  </div><div class="line">// 否则，对原型链递归调用[[Get]]，在各层的原型中查找属性</div><div class="line">// 直到原型为null</div><div class="line">return __proto.[[Get]](P)</div></pre></td></tr></table></figure>
<p>请注意，因为[[Get]]在如下情况也会返回 undefined：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (window.someObject) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，在 window 里没有找到 someObject 属性，然后会在原型里找，原型的原型里找，以此类推，如果都找不到，按照定义就返回 undefined。</p>
<p>注意：in 操作符也可以负责查找属性（也会查找原型链）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (&apos;someObject&apos; in window) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这有助于避免一些特殊问题：比如即便 someObject 存在，在 someObject 等于 false 的时候，第一轮检测就通不过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[[Put]]方法</div><div class="line">[[Put]]方法可以创建、更新对象自身的属性，并且掩盖原型里的同名属性  </div><div class="line">O.[[Put]](P, V):  </div><div class="line">// 如果不能给属性写值，就退出</div><div class="line">if (!O.[[CanPut]](P)) &#123;</div><div class="line">  return;</div><div class="line">&#125;  </div><div class="line">// 如果对象没有自身的属性，就创建它</div><div class="line">// 所有的attributes特性都是false</div><div class="line">if (!O.hasOwnProperty(P)) &#123;</div><div class="line">  createNewProperty(O, P, attributes: &#123;</div><div class="line">    ReadOnly: false,</div><div class="line">    DontEnum: false,</div><div class="line">    DontDelete: false,</div><div class="line">    Internal: false</div><div class="line">  &#125;);</div><div class="line">&#125;  </div><div class="line">// 如果属性存在就设置值，但不改变attributes特性</div><div class="line">O.P = V  </div><div class="line">return;</div></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 100;  </div><div class="line">var foo = &#123;&#125;;</div><div class="line">console.log(foo.x); // 100, 继承属性  </div><div class="line">foo.x = 10; // [[Put]]</div><div class="line">console.log(foo.x); // 10, 自身属性  </div><div class="line">delete foo.x;</div><div class="line">console.log(foo.x); // 重新是100,继承属性</div></pre></td></tr></table></figure>
<p>请注意，不能掩盖原型里的只读属性，赋值结果将忽略，这是由内部方法[[CanPut]]控制的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 例如，属性length是只读的，我们来掩盖一下length试试  </div><div class="line">function SuperString() &#123;</div><div class="line">  /* nothing */</div><div class="line">&#125;  </div><div class="line">SuperString.prototype = new String(&quot;abc&quot;);  </div><div class="line">var foo = new SuperString();  </div><div class="line">console.log(foo.length); // 3, &quot;abc&quot;的长度 </div><div class="line">// 尝试掩盖</div><div class="line">foo.length = 5;</div><div class="line">console.log(foo.length); // 依然是3</div></pre></td></tr></table></figure>
<p>但在 ES5 的严格模式下，如果掩盖只读属性的话，会保存 TypeError 错误。</p>
<h3 id="属性访问器"><a href="#属性访问器" class="headerlink" title="属性访问器"></a>属性访问器</h3><p>内部方法[[Get]]和[[Put]]在 ECMAScript 里是通过点符号或者索引法来激活的，如果属性标示符是合法的名字的话，可以通过“.”来访问，而索引方运行动态定义名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var a = &#123;testProperty: 10&#125;;  </div><div class="line">alert(a.testProperty); // 10, 点</div><div class="line">alert(a[&apos;testProperty&apos;]); // 10, 索引  </div><div class="line">var propertyName = &apos;Property&apos;;</div><div class="line">alert(a[&apos;test&apos; + propertyName]); // 10, 动态属性通过索引的方式</div></pre></td></tr></table></figure>
<p>这里有一个非常重要的特性——属性访问器总是使用 ToObject 规范来对待“.”左边的值。这种隐式转化和这句“在 JavaScript 中一切都是对象”有关系，（然而，当我们已经知道了，JavaScript 里不是所有的值都是对象）。</p>
<p>如果对原始值进行属性访问器取值，访问之前会先对原始值进行对象包装（包括原始值），然后通过包装的对象进行访问属性，属性访问以后，包装对象就会被删除。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var a = 10; // 原始值  </div><div class="line">// 但是可以访问方法（就像对象一样）</div><div class="line">alert(a.toString()); // &quot;10&quot;  </div><div class="line">// 此外，我们可以在a上创建一个心属性</div><div class="line">a.test = 100; // 好像是没问题的  </div><div class="line">// 但，[[Get]]方法没有返回该属性的值，返回的却是undefined</div><div class="line">alert(a.test); // undefined</div></pre></td></tr></table></figure>
<p>那么，为什么整个例子里的原始值可以访问 toString 方法，而不能访问新创建的 test 属性呢？</p>
<p>答案很简单：</p>
<p>首先，正如我们所说，使用属性访问器以后，它已经不是原始值了，而是一个包装过的中间对象（整个例子是使用 new Number(a)），而 toString 方法这时候是通过原型链查找到的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 执行a.toString()的原理:</div><div class="line">1. wrapper = new Number(a);</div><div class="line">2. wrapper.toString(); // &quot;10&quot;</div><div class="line">3. delete wrapper;</div></pre></td></tr></table></figure>
<p>接下来，[[Put]]方法创建新属性时候，也是通过包装装的对象进行的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 执行a.test = 100的原理：</div><div class="line">1. wrapper = new Number(a);</div><div class="line">2. wrapper.test = 100;</div><div class="line">3. delete wrapper;</div></pre></td></tr></table></figure>
<p>我们看到，在第3步的时候，包装的对象以及删除了，随着新创建的属性页被删除了——删除包装对象本身。</p>
<p>然后使用[[Get]]获取 test 值的时候，再一次创建了包装对象，但这时候包装的对象已经没有 test 属性了，所以返回的是 undefined：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 执行a.test的原理:  </div><div class="line">1. wrapper = new Number(a);</div><div class="line">2. wrapper.test; // undefined</div></pre></td></tr></table></figure>
<p>这种方式解释了原始值的读取方式，另外，任何原始值如果经常用在访问属性的话，时间效率考虑，都是直接用一个对象替代它；与此相反，如果不经常访问，或者只是用于计算的话，到可以保留这种形式。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>我们知道，ECMAScript 是使用基于原型的委托式继承。链和原型在原型链里已经提到过了。其实，所有委托的实现和原型链的查找分析都浓缩到[[Get]]方法了。</p>
<p>如果你完全理解[[Get]]方法，那 JavaScript 中的继承这个问题将不解自答了。</p>
<p>经常在论坛上谈论 JavaScript 中的继承时，我都是用一行代码来展示，事实上，我们不需要创建任何对象或函数，因为该语言已经是基于继承的了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(1..toString()); // &quot;1&quot;</div></pre></td></tr></table></figure>
<p>我们已经知道了[[Get]]方法和属性访问器的原理了，我们来看看都发生了什么：</p>
<ol>
<li>首先，从原始值 1，通过 new Number(1)创建包装对象</li>
<li>然后 toString 方法是从这个包装对象上继承得到的</li>
</ol>
<p>为什么是继承的？ 因为在 ECMAScript 中的对象可以有自己的属性，包装对象在这种情况下没有 toString 方法。 因此它是从原理里继承的，即 Number.prototype。</p>
<p><code>注意有个微妙的地方，在上面的例子中的两个点不是一个错误。第一点是代表小数部分，第二个才是一个属性访问器：</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1.toString(); // 语法错误！  </div><div class="line">(1).toString(); // OK  </div><div class="line">1..toString(); // OK  </div><div class="line">1[&apos;toString&apos;](); // OK</div></pre></td></tr></table></figure>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>让我们展示如何为用户定义对象创建原型链，非常简单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">  alert(&apos;A.[[Call]] activated&apos;);</div><div class="line">  this.x = 10;</div><div class="line">&#125;</div><div class="line">A.prototype.y = 20;  </div><div class="line">var a = new A();</div><div class="line">alert([a.x, a.y]); // 10 (自身), 20 (继承)  </div><div class="line">function B() &#123;&#125;  </div><div class="line">// 最近的原型链方式就是设置对象的原型为另外一个新对象</div><div class="line">B.prototype = new A();  </div><div class="line">// 修复原型的constructor属性，否则的话是A了 </div><div class="line">B.prototype.constructor = B;  </div><div class="line">var b = new B();</div><div class="line">alert([b.x, b.y]); // 10, 20, 2个都是继承的  </div><div class="line">// [[Get]] b.x:</div><div class="line">// b.x (no) --&gt;</div><div class="line">// b.[[Prototype]].x (yes) - 10  </div><div class="line">// [[Get]] b.y</div><div class="line">// b.y (no) --&gt;</div><div class="line">// b.[[Prototype]].y (no) --&gt;</div><div class="line">// b.[[Prototype]].[[Prototype]].y (yes) - 20  </div><div class="line">// where b.[[Prototype]] === B.prototype,</div><div class="line">// and b.[[Prototype]].[[Prototype]] === A.prototype</div></pre></td></tr></table></figure>
<p>这种方法有两个特性：</p>
<p>首先，B.prototype 将包含 x 属性。乍一看这可能不对，你可能会想 x 属性是在 A 里定义的并且B构造函数也是这样期望的。尽管原型继承正常情况是没问题的，但 B 构造函数有时候可能不需要 x 属性，与基于 class 的继承相比，所有的属性都复制到后代子类里了。</p>
<p>尽管如此，如果有需要（模拟基于类的继承）将x属性赋给 B 构造函数创建的对象上，有一些方法，我们后来来展示其中一种方式。</p>
<p>其次，这不是一个特征而是缺点——子类原型创建的时候，构造函数的代码也执行了，我们可以看到消息”A.[[Call]] activated”显示了两次——当用A构造函数创建对象赋给 B.prototype 属性的时候，另外一场是 a 对象创建自身的时候！</p>
<p>下面的例子比较关键，在父类的构造函数抛出的异常：可能实际对象创建的时候需要检查吧，但很明显，同样的 case，也就是就是使用这些父对象作为原型的时候就会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function A(param) &#123;</div><div class="line">  if (!param) &#123;</div><div class="line">    throw &apos;Param required&apos;;</div><div class="line">  &#125;</div><div class="line">  this.param = param;</div><div class="line">&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">var a = new A(20);</div><div class="line">alert([a.x, a.param]); // 10, 20  </div><div class="line">function B() &#123;&#125;</div><div class="line">B.prototype = new A(); // Error</div></pre></td></tr></table></figure>
<p>此外，在父类的构造函数有太多代码的话也是一种缺点。</p>
<p>解决这些“功能”和问题，程序员使用原型链的标准模式（下面展示），主要目的就是在中间包装构造函数的创建，这些包装构造函数的链里包含需要的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function A() &#123;</div><div class="line">  alert(&apos;A.[[Call]] activated&apos;);</div><div class="line">  this.x = 10;</div><div class="line">&#125;</div><div class="line">A.prototype.y = 20;  </div><div class="line">var a = new A();</div><div class="line">alert([a.x, a.y]); // 10 (自身), 20 (集成)  </div><div class="line">function B() &#123;</div><div class="line">  // 或者使用A.apply(this, arguments)</div><div class="line">  B.superproto.constructor.apply(this, arguments);</div><div class="line">&#125;  </div><div class="line">// 继承：通过空的中间构造函数将原型连在一起</div><div class="line">var F = function () &#123;&#125;;</div><div class="line">F.prototype = A.prototype; // 引用</div><div class="line">B.prototype = new F();</div><div class="line">B.superproto = A.prototype; // 显示引用到另外一个原型上, &quot;sugar&quot;  </div><div class="line">// 修复原型的constructor属性，否则的就是A了</div><div class="line">B.prototype.constructor = B;  </div><div class="line">var b = new B();</div><div class="line">alert([b.x, b.y]); // 10 (自身), 20 (集成)</div></pre></td></tr></table></figure>
<p>注意，我们在 b 实例上创建了自己的x属性，通过 B.superproto.constructor 调用父构造函数来引用新创建对象的上下文。</p>
<p>我们也修复了父构造函数在创建子原型的时候不需要的调用，此时，消息”A.[[Call]] activated”在需要的时候才会显示。</p>
<p>为了在原型链里重复相同的行为（中间构造函数创建，设置 superproto，恢复原始构造函数），下面的模板可以封装成一个非常方面的工具函数，其目的是连接原型的时候不是根据构造函数的实际名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function inherit(child, parent) &#123;</div><div class="line">  var F = function () &#123;&#125;;</div><div class="line">  F.prototype = parent.prototype</div><div class="line">  child.prototype = new F();</div><div class="line">  child.prototype.constructor = child;</div><div class="line">  child.superproto = parent.prototype;</div><div class="line">  return child;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此，继承：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">function B() &#123;&#125;</div><div class="line">inherit(B, A); // 连接原型  </div><div class="line">var b = new B();</div><div class="line">alert(b.x); // 10, 在A.prototype查找到</div></pre></td></tr></table></figure>
<p>也有很多语法形式（包装而成），但所有的语法行都是为了减少上述代码里的行为。</p>
<p>例如，如果我们把中间的构造函数放到外面，就可以优化前面的代码（因此，只有一个函数被创建），然后重用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var inherit = (function()&#123;</div><div class="line">  function F() &#123;&#125;</div><div class="line">  return function (child, parent) &#123;</div><div class="line">    F.prototype = parent.prototype;</div><div class="line">    child.prototype = new F;</div><div class="line">    child.prototype.constructor = child;</div><div class="line">    child.superproto = parent.prototype;</div><div class="line">    return child;</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>由于对象的真实原型是[[Prototype]]属性，这意味着 F.prototype 可以很容易修改和重用，因为通过 new F 创建的 child.prototype 可以从 child.prototype 的当前值里获取[[Prototype]]：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function A() &#123;&#125;</div><div class="line">A.prototype.x = 10;  </div><div class="line">function B() &#123;&#125;</div><div class="line">inherit(B, A);  </div><div class="line">B.prototype.y = 20;  </div><div class="line">B.prototype.foo = function () &#123;</div><div class="line">  alert(&quot;B#foo&quot;);</div><div class="line">&#125;;  </div><div class="line">var b = new B();</div><div class="line">alert(b.x); // 10, 在A.prototype里查到  </div><div class="line">function C() &#123;&#125;</div><div class="line">inherit(C, B);  </div><div class="line">// 使用&quot;superproto&quot;语法糖</div><div class="line">// 调用父原型的同名方法  </div><div class="line">C.ptototype.foo = function () &#123;</div><div class="line">  C.superproto.foo.call(this);</div><div class="line">  alert(&quot;C#foo&quot;);</div><div class="line">&#125;;  </div><div class="line">var c = new C();</div><div class="line">alert([c.x, c.y]); // 10, 20  </div><div class="line">c.foo(); // B#foo, C#foo</div></pre></td></tr></table></figure>
<p>注意，ES5 为原型链标准化了这个工具函数，那就是 Object.create 方法。ES3 可以使用以下方式实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Object.create ||</div><div class="line">Object.create = function (parent, properties) &#123;</div><div class="line">  function F() &#123;&#125;</div><div class="line">  F.prototype = parent;</div><div class="line">  var child = new F;</div><div class="line">  for (var k in properties) &#123;</div><div class="line">    child[k] = properties[k].value;</div><div class="line">  &#125;</div><div class="line">  return child;</div><div class="line">&#125;  </div><div class="line">// 用法</div><div class="line">var foo = &#123;x: 10&#125;;</div><div class="line">var bar = Object.create(foo, &#123;y: &#123;value: 20&#125;&#125;);</div><div class="line">console.log(bar.x, bar.y); // 10, 20</div></pre></td></tr></table></figure>
<p>此外，所有模仿现在基于类的经典继承方式都是根据这个原则实现的，现在可以看到，它实际上不是基于类的继承，而是连接原型的一个很方便的代码重用。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>本章内容已经很充分和详细了，希望这些资料对你有用，并且消除你对 ECMAScript 的疑问，如果你有任何问题，请留言，我们一起讨论。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://bclary.com/2004/11/07/#a-4.2" target="_blank" rel="external">Language Overview</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-4.3" target="_blank" rel="external">Definitions</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-7.8.5" target="_blank" rel="external">Regular Expression Literals</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-8" target="_blank" rel="external">Types</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-9" target="_blank" rel="external">Type Conversion</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-11.1.4" target="_blank" rel="external">Array Initialiser</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-11.1.5" target="_blank" rel="external">Object Initialiser</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-11.2.2" target="_blank" rel="external">The new Operator</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-13.2.1" target="_blank" rel="external">[[Call]]</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-13.2.2" target="_blank" rel="external">[[Construct]]</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-15" target="_blank" rel="external">Native ECMAScript Objects</a>.</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/07/深入理解javascript/25设计模式之单例模式/"><span>设计模式之单例模式</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/07/深入理解javascript/25设计模式之单例模式/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-07T04:02:02.000Z">
          2016-03-07
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>从本章开始，我们会逐步介绍在 JavaScript 里使用的各种设计模式实现，在这里我不会过多地介绍模式本身的理论，而只会关注实现。OK，正式开始。</p>
<p>在传统开发工程师眼里，单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。在 JavaScript 里，单例作为一个命名空间提供者，从全局命名空间里提供一个唯一的访问点来访问该对象。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>在 JavaScript 里，实现单例的方式有很多种，其中最简单的一个方式是使用对象字面量的方法，其字面量里可以包含大量的属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var mySingleton = &#123;</div><div class="line">    property1: &quot;something&quot;,</div><div class="line">    property2: &quot;something else&quot;,</div><div class="line">    method1: function () &#123;</div><div class="line">        console.log(&apos;hello world&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如果以后要扩展该对象，你可以添加自己的私有成员和方法，然后使用闭包在其内部封装这些变量和函数声明。只暴露你想暴露的 public 成员和方法，样例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var mySingleton = function () &#123;</div><div class="line">    /* 这里声明私有变量和方法 */</div><div class="line">    var privateVariable = &apos;something private&apos;;</div><div class="line">    function showPrivate() &#123;</div><div class="line">        console.log(privateVariable);</div><div class="line">    &#125;</div><div class="line">    /* 公有变量和方法（可以访问私有变量和方法） */</div><div class="line">    return &#123;</div><div class="line">        publicMethod: function () &#123;</div><div class="line">            showPrivate();</div><div class="line">        &#125;,</div><div class="line">        publicVar: &apos;the public can see this!&apos;</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line">var single = mySingleton();</div><div class="line">single.publicMethod();  // 输出 &apos;something private&apos;</div><div class="line">console.log(single.publicVar); // 输出 &apos;the public can see this!&apos;</div></pre></td></tr></table></figure>
<p>上面的代码很不错了，但如果我们想做到只有在使用的时候才初始化，那该如何做呢？为了节约资源的目的，我们可以另外一个构造函数里来初始化这些代码，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var Singleton = (function () &#123;</div><div class="line">    var instantiated;</div><div class="line">    function init() &#123;</div><div class="line">        /*这里定义单例代码*/</div><div class="line">        return &#123;</div><div class="line">            publicMethod: function () &#123;</div><div class="line">                console.log(&apos;hello world&apos;);</div><div class="line">            &#125;,</div><div class="line">            publicProperty: &apos;test&apos;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    return &#123;</div><div class="line">        getInstance: function () &#123;</div><div class="line">            if (!instantiated) &#123;</div><div class="line">                instantiated = init();</div><div class="line">            &#125;</div><div class="line">            return instantiated;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;)();</div><div class="line">/*调用公有的方法来获取实例:*/</div><div class="line">Singleton.getInstance().publicMethod();</div></pre></td></tr></table></figure>
<p>知道了单例如何实现了，但单例用在什么样的场景比较好呢？其实单例一般是用在系统间各种模式的通信协调上，下面的代码是一个单例的最佳实践：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">var SingletonTester = (function () &#123;</div><div class="line">    //参数：传递给单例的一个参数集合</div><div class="line">    function Singleton(args) &#123;</div><div class="line">        //设置args变量为接收的参数或者为空（如果没有提供的话）</div><div class="line">        var args = args || &#123;&#125;;</div><div class="line">        //设置name参数</div><div class="line">        this.name = &apos;SingletonTester&apos;;</div><div class="line">        //设置pointX的值</div><div class="line">        this.pointX = args.pointX || 6; //从接收的参数里获取，或者设置为默认值</div><div class="line">        //设置pointY的值</div><div class="line">        this.pointY = args.pointY || 10;</div><div class="line">    &#125;</div><div class="line">    //实例容器</div><div class="line">    var instance;</div><div class="line">    var _static = &#123;</div><div class="line">        name: &apos;SingletonTester&apos;,</div><div class="line">        //获取实例的方法</div><div class="line">        //返回Singleton的实例</div><div class="line">        getInstance: function (args) &#123;</div><div class="line">            if (instance === undefined) &#123;</div><div class="line">                instance = new Singleton(args);</div><div class="line">            &#125;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    return _static;</div><div class="line">&#125;)();</div><div class="line">var singletonTest = SingletonTester.getInstance(&#123; pointX: 5 &#125;);</div><div class="line">console.log(singletonTest.pointX); // 输出 5</div></pre></td></tr></table></figure>
<h2 id="其它实现方式"><a href="#其它实现方式" class="headerlink" title="其它实现方式"></a>其它实现方式</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">    // 判断是否存在实例</div><div class="line">    if (typeof Universe.instance === &apos;object&apos;) &#123;</div><div class="line">        return Universe.instance;</div><div class="line">    &#125;</div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line">    // 缓存</div><div class="line">    Universe.instance = this;</div><div class="line">    // 隐式返回this</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div></pre></td></tr></table></figure>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">    // 缓存的实例</div><div class="line">    var instance = this;</div><div class="line">    // 其它内容</div><div class="line">    this.start_time = 0;</div><div class="line">    this.bang = &quot;Big&quot;;</div><div class="line">    // 重写构造函数</div><div class="line">    Universe = function () &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">uni.bang = &quot;123&quot;;</div><div class="line">console.log(uni === uni2); // true</div><div class="line">console.log(uni2.bang); // 123</div></pre></td></tr></table></figure>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法 3"></a>方法 3</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">function Universe() &#123;</div><div class="line">    // 缓存实例</div><div class="line">    var instance;</div><div class="line">    // 重新构造函数</div><div class="line">    Universe = function Universe() &#123;</div><div class="line">        return instance;</div><div class="line">    &#125;;</div><div class="line">    // 后期处理原型属性</div><div class="line">    Universe.prototype = this;</div><div class="line">    // 实例</div><div class="line">    instance = new Universe();</div><div class="line">    // 重设构造函数指针</div><div class="line">    instance.constructor = Universe;</div><div class="line">    // 其它功能</div><div class="line">    instance.start_time = 0;</div><div class="line">    instance.bang = &quot;Big&quot;;</div><div class="line">    return instance;</div><div class="line">&#125;</div><div class="line">// 测试</div><div class="line">var uni = new Universe();</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni === uni2); // true</div><div class="line">// 添加原型属性</div><div class="line">Universe.prototype.nothing = true;</div><div class="line">var uni = new Universe();</div><div class="line">Universe.prototype.everything = true;</div><div class="line">var uni2 = new Universe();</div><div class="line">console.log(uni.nothing); // true</div><div class="line">console.log(uni2.nothing); // true</div><div class="line">console.log(uni.everything); // true</div><div class="line">console.log(uni2.everything); // true</div><div class="line">console.log(uni.constructor === Universe); // true</div></pre></td></tr></table></figure>
<h3 id="方式-4"><a href="#方式-4" class="headerlink" title="方式 4"></a>方式 4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var Universe;</div><div class="line">(function () &#123;</div><div class="line">    var instance;</div><div class="line">    Universe = function Universe() &#123;</div><div class="line">        if (instance) &#123;</div><div class="line">            return instance;</div><div class="line">        &#125;</div><div class="line">        instance = this;</div><div class="line">        // 其它内容</div><div class="line">        this.start_time = 0;</div><div class="line">        this.bang = &quot;Big&quot;;</div><div class="line">    &#125;;</div><div class="line">&#125; ());</div><div class="line">//测试代码</div><div class="line">var a = new Universe();</div><div class="line">var b = new Universe();</div><div class="line">alert(a === b); // true</div><div class="line">a.bang = &quot;123&quot;;</div><div class="line">alert(b.bang); // 123</div></pre></td></tr></table></figure>
      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/03/01/深入理解javascript/16闭包（Closures)/"><span>闭包（Closures)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/03/01/深入理解javascript/16闭包（Closures)/" rel="bookmark">
        <time class="entry-date published" datetime="2016-03-01T00:23:02.000Z">
          2016-03-01
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章我们将介绍在 JavaScript 里大家经常来讨论的话题 —— 闭包（closure）。闭包其实大家都已经谈烂了。尽管如此，这里还是要试着从理论角度来讨论下闭包，看看 ECMAScript 中的闭包内部究竟是如何工作的。</p>
<p>正如在前面的文章中提到的，这些文章都是系列文章，相互之间都是有关联的。因此，为了更好的理解本文要介绍的内容，建议先去阅读第 14 章作用域链和第 12 章变量对象。</p>
<h2 id="概论"><a href="#概论" class="headerlink" title="概论"></a>概论</h2><p>在直接讨论 ECMAScript 闭包之前，还是有必要来看一下函数式编程中一些基本定义。</p>
<p>众所周知，在函数式语言中（ECMAScript也支持这种风格），函数即是数据。就比方说，函数可以赋值给变量，可以当参数传递给其他函数，还可以从函数里返回等等。这类函数有特殊的名字和结构。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote>
<p>A functional argument (“Funarg”) — is an argument which value is a function.<br>函数式参数（“Funarg”） —— 是指值为函数的参数。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function exampleFunc(funArg) &#123;</div><div class="line">  funArg();</div><div class="line">&#125;</div><div class="line">exampleFunc(function () &#123;</div><div class="line">  alert(&apos;funArg&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上述例子中 funarg 的实际参数其实是传递给 exampleFunc 的匿名函数。</p>
<p>反过来，接受函数式参数的函数称为高阶函数（high-order function 简称：HOF）。还可以称作：函数式函数或者偏数理或操作符。上述例子中，exampleFunc 就是这样的函数。</p>
<p>此前提到的，函数不仅可以作为参数，还可以作为返回值。这类以函数为返回值的函数称为带函数值的函数（functions with functional value or function valued functions）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function functionValued() &#123;</div><div class="line">  return function () &#123;</div><div class="line">    alert(&apos;returned function is called&apos;);</div><div class="line">  &#125;;</div><div class="line">&#125;)()();</div></pre></td></tr></table></figure>
<p>可以以正常数据形式存在的函数（比方说：当参数传递，接受函数式参数或者以函数值返回）都称作 第一类函数（一般说第一类对象）。在 ECMAScript 中，所有的函数都是第一类对象。</p>
<p><em>函数可以作为正常数据存在（例如：当参数传递，接受函数式参数或者以函数值返回）都称作第一类函数（一般说第一类对象）。</em></p>
<p>在 ECMAScript 中，所有的函数都是第一类对象。</p>
<p>接受自己作为参数的函数，称为自应用函数（auto-applicative function 或者 self-applicative function）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function selfApplicative(funArg) &#123;</div><div class="line">  if (funArg &amp;&amp; funArg === selfApplicative) &#123;</div><div class="line">    alert(&apos;self-applicative&apos;);</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  selfApplicative(selfApplicative);</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>以自己为返回值的函数称为自复制函数（auto-replicative function 或者 self-replicative function）。通常，“自复制”这个词用在文学作品中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function selfReplicative() &#123;</div><div class="line">  return selfReplicative;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>自复制函数的其中一个比较有意思的模式是让仅接受集合的一个项作为参数来接受从而代替接受集合本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 接受集合的函数</div><div class="line">function registerModes(modes) &#123;</div><div class="line">  modes.forEach(registerMode, modes);</div><div class="line">&#125;</div><div class="line">// 用法</div><div class="line">registerModes([&apos;roster&apos;, &apos;accounts&apos;, &apos;groups&apos;]);</div><div class="line">// 自复制函数的声明</div><div class="line">function modes(mode) &#123;</div><div class="line">  registerMode(mode); // 注册一个mode</div><div class="line">  return modes; // 返回函数自身</div><div class="line">&#125;</div><div class="line">// 用法，modes链式调用</div><div class="line">modes(&apos;roster&apos;)(&apos;accounts&apos;)(&apos;groups&apos;)</div><div class="line">//有点类似：jQueryObject.addClass(&quot;a&quot;).toggle().removClass(&quot;b&quot;)</div></pre></td></tr></table></figure>
<p>但直接传集合用起来相对来说，比较有效并且直观。</p>
<p>在函数式参数中定义的变量，在“funarg”激活时就能够访问了（因为存储上下文数据的变量对象每次在进入上下文的时候就创建出来了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function testFn(funArg) &#123;</div><div class="line">  // funarg激活时, 局部变量localVar可以访问了</div><div class="line">  funArg(10); // 20</div><div class="line">  funArg(20); // 30</div><div class="line">&#125;</div><div class="line">testFn(function (arg) &#123;</div><div class="line">  var localVar = 10;</div><div class="line">  alert(arg + localVar);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>然而，我们从第 14 章知道，在 ECMAScript 中，函数是可以封装在父函数中的，并可以使用父函数上下文的变量。这个特性会引发 funarg 问题。</p>
<h3 id="Funarg-问题"><a href="#Funarg-问题" class="headerlink" title="Funarg 问题"></a>Funarg 问题</h3><p>在<a href="https://en.wikipedia.org/wiki/Stack-oriented_programming_language" target="_blank" rel="external">面向堆栈的编程语言</a>中，函数的局部变量都是保存在栈上的，每当函数激活的时候，这些变量和函数参数都会压入到该堆栈上。</p>
<p>当函数返回的时候，这些参数又会从栈中移除。这种模型对将函数作为函数式值使用的时候有很大的限制（比方说，作为返回值从父函数中返回）。绝大部分情况下，问题会出现在当函数有自由变量的时候。</p>
<p><em>自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</em></p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function testFn() &#123;</div><div class="line">  var localVar = 10;</div><div class="line">  function innerFn(innerParam) &#123;</div><div class="line">    alert(innerParam + localVar);</div><div class="line">  &#125;</div><div class="line">  return innerFn;</div><div class="line">&#125;</div><div class="line">var someFn = testFn();</div><div class="line">someFn(20); // 30</div></pre></td></tr></table></figure>
<p>上述例子中，对于 innerFn 函数来说，localVar 就属于自由变量。</p>
<p>对于采用面向栈模型来存储局部变量的系统而言，就意味着当 testFn 函数调用结束后，其局部变量都会从堆栈中移除。这样一来，当从外部对 innerFn 进行函数调用的时候，就会发生错误（因为 localVar 变量已经不存在了）。</p>
<p>而且，上述例子在面向栈实现模型中，要想将 innerFn 以返回值返回根本是不可能的。因为它也是 testFn 函数的局部变量，也会随着 testFn 的返回而移除。</p>
<p>还有一个问题是当系统采用动态作用域，函数作为函数参数使用的时候有关。</p>
<p>看如下例子（伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var z = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(z);</div><div class="line">&#125;</div><div class="line">foo(); // 10 – 使用静态和动态作用域的时候</div><div class="line">(function () &#123;</div><div class="line">  var z = 20;</div><div class="line">  foo(); // 10 – 使用静态作用域, 20 – 使用动态作用域</div><div class="line">&#125;)();</div><div class="line">// 将foo作为参数的时候是一样的</div><div class="line">(function (funArg) &#123;</div><div class="line">  var z = 30;</div><div class="line">  funArg(); // 10 – 静态作用域, 30 – 动态作用域</div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure>
<p>我们看到，采用动态作用域，变量（标识符）的系统是通过变量动态栈来管理的。因此，自由变量是在当前活跃的动态链中查询的，而不是在函数创建的时候保存起来的静态作用域链中查询的。</p>
<p>这样就会产生冲突。比方说，即使Z仍然存在（与之前从栈中移除变量的例子相反），还是会有这样一个问题： 在不同的函数调用中，Z 的值到底取哪个呢（从哪个上下文，哪个作用域中查询）？</p>
<p>上述描述的就是两类 funarg 问题 —— 取决于是否将函数以返回值返回（第一类问题）以及是否将函数当函数参数使用（第二类问题）。</p>
<p>为了解决上述问题，就引入了 闭包的概念。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>闭包是代码块和创建该代码块的上下文中数据的结合。</p>
</blockquote>
<p>让我们来看下面这个例子（伪代码）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 20;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x); // 自由变量&quot;x&quot; == 20</div><div class="line">&#125;</div><div class="line">// 为foo闭包</div><div class="line">fooClosure = &#123;</div><div class="line">  call: foo // 引用到function</div><div class="line">  lexicalEnvironment: &#123;x: 20&#125; // 搜索上下文的上下文</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上述例子中，“fooClosure”部分是伪代码。对应的，在 ECMAScript 中，“foo”函数已经有了一个内部属性——创建该函数上下文的作用域链。</p>
<p>“lexical”通常是省略的。上述例子中是为了强调在闭包创建的同时，上下文的数据就会保存起来。当下次调用该函数的时候，自由变量就可以在保存的（闭包）上下文中找到了，正如上述代码所示，变量“z”的值总是 10。</p>
<p>定义中我们使用的比较广义的词 —— “代码块”，然而，通常（在 ECMAScript 中）会使用我们经常用到的函数。当然了，并不是所有对闭包的实现都会将闭包和函数绑在一起，比方说，在 Ruby 语言中，闭包就有可能是： 一个过程对象（procedure object），一个 lambda 表达式或者是代码块。</p>
<p>对于要实现将局部变量在上下文销毁后仍然保存下来，基于栈的实现显然是不适用的（因为与基于栈的结构相矛盾）。因此在这种情况下，上层作用域的闭包数据是通过 动态分配内存的方式来实现的（基于“堆”的实现），配合使用垃圾回收器（garbage collector 简称 GC）和 引用计数（reference counting）。这种实现方式比基于栈的实现性能要低，然而，任何一种实现总是可以优化的： 可以分析函数是否使用了自由变量，函数式参数或者函数式值，然后根据情况来决定 —— 是将数据存放在堆栈中还是堆中。</p>
<h2 id="ECMAScript闭包的实现"><a href="#ECMAScript闭包的实现" class="headerlink" title="ECMAScript闭包的实现"></a>ECMAScript闭包的实现</h2><p>讨论完理论部分，接下来让我们来介绍下 ECMAScript 中闭包究竟是如何实现的。这里还是有必要再次强调下：ECMAScript 只使用静态（词法）作用域（而诸如 Perl 这样的语言，既可以使用静态作用域也可以使用动态作用域进行变量声明）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">(function (funArg) &#123;</div><div class="line">  var x = 20;</div><div class="line">  // 变量&quot;x&quot;在(lexical)上下文中静态保存的，在该函数创建的时候就保存了</div><div class="line">  funArg(); // 10, 而不是20</div><div class="line">&#125;)(foo);</div></pre></td></tr></table></figure>
<p>技术上说，创建该函数的父级上下文的数据是保存在函数的内部属性 [[Scope]]中的。如果你还不了解什么是[[Scope]]，建议你先阅读第 14 章, 该章节对[[Scope]]作了非常详细的介绍。如果你对[[Scope]]和作用域链的知识完全理解了的话，那对闭包也就完全理解了。</p>
<p>根据函数创建的算法，我们看到在 ECMAScript 中，所有的函数都是闭包，因为它们都是在创建的时候就保存了上层上下文的作用域链（除开异常的情况） （不管这个函数后续是否会激活 —— [[Scope]]在函数创建的时候就有了）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">// foo是闭包</div><div class="line">foo: &lt;FunctionObject&gt; = &#123;</div><div class="line">  [[Call]]: &lt;code block of foo&gt;,</div><div class="line">  [[Scope]]: [</div><div class="line">    global: &#123;</div><div class="line">      x: 10</div><div class="line">    &#125;</div><div class="line">  ],</div><div class="line">  ... // 其它属性</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>如我们所说，为了优化目的，当一个函数没有使用自由变量的话，实现可能不保存在副作用域链里。不过，在 ECMA-262-3 规范里任何都没说。因此，正常来说，所有的参数都是在创建阶段保存在[[Scope]]属性里的。</p>
<p>有些实现中，允许对闭包作用域直接进行访问。比如 Rhino，针对函数的[[Scope]]属性，对应有一个非标准的<strong>parent</strong>属性，在第 12 章中作过介绍：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var global = this;</div><div class="line">var x = 10;</div><div class="line">var foo = (function () &#123;</div><div class="line">  var y = 20;</div><div class="line">  return function () &#123;</div><div class="line">    alert(y);</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line">foo(); // 20</div><div class="line">alert(foo.__parent__.y); // 20</div><div class="line">foo.__parent__.y = 30;</div><div class="line">foo(); // 30</div><div class="line">// 可以通过作用域链移动到顶部</div><div class="line">alert(foo.__parent__.__parent__ === global); // true</div><div class="line">alert(foo.__parent__.__parent__.x); // 10</div></pre></td></tr></table></figure>
<h2 id="所有对象都引用一个-Scope"><a href="#所有对象都引用一个-Scope" class="headerlink" title="所有对象都引用一个[[Scope]]"></a>所有对象都引用一个[[Scope]]</h2><p>这里还要注意的是：在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个[[Scope]]属性的。也就是说，某个闭包对其中[[Scope]]的变量做修改会影响到其他闭包对其变量的读取：</p>
<p><em>这就是说：所有的内部函数都共享同一个父作用域</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var firstClosure;</div><div class="line">var secondClosure;</div><div class="line">function foo() &#123;</div><div class="line">  var x = 1;</div><div class="line">  firstClosure = function () &#123; return ++x; &#125;;</div><div class="line">  secondClosure = function () &#123; return --x; &#125;;</div><div class="line">  x = 2; // 影响 AO[&quot;x&quot;], 在2个闭包公有的[[Scope]]中</div><div class="line">  alert(firstClosure()); // 3, 通过第一个闭包的[[Scope]]</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line">alert(firstClosure()); // 4</div><div class="line">alert(secondClosure()); // 3</div></pre></td></tr></table></figure>
<p>关于这个功能有一个非常普遍的错误认识，开发人员在循环语句里创建函数（内部进行计数）的时候经常得不到预期的结果，而期望是每个函数都有自己的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = function () &#123;</div><div class="line">    alert(k);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">data[0](); // 3, 而不是0</div><div class="line">data[1](); // 3, 而不是1</div><div class="line">data[2](); // 3, 而不是2</div></pre></td></tr></table></figure>
<p>上述例子就证明了 —— 同一个上下文中创建的闭包是共用一个[[Scope]]属性的。因此上层上下文中的变量“k”是可以很容易就被改变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">activeContext.Scope = [</div><div class="line">  ... // 其它变量对象</div><div class="line">  &#123;data: [...], k: 3&#125; // 活动对象</div><div class="line">];</div><div class="line">data[0].[[Scope]] === Scope;</div><div class="line">data[1].[[Scope]] === Scope;</div><div class="line">data[2].[[Scope]] === Scope;</div></pre></td></tr></table></figure>
<p>这样一来，在函数激活的时候，最终使用到的k就已经变成了 3 了。如下所示，创建一个闭包就可以解决这个问题了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  data[k] = (function _helper(x) &#123;</div><div class="line">    return function () &#123;</div><div class="line">      alert(x);</div><div class="line">    &#125;;</div><div class="line">  &#125;)(k); // 传入&quot;k&quot;值</div><div class="line">&#125;</div><div class="line">// 现在结果是正确的了</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<p>让我们来看看上述代码都发生了什么？函数“_helper”创建出来之后，通过传入参数“k”激活。其返回值也是个函数，该函数保存在对应的数组元素中。这种技术产生了如下效果： 在函数激活时，每次“_helper”都会创建一个新的变量对象，其中含有参数“x”，“x”的值就是传递进来的“k”的值。这样一来，返回的函数的[[Scope]]就成了如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">data[0].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 0&#125;</div><div class="line">];</div><div class="line">data[1].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 1&#125;</div><div class="line">];</div><div class="line">data[2].[[Scope]] === [</div><div class="line">  ... // 其它变量对象</div><div class="line">  父级上下文中的活动对象AO: &#123;data: [...], k: 3&#125;,</div><div class="line">  _helper上下文中的活动对象AO: &#123;x: 2&#125;</div><div class="line">];</div></pre></td></tr></table></figure>
<p>我们看到，这时函数的[[Scope]]属性就有了真正想要的值了，为了达到这样的目的，我们不得不在[[Scope]]中创建额外的变量对象。要注意的是，在返回的函数中，如果要获取“k”的值，那么该值还是会是 3。</p>
<p>顺便提下，大量介绍 JavaScript 的文章都认为只有额外创建的函数才是闭包，这种说法是错误的。实践得出，这种方式是最有效的，然而，从理论角度来说，在 ECMAScript 中所有的函数都是闭包。</p>
<p>然而，上述提到的方法并不是唯一的方法。通过其他方式也可以获得正确的“k”的值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var data = [];</div><div class="line">for (var k = 0; k &lt; 3; k++) &#123;</div><div class="line">  (data[k] = function () &#123;</div><div class="line">    alert(arguments.callee.x);</div><div class="line">  &#125;).x = k; // 将k作为函数的一个属性</div><div class="line">&#125;</div><div class="line">// 结果也是对的</div><div class="line">data[0](); // 0</div><div class="line">data[1](); // 1</div><div class="line">data[2](); // 2</div></pre></td></tr></table></figure>
<h2 id="Funarg-和-return"><a href="#Funarg-和-return" class="headerlink" title="Funarg 和 return"></a>Funarg 和 return</h2><p>另外一个特性是从闭包中返回。在 ECMAScript 中，闭包中的返回语句会将控制流返回给调用上下文（调用者）。而在其他语言中，比如，Ruby，有很多中形式的闭包，相应的处理闭包返回也都不同，下面几种方式都是可能的：可能直接返回给调用者，或者在某些情况下——直接从上下文退出。</p>
<p>ECMAScript 标准的退出行为如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getElement() &#123;</div><div class="line">  [1, 2, 3].forEach(function (element) &#123;</div><div class="line">    if (element % 2 == 0) &#123;</div><div class="line">      // 返回给函数&quot;forEach&quot;函数</div><div class="line">      // 而不是返回给getElement函数</div><div class="line">      alert(&apos;found: &apos; + element); // found: 2</div><div class="line">      return element;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">  return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，在 ECMAScript 中通过 try catch 可以实现如下效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var $break = &#123;&#125;;</div><div class="line">function getElement() &#123;</div><div class="line">  try &#123;</div><div class="line">    [1, 2, 3].forEach(function (element) &#123;</div><div class="line">      if (element % 2 == 0) &#123;</div><div class="line">        // // 从getElement中&quot;返回&quot;</div><div class="line">        alert(&apos;found: &apos; + element); // found: 2</div><div class="line">        $break.data = element;</div><div class="line">        throw $break;</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  &#125; catch (e) &#123;</div><div class="line">    if (e == $break) &#123;</div><div class="line">      return $break.data;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  return null;</div><div class="line">&#125;</div><div class="line">alert(getElement()); // 2</div></pre></td></tr></table></figure>
<h3 id="理论版本"><a href="#理论版本" class="headerlink" title="理论版本"></a>理论版本</h3><p>这里说明一下，开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，甚至理解成只有匿名函数才能是闭包。</p>
<p>再说一下，因为作用域链，使得所有的函数都是闭包（与函数类型无关： 匿名函数，FE，NFE，FD 都是闭包）。 这里只有一类函数除外，那就是通过 Function 构造器创建的函数，因为其[[Scope]]只包含全局对象。</p>
<p>为了更好的澄清该问题，我们对 ECMAScript 中的闭包给出 2 个正确的版本定义：</p>
<p>ECMAScript 中，闭包指的是：</p>
<ol>
<li>从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</li>
<li>从实践角度：以下函数才算是闭包：<ol>
<li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h2 id="闭包用法实战"><a href="#闭包用法实战" class="headerlink" title="闭包用法实战"></a>闭包用法实战</h2><p>实际使用的时候，闭包可以创建出非常优雅的设计，允许对 funarg 上定义的多种计算方式进行定制。如下就是数组排序的例子，它接受一个排序条件函数作为参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].sort(function (a, b) &#123;</div><div class="line">  ... // 排序条件</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>同样的例子还有，数组的 map 方法是根据函数中定义的条件将原数组映射到一个新的数组中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].map(function (element) &#123;</div><div class="line">  return element * 2;</div><div class="line">&#125;); // [2, 4, 6]</div></pre></td></tr></table></figure>
<p>使用函数式参数，可以很方便的实现一个搜索方法，并且可以支持无限制的搜索条件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">someCollection.find(function (element) &#123;</div><div class="line">  return element.someProperty == &apos;searchCondition&apos;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>还有应用函数，比如常见的 forEach 方法，将函数应用到每个数组元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[1, 2, 3].forEach(function (element) &#123;</div><div class="line">  if (element % 2 != 0) &#123;</div><div class="line">    alert(element);</div><div class="line">  &#125;</div><div class="line">&#125;); // 1, 3</div></pre></td></tr></table></figure>
<p>顺便提下，函数对象的 apply 和 call 方法，在函数式编程中也可以用作应用函数。 apply 和 call 已经在讨论“this”的时候介绍过了；这里，我们将它们看作是应用函数 —— 应用到参数中的函数（在 apply 中是参数列表，在 call 中是独立的参数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  alert([].join.call(arguments, &apos;;&apos;)); // 1;2;3</div><div class="line">&#125;).apply(this, [1, 2, 3]);</div></pre></td></tr></table></figure>
<p>闭包还有另外一个非常重要的应用 —— 延迟调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = 10;</div><div class="line">setTimeout(function () &#123;</div><div class="line">  alert(a); // 10, after one second</div><div class="line">&#125;, 1000);</div></pre></td></tr></table></figure>
<p>还有回调函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//...</div><div class="line">var x = 10;</div><div class="line">// only for example</div><div class="line">xmlHttpRequestObject.onreadystatechange = function () &#123;</div><div class="line">  // 当数据就绪的时候，才会调用;</div><div class="line">  // 这里，不论是在哪个上下文中创建</div><div class="line">  // 此时变量“x”的值已经存在了</div><div class="line">  alert(x); // 10</div><div class="line">&#125;;</div><div class="line">//...</div></pre></td></tr></table></figure>
<p>还可以创建封装的作用域来隐藏辅助对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;&#125;;</div><div class="line">// 初始化</div><div class="line">(function (object) &#123;</div><div class="line">  var x = 10;</div><div class="line">  object.getX = function _getX() &#123;</div><div class="line">    return x;</div><div class="line">  &#125;;</div><div class="line">&#125;)(foo);</div><div class="line">alert(foo.getX()); // 获得闭包 &quot;x&quot; – 10</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了更多关于 ECMAScript-262-3 的理论知识，而我认为，这些基础的理论有助于理解 ECMAScript 中闭包的概念。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://jibbering.com/faq/notes/closures/" target="_blank" rel="external">Javascript Closures (by Richard Cornford)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Funarg_problem" target="_blank" rel="external">Funarg problem</a></li>
<li><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming" target="_blank" rel="external">Closures</a>)</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/02/25/深入理解javascript/15函数（Functions）/"><span>函数（Functions）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/25/深入理解javascript/15函数（Functions）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-25T09:42:02.000Z">
          2016-02-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章节我们要着重介绍的是一个非常常见的 ECMAScript 对象——函数（function),我们将详细讲解一下各种类型的函数是如何影响上下文的变量对象以及每个函数的作用域链都包含什么，以及回答诸如像下面这样的问题：下面声明的函数有什么区别么？（如果有，区别是什么）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo = function () &#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>平时的惯用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者，下面的函数为什么要用括号括住？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  ...</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>关于具体的介绍，早前面的 12 章变量对象和 14 章作用域链都有介绍，如果需要详细了解这些内容，请查询上述 2 个章节的详细内容。</p>
<p>但我们依然要一个一个分别看看，首先从函数的类型讲起：</p>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>在 ECMAScript 中有三种函数类型：函数声明，函数表达式和函数构造器创建的函数。每一种都有自己的特点。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p><code>函数声明（缩写为 FD）是这样一种函数：</code></p>
<ol>
<li>有一个特定的名称</li>
<li>在源码中的位置：要么处于程序级（Program level），要么处于其它函数的主体（FunctionBody）中</li>
<li>在进入上下文阶段创建</li>
<li>影响变量对象</li>
<li>以下面的方式声明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function exampleFunc() &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种函数类型的主要特点在于它们仅仅影响变量对象（即存储在上下文的 VO 中的变量对象）。该特点也解释了第二个重要点（它是变量对象特性的结果）——在代码执行阶段它们已经可用（因为 FD 在进入上下文阶段已经存在于 VO 中——代码执行之前）。</p>
<p>例如（函数在其声明之前被调用）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">foo();</div><div class="line">function foo() &#123;</div><div class="line">  alert(&apos;foo&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一个重点知识点是上述定义中的第二点——函数声明在源码中的位置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 函数可以在如下地方声明：</div><div class="line">// 1) 直接在全局上下文中</div><div class="line">function globalFD() &#123;</div><div class="line">  // 2) 或者在一个函数的函数体内</div><div class="line">  function innerFD() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只有这 2 个位置可以声明函数，也就是说:不可能在表达式位置或一个代码块中定义它。</p>
<p>另外一种可以取代函数声明的方式是函数表达式，解释如下：</p>
<h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p><code>函数表达式（缩写为FE）是这样一种函数：</code></p>
<ol>
<li>在源码中须出现在表达式的位置</li>
<li>有可选的名称</li>
<li>不会影响变量对象</li>
<li>在代码执行阶段创建</li>
</ol>
<p>这种函数类型的主要特点在于它在源码中总是处在表达式的位置。最简单的一个例子就是一个赋值声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo = function () &#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>该例演示是让一个匿名函数表达式赋值给变量 foo，然后该函数可以用 foo这个名称进行访问——foo()。</p>
<p>同时和定义里描述的一样，函数表达式也可以拥有可选的名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var foo = function _foo() &#123;</div><div class="line">  ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>需要注意的是，在外部FE通过变量“foo”来访问——foo()，而在函数内部（如递归调用），有可能使用名称“_foo”。</p>
<p>如果 FE 有一个名称，就很难与 FD 区分。但是，如果你明白定义，区分起来就简单明了：FE 总是处在表达式的位置。在下面的例子中我们可以看到各种 ECMAScript 表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 圆括号（分组操作符）内只能是表达式</div><div class="line">(function foo() &#123;&#125;);</div><div class="line">// 在数组初始化器内只能是表达式</div><div class="line">[function bar() &#123;&#125;];</div><div class="line">// 逗号也只能操作表达式</div><div class="line">1, function baz() &#123;&#125;;</div></pre></td></tr></table></figure>
<p>表达式定义里说明：FE 只能在代码执行阶段创建而且不存在于变量对象中，让我们来看一个示例行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// FE在定义阶段之前不可用（因为它是在代码执行阶段创建）</div><div class="line">alert(foo); // &quot;foo&quot; 未定义</div><div class="line">(function foo() &#123;&#125;);</div><div class="line">// 定义阶段之后也不可用，因为他不在变量对象VO中</div><div class="line">alert(foo);  // &quot;foo&quot; 未定义</div></pre></td></tr></table></figure>
<p>相当一部分问题出现了，我们为什么需要函数表达式？答案很明显——在表达式中使用它们，”不会污染”变量对象。最简单的例子是将一个函数作为参数传递给其它函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function foo(callback) &#123;</div><div class="line">  callback();</div><div class="line">&#125;</div><div class="line">foo(function bar() &#123;</div><div class="line">  alert(&apos;foo.bar&apos;);</div><div class="line">&#125;);</div><div class="line">foo(function baz() &#123;</div><div class="line">  alert(&apos;foo.baz&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上述例子里，FE 赋值给了一个变量（也就是参数），函数将该表达式保存在内存中，并通过变量名来访问（因为变量影响变量对象)，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var foo = function () &#123;</div><div class="line">  alert(&apos;foo&apos;);</div><div class="line">&#125;;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>另外一个例子是创建封装的闭包从外部上下文中隐藏辅助性数据（在下面的例子中我们使用 FE，它在创建后立即调用）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;&#125;;</div><div class="line">(function initialize() &#123;</div><div class="line">  var x = 10;</div><div class="line">  foo.bar = function () &#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;;</div><div class="line">&#125;)();</div><div class="line">foo.bar(); // 10;</div><div class="line">alert(x); // &quot;x&quot; 未定义</div></pre></td></tr></table></figure>
<p>我们看到函数 foo.bar（通过[[Scope]]属性）访问到函数 initialize 的内部变量“x”。同时，“x”在外部不能直接访问。在许多库中，这种策略常用来创建”私有”数据和隐藏辅助实体。在这种模式中，初始化的FE的名称通常被忽略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">   // 初始化作用域 </div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>还有一个例子是：在代码执行阶段通过条件语句进行创建 FE，不会污染变量对象 VO。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var foo = 10;</div><div class="line">var bar = (foo % 2 == 0</div><div class="line">  ? function () &#123; alert(0); &#125;</div><div class="line">  : function () &#123; alert(1); &#125;</div><div class="line">);</div><div class="line">bar(); // 0</div></pre></td></tr></table></figure>
<p>关于圆括号的问题</p>
<p>让我们回头并回答在文章开头提到的问题——”为何在函数创建后的立即调用中必须用圆括号来包围它？”，答案就是：表达式句子的限制就是这样的。</p>
<p>按照标准，表达式语句不能以一个大括号{开始是因为他很难与代码块区分，同样，他也不能以函数关键字开始，因为很难与函数声明进行区分。即，所以，如果我们定义一个立即执行的函数，在其创建后立即按以下方式调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function () &#123;</div><div class="line">  ...</div><div class="line">&#125;();</div><div class="line">// 即便有名称</div><div class="line">function foo() &#123;</div><div class="line">  ...</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>我们使用了函数声明，上述 2 个定义，解释器在解释的时候都会报错，但是可能有多种原因。</p>
<p>如果在全局代码里定义（也就是程序级别），解释器会将它看做是函数声明，因为他是以 function 关键字开头，第一个例子，我们会得到 SyntaxError 错误，是因为函数声明没有名字（我们前面提到了函数声明必须有名字）。</p>
<p>第二个例子，我们有一个名称为 foo 的一个函数声明正常创建，但是我们依然得到了一个语法错误——没有任何表达式的分组操作符错误。在函数声明后面他确实是一个分组操作符，而不是一个函数调用所使用的圆括号。所以如果我们声明如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// &quot;foo&quot; 是一个函数声明，在进入上下文的时候创建</div><div class="line">alert(foo); // 函数</div><div class="line">function foo(x) &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;(1); // 这只是一个分组操作符，不是函数调用！</div><div class="line">foo(10); // 这才是一个真正的函数调用，结果是10</div></pre></td></tr></table></figure>
<p>上述代码是没有问题的，因为声明的时候产生了 2 个对象：一个函数声明，一个带有 1 的分组操作，上面的例子可以理解为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function foo(x) &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;</div><div class="line">// 一个分组操作符，包含一个表达式1</div><div class="line">(1);</div><div class="line">// 另外一个操作符，包含一个function表达式</div><div class="line">(function () &#123;&#125;);</div><div class="line">// 这个操作符里，包含的也是一个表达式&quot;foo&quot;</div><div class="line">(&quot;foo&quot;);</div><div class="line">// 等等</div></pre></td></tr></table></figure>
<p>如果我们定义一个如下代码（定义里包含一个语句），我们可能会说，定义歧义，会得到报错：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (true) function foo() &#123;alert(1)&#125;</div></pre></td></tr></table></figure>
<p>根据规范，上述代码是错误的（一个表达式语句不能以 function 关键字开头），但下面的例子就没有报错，想想为什么？</p>
<p>我们如果来告诉解释器：我就像在函数声明之后立即调用，答案是很明确的，你得声明函数表达式 function expression，而不是函数声明 function declaration，并且创建表达式最简单的方式就是用分组操作符括号，里边放入的永远是表达式，所以解释器在解释的时候就不会出现歧义。在代码执行阶段这个的 function 就会被创建，并且立即执行，然后自动销毁（如果没有引用的话）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function foo(x) &#123;</div><div class="line">  alert(x);</div><div class="line">&#125;)(1); // 这才是调用，不是分组操作符</div></pre></td></tr></table></figure>
<p>上述代码就是我们所说的在用括号括住一个表达式，然后通过（1）去调用。</p>
<p>注意，下面一个立即执行的函数，周围的括号不是必须的，因为函数已经处在表达式的位置，解析器知道它处理的是在函数执行阶段应该被创建的 FE，这样在函数创建后立即调用了函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line"></div><div class="line">  bar: function (x) &#123;</div><div class="line">    return x % 2 != 0 ? &apos;yes&apos; : &apos;no&apos;;</div><div class="line">  &#125;(1)</div><div class="line">&#125;;</div><div class="line">alert(foo.bar); // &apos;yes&apos;</div></pre></td></tr></table></figure>
<p>就像我们看到的，foo.bar 是一个字符串而不是一个函数，这里的函数仅仅用来根据条件参数初始化这个属性——它创建后并立即调用。</p>
<blockquote>
<p>因此，”关于圆括号”问题完整的答案如下：当函数不在表达式的位置的时候，分组操作符圆括号是必须的——也就是手工将函数转化成 FE。<br>如果解析器知道它处理的是 FE，就没必要用圆括号。</p>
</blockquote>
<p>除了大括号以外，如下形式也可以将函数转化为 FE类型，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 注意是1,后面的声明</div><div class="line">1, function () &#123;</div><div class="line">  alert(&apos;anonymous function is called&apos;);</div><div class="line">&#125;();</div><div class="line">// 或者这个</div><div class="line">!function () &#123;</div><div class="line">  alert(&apos;ECMAScript&apos;);</div><div class="line">&#125;();</div><div class="line">// 其它手工转化的形式</div><div class="line">...</div></pre></td></tr></table></figure>
<p>但是，在这个例子中，圆括号是最简洁的方式。</p>
<p>顺便提一句，组表达式包围函数描述可以没有调用圆括号，也可包含调用圆括号，即，下面的两个表达式都是正确的 FE。</p>
<p>实现扩展：函数语句</p>
<p>下面的代码，根据贵方任何一个 function 声明都不应该被执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if (true) &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    alert(0);</div><div class="line">  &#125;</div><div class="line">&#125; else &#123;</div><div class="line">  function foo() &#123;</div><div class="line">    alert(1);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">foo(); // 1 or 0 ?实际在上不同环境下测试得出个结果不一样</div></pre></td></tr></table></figure>
<p>这里有必要说明的是，按照标准，这种句法结构通常是不正确的，因为我们还记得，一个函数声明（FD）不能出现在代码块中（这里 if 和 else 包含代码块）。我们曾经讲过，FD 仅出现在两个位置：程序级（Program level）或直接位于其它函数体中。</p>
<p>因为代码块仅包含语句，所以这是不正确的。可以出现在块中的函数的唯一位置是这些语句中的一个——上面已经讨论过的表达式语句。但是，按照定义它不能以大括号开始(既然它有别于代码块)或以一个函数关键字开始（既然它有别于 FD）。</p>
<p>但是，在标准的错误处理章节中，它允许程序语法的扩展执行。这样的扩展之一就是我们见到的出现在代码块中的函数。在这个例子中，现今的所有存在的执行都不会抛出异常，都会处理它。但是它们都有自己的方式。</p>
<p>if-else 分支语句的出现意味着一个动态的选择。即，从逻辑上来说，它应该是在代码执行阶段动态创建的函数表达式（FE）。但是，大多数执行在进入上下文阶段时简单的创建函数声明（FD），并使用最后声明的函数。即，函数 foo 将显示”1″，事实上 else 分支将永远不会执行。</p>
<p>但是，SpiderMonkey （和TraceMonkey）以两种方式对待这种情况：一方面它不会将函数作为声明处理（即，函数在代码执行阶段根据条件创建），但另一方面，既然没有括号包围（再次出现解析错误——”与 FD 有别”），他们不能被调用，所以也不是真正的函数表达式，它储存在变量对象中。</p>
<p>我个人认为这个例子中 SpiderMonkey 的行为是正确的，拆分了它自身的函数中间类型——（FE+FD）。这些函数在合适的时间创建，根据条件，也不像 FE，倒像一个可以从外部调用的 FD，SpiderMonkey 将这种语法扩展 称之为函数语句（缩写为 FS）;该语法在 MDC 中提及过。</p>
<h3 id="命名函数表达式的特性"><a href="#命名函数表达式的特性" class="headerlink" title="命名函数表达式的特性"></a>命名函数表达式的特性</h3><p>当函数表达式 FE 有一个名称（称为命名函数表达式，缩写为 NFE）时，将会出现一个重要的特点。从定义（正如我们从上面示例中看到的那样）中我们知道函数表达式不会影响一个上下文的变量对象（那样意味着既不可能通过名称在函数声明之前调用它，也不可能在声明之后调用它）。但是，FE 在递归调用中可以通过名称调用自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(function foo(bar) &#123;</div><div class="line">  if (bar) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  foo(true); // &quot;foo&quot; 是可用的</div><div class="line">&#125;)();</div><div class="line">// 在外部，是不可用的 </div><div class="line">foo(); // &quot;foo&quot; 未定义</div></pre></td></tr></table></figure>
<p>“foo”储存在什么地方？在 foo 的活动对象中？不是，因为在 foo 中没有定义任何”foo”。在上下文的父变量对象中创建 foo？也不是，因为按照定义——FE 不会影响 VO(变量对象)——从外部调用 foo 我们可以实实在在的看到。那么在哪里呢？</p>
<p>以下是关键点。当解释器在代码执行阶段遇到命名的 FE 时，在 FE 创建之前，它创建了辅助的特定对象，并添加到当前作用域链的最前端。然后它创建了 FE，此时（正如我们在第四章 作用域链知道的那样）函数获取了[[Scope]] 属性——创建这个函数上下文的作用域链）。此后，FE 的名称添加到特定对象上作为唯一的属性；这个属性的值是引用到FE上。最后一步是从父作用域链中移除那个特定的对象。让我们在伪码中看看这个算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">specialObject = &#123;&#125;;</div><div class="line">Scope = specialObject + Scope;</div><div class="line">foo = new FunctionExpression;</div><div class="line">foo.[[Scope]] = Scope;</div><div class="line">specialObject.foo = foo; // &#123;DontDelete&#125;, &#123;ReadOnly&#125;</div><div class="line">delete Scope[0]; // 从作用域链中删除定义的特殊对象specialObject</div></pre></td></tr></table></figure>
<p>因此，在函数外部这个名称不可用的（因为它不在父作用域链中），但是，特定对象已经存储在函数的[[scope]]中，在那里名称是可用的。</p>
<p>但是需要注意的是一些实现（如 Rhino）不是在特定对象中而是在 FE 的激活对象中存储这个可选的名称。Microsoft 中的执行完全打破了 FE 规则，它在父变量对象中保持了这个名称，这样函数在外部变得可以访问。</p>
<h3 id="NFE-与-SpiderMonkey"><a href="#NFE-与-SpiderMonkey" class="headerlink" title="NFE 与 SpiderMonkey"></a>NFE 与 SpiderMonkey</h3><p>我们来看看 NFE 和 SpiderMonkey 的区别，SpiderMonkey 的一些版本有一个与特定对象相关的属性，它可以作为 bug 来对待（虽然按照标准所有的都那样实现了，但更像一个 ECMAScript 标准上的 bug）。它与标识符的解析机制相关：作用域链的分析是二维的，在标识符的解析中，同样考虑到作用域链中每个对象的原型链。</p>
<p>如果我们在 Object.prototype 中定义一个属性，并引用一个”不存在（nonexistent）”的变量。我们就能看到这种执行机制。这样，在下面示例的”x”解析中，我们将到达全局对象，但是没发现”x”。但是，在 SpiderMonkey 中全局对象继承了 Object.prototype 中的属性，相应地，”x”也能被解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;</div><div class="line">(function () &#123;</div><div class="line">  alert(x); // 10</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>活动对象没有原型。按照同样的起始条件，在上面的例子中，不可能看到内部函数的这种行为。如果定义一个局部变量”x”，并定义内部函数（FD 或匿名的 FE），然后再内部函数中引用”x”。那么这个变量将在父函数上下文（即，应该在哪里被解析）中而不是在 Object.prototype 中被解析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Object.prototype.x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  var x = 20;</div><div class="line">  // 函数声明</div><div class="line">  function bar() &#123;</div><div class="line">    alert(x);</div><div class="line">  &#125;</div><div class="line">  bar(); // 20, 从foo的变量对象AO中查询</div><div class="line">  // 匿名函数表达式也是一样</div><div class="line">  (function () &#123;</div><div class="line">    alert(x); // 20, 也是从foo的变量对象AO中查询</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p>尽管如此，一些执行会出现例外，它给活动对象设置了一个原型。因此，在 Blackberry 的执行中，上面例子中的”x”被解析为”10″。也就是说，既然在 Object.prototype 中已经找到了 foo 的值，那么它就不会到达 foo 的活动对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AO(bar FD or anonymous FE) -&gt; no -&gt;</div><div class="line">AO(bar FD or anonymous FE).[[Prototype]] -&gt; yes - 10</div></pre></td></tr></table></figure>
<p>在 SpiderMonkey 中，同样的情形我们完全可以在命名 FE 的特定对象中看到。这个特定的对象（按照标准）是普通对象——“就像表达式 new Object()”，相应地，它应该从 Object.prototype 继承属性，这恰恰是我们在 SpiderMonkey （1.7 以上的版本）看到的执行。其余的执行（包括新的 TraceMonkey）不会为特定的对象设置一个原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  var x = 10;</div><div class="line">  (function bar() &#123;</div><div class="line">    alert(x); // 20, 不上10,不是从foo的活动对象上得到的</div><div class="line">    // &quot;x&quot;从链上查找:</div><div class="line">    // AO(bar) - no -&gt; __specialObject(bar) -&gt; no</div><div class="line">    // __specialObject(bar).[[Prototype]] - yes: 20</div><div class="line">  &#125;)();</div><div class="line">&#125;</div><div class="line">Object.prototype.x = 20;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<h3 id="NFE-与-Jscript"><a href="#NFE-与-Jscript" class="headerlink" title="NFE 与 Jscript"></a>NFE 与 Jscript</h3><p>当前 IE 浏览器(直到 JScript 5.8 — IE8)中内置的 JScript 执行有很多与函数表达式（NFE）相关的 bug。所有的这些 bug 都完全与 ECMA-262-3 标准矛盾；有些可能会导致严重的错误。</p>
<p>首先，这个例子中 JScript 破坏了 FE 的主要规则，它不应该通过函数名存储在变量对象中。可选的 FE 名称应该存储在特定的对象中，并只能在函数自身(而不是别的地方)中访问。但IE直接将它存储在父变量对象中。此外，命名的 FE 在 JScript 中作为函数声明（FD）对待。即创建于进入上下文的阶段，在源代码中的定义之前可以访问。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// FE 在变量对象里可见</div><div class="line">testNFE();</div><div class="line">(function testNFE() &#123;</div><div class="line">  alert(&apos;testNFE&apos;);</div><div class="line">&#125;);</div><div class="line">// FE 在定义结束以后也可见</div><div class="line">// 就像函数声明一样</div><div class="line">testNFE();</div></pre></td></tr></table></figure>
<p>正如我们所见，它完全违背了规则。</p>
<p>其次，在声明中将命名FE赋给一个变量时，JScript 创建了两个不同的函数对象。逻辑上（特别注意的是在 NFE 的外部它的名称根本不应该被访问）很难命名这种行为。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var foo = function bar() &#123;</div><div class="line">  alert(&apos;foo&apos;);</div><div class="line">&#125;;</div><div class="line">alert(typeof bar); // &quot;function&quot;, </div><div class="line">// 有趣的是</div><div class="line">alert(foo === bar); // false!</div><div class="line">foo.x = 10;</div><div class="line">alert(bar.x); // 未定义</div><div class="line">// 但执行的时候结果一样</div><div class="line">foo(); // &quot;foo&quot;</div><div class="line">bar(); // &quot;foo&quot;</div></pre></td></tr></table></figure>
<p>再次看到，已经乱成一片了。</p>
<p>但是，需要注意的是，如果与变量赋值分开，单独描述 NFE（如通过组运算符），然后将它赋给一个变量，并检查其相等性，结果为 true，就好像是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function bar() &#123;&#125;);</div><div class="line">var foo = bar;</div><div class="line">alert(foo === bar); // true</div><div class="line">foo.x = 10;</div><div class="line">alert(bar.x); // 10</div></pre></td></tr></table></figure>
<p>此时是可以解释的。实际上，再次创建两个对象，但那样做事实上仍保持一个。如果我们再次认为这里的 NFE 被作为 FD 对待，然后在进入上下文阶段创建 FD bar。此后，在代码执行阶段第二个对象——函数表达式（FE）bar 被创建，它不会被存储。相应地，没有 FE bar 的任何引用，它被移除了。这样就只有一个对象——FD bar，对它的引用赋给了变量 foo。</p>
<p>第三，就通过 arguments.callee 间接引用一个函数而言，它引用的是被激活的那个对象的名称（确切的说——再这里有两个函数对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var foo = function bar() &#123;</div><div class="line">  alert([</div><div class="line">    arguments.callee === foo,</div><div class="line">    arguments.callee === bar</div><div class="line">  ]);</div><div class="line">&#125;;</div><div class="line">foo(); // [true, false]</div><div class="line">bar(); // [false, true]</div></pre></td></tr></table></figure>
<p>第四，JScript 像对待普通的 FD 一样对待 NFE，他不服从条件表达式规则。即，就像一个 FD，NFE 在进入上下文时创建，在代码中最后的定义被使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var foo = function bar() &#123;</div><div class="line">  alert(1);</div><div class="line">&#125;;</div><div class="line">if (false) &#123;</div><div class="line">  foo = function bar() &#123;</div><div class="line">    alert(2);</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">bar(); // 2</div><div class="line">foo(); // 1</div></pre></td></tr></table></figure>
<p>这种行为从”逻辑上”也可以解释。在进入上下文阶段，最后遇到的 FD bar 被创建，即包含 alert(2)的函数。此后，在代码执行阶段，新的函数——FE bar 创建，对它的引用赋给了变量 foo。这样 foo 激活产生 alert(1)。逻辑很清楚，但考虑到 IE 的 bug，既然执行明显被破坏，并依赖于 JScript 的 bug，我给单词”逻辑上(logically)”加上了引号。</p>
<p>JScript 的第五个 bug 与全局对象的属性创建相关，全局对象由赋值给一个未限定的标识符（即，没有 var 关键字）来生成。既然 NFE 在这被作为 FD 对待，相应地，它存储在变量对象中，赋给一个未限定的标识符（即不是赋给变量而是全局对象的普通属性），万一函数的名称与未限定的标识符相同，这样该属性就不是全局的了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(function () &#123;</div><div class="line">  // 不用var的话，就不是当前上下文的一个变量了</div><div class="line">  // 而是全局对象的一个属性</div><div class="line">  foo = function foo() &#123;&#125;;</div><div class="line">&#125;)();</div><div class="line">//  但，在匿名函数的外部，foo这个名字是不可用的</div><div class="line">alert(typeof foo); // 未定义</div></pre></td></tr></table></figure>
<p>“逻辑”已经很清楚了：在进入上下文阶段，函数声明foo取得了匿名函数局部上下文的活动对象。在代码执行阶段，名称 foo 在 AO 中已经存在，即，它被作为局部变量。相应地，在赋值操作中，只是简单的更新已存在于 AO 中的属性 foo，而不是按照 ECMA-262-3 的逻辑创建全局对象的新属性。</p>
<h3 id="通过函数构造器创建的函数"><a href="#通过函数构造器创建的函数" class="headerlink" title="通过函数构造器创建的函数"></a>通过函数构造器创建的函数</h3><p>既然这种函数对象也有自己的特色，我们将它与FD和FE区分开来。其主要特点在于这种函数的[[Scope]]属性仅包含全局对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function foo() &#123;</div><div class="line">  var x = 20;</div><div class="line">  var y = 30;</div><div class="line">  var bar = new Function(&apos;alert(x); alert(y);&apos;);</div><div class="line">  bar(); // 10, &quot;y&quot; 未定义</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到，函数 bar 的[[Scope]]属性不包含 foo 上下文的 Ao ——变量”y”不能访问，变量”x”从全局对象中取得。顺便提醒一句，Function 构造器既可使用 new 关键字，也可以没有，这样说来，这些变体是等价的。</p>
<p>这些函数的其他特点与 Equated Grammar Productions 和 Joined Objects 相关。作为优化建议（但是，实现上可以不使用优化）,规范提供了这些机制。如，如果我们有一个 100 个元素的数组，在函数的一个循环中，执行可能使用 Joined Objects 机制。结果是数组中的所有元素仅一个函数对象可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var k = 0; k &lt; 100; k++) &#123;</div><div class="line">  a[k] = function () &#123;&#125;; // 可能使用了joined objects</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是通过函数构造器创建的函数不会被连接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for (var k = 0; k &lt; 100; k++) &#123;</div><div class="line">  a[k] = Function(&apos;&apos;); // 一直是100个不同的函数</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一个与联合对象（joined objects）相关的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">  function bar(z) &#123;</div><div class="line">    return z * z;</div><div class="line">  &#125;</div><div class="line">  return bar;</div><div class="line">&#125;</div><div class="line">var x = foo();</div><div class="line">var y = foo();</div></pre></td></tr></table></figure>
<p>这里的实现，也有权利连接对象x和对象y（使用同一个对象），因为函数（包括它们的内部[[Scope]] 属性）在根本上是没有区别的。因此，通过函数构造器创建的函数总是需要更多的内存资源。</p>
<h2 id="创建函数的算法"><a href="#创建函数的算法" class="headerlink" title="创建函数的算法"></a>创建函数的算法</h2><p>下面的伪码描述了函数创建的算法（与联合对象相关的步骤除外）。这些描述有助于你理解 ECMAScript 中函数对象的更多细节。这种算法适合所有的函数类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">F = new NativeObject();</div><div class="line">// 属性[[Class]]是&quot;Function&quot;</div><div class="line">F.[[Class]] = &quot;Function&quot;</div><div class="line">// 函数对象的原型是Function的原型</div><div class="line">F.[[Prototype]] = Function.prototype </div><div class="line">// 医用到函数自身</div><div class="line">// 调用表达式F的时候激活[[Call]]</div><div class="line">// 并且创建新的执行上下文</div><div class="line">F.[[Call]] = &lt;reference to function&gt;</div><div class="line">// 在对象的普通构造器里编译</div><div class="line">// [[Construct]] 通过new关键字激活</div><div class="line">// 并且给新对象分配内存</div><div class="line">// 然后调用F.[[Call]]初始化作为this传递的新创建的对象</div><div class="line">F.[[Construct]] = internalConstructor</div><div class="line">// 当前执行上下文的作用域链</div><div class="line">// 例如，创建F的上下文</div><div class="line">F.[[Scope]] = activeContext.Scope</div><div class="line">// 如果函数通过new Function(...)来创建，</div><div class="line">// 那么</div><div class="line">F.[[Scope]] = globalContext.Scope</div><div class="line">// 传入参数的个数</div><div class="line">F.length = countParameters</div><div class="line">// F对象创建的原型</div><div class="line">__objectPrototype = new Object();</div><div class="line">__objectPrototype.constructor = F // &#123;DontEnum&#125;, 在循环里不可枚举x</div><div class="line">F.prototype = __objectPrototype</div><div class="line">return F</div></pre></td></tr></table></figure>
<p>注意，F.[[Prototype]]是函数（构造器）的一个原型，F.prototype 是通过这个函数创建的对象的原型（因为术语常常混乱，一些文章中 F.prototype 被称之为“构造器的原型”，这是不正确的）。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章有些长。但是，当我们在接下来关于对象和原型章节中将继续讨论函数。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ol>
<li><a href="http://bclary.com/2004/11/07/#a-13" target="_blank" rel="external">Function Definition</a>;</li>
<li><a href="http://bclary.com/2004/11/07/#a-15.3" target="_blank" rel="external">Function Objects</a>.</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/02/14/深入理解javascript/45代码复用模式（避免篇）/"><span>代码复用模式（避免篇）</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/14/深入理解javascript/45代码复用模式（避免篇）/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-14T04:02:02.000Z">
          2016-02-14
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>任何编程都提出代码复用，否则话每次开发一个新程序或者写一个新功能都要全新编写的话，那就歇菜了，但是代码复用也是有好要坏，接下来的两篇文章我们将针对代码复用来进行讨论，第一篇文避免篇，指的是要尽量避免使用这些模式，因为或多或少有带来一些问题；第二排是推荐篇，指的是推荐大家使用的模式，一般不会有什么问题。</p>
<h2 id="模式-1：默认模式"><a href="#模式-1：默认模式" class="headerlink" title="模式 1：默认模式"></a>模式 1：默认模式</h2><p>代码复用大家常用的默认模式，往往是有问题的，该模式使用 Parent()的构造函数创建一个对象，并且将该对象赋值给 Child()的原型。我们看一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function inherit(C, P) &#123;</div><div class="line">    C.prototype = new P();</div><div class="line">&#125;</div><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数为空</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">// 执行继承</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child();</div><div class="line">console.log(kid.say()); // &quot;Adam&quot;</div><div class="line">var kiddo = new Child();</div><div class="line">kiddo.name = &quot;Patrick&quot;;</div><div class="line">console.log(kiddo.say()); // &quot;Patrick&quot;</div><div class="line">// 缺点:不能让参数传进给Child构造函数</div><div class="line">var s = new Child(&apos;Seth&apos;);</div><div class="line">console.log(s.say()); // &quot;Adam&quot;</div></pre></td></tr></table></figure>
<p>这种模式的缺点是 Child 不能传进参数，基本上也就废了。</p>
<h2 id="模式-2：借用构造函数"><a href="#模式-2：借用构造函数" class="headerlink" title="模式 2：借用构造函数"></a>模式 2：借用构造函数</h2><p>该模式是 Child 借用 Parent 的构造函数进行 apply，然后将 child 的 this 和参数传递给 apply 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">    Parent.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">var kid = new Child(&quot;Patrick&quot;);</div><div class="line">console.log(kid.name); // &quot;Patrick&quot;</div><div class="line">// 缺点：没有从构造函数上继承say方法</div><div class="line">console.log(typeof kid.say); // &quot;undefined&quot;</div></pre></td></tr></table></figure>
<p>缺点也很明显，say 方法不可用，因为没有继承过来。</p>
<h2 id="模式-3：借用构造函数并设置原型"><a href="#模式-3：借用构造函数并设置原型" class="headerlink" title="模式 3：借用构造函数并设置原型"></a>模式 3：借用构造函数并设置原型</h2><p>上述两个模式都有自己的缺点，那如何把两者的缺点去除呢，我们来尝试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">    Parent.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">Child.prototype = new Parent();</div><div class="line">var kid = new Child(&quot;Patrick&quot;);</div><div class="line">console.log(kid.name); // &quot;Patrick&quot;</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">console.dir(kid);</div><div class="line">delete kid.name;</div><div class="line">console.log(kid.say()); // &quot;Adam&quot;</div></pre></td></tr></table></figure>
<p>运行起来，一切正常，但是有没有发现，Parent 构造函数执行了两次，所以说，虽然程序可用，但是效率很低。</p>
<h2 id="模式4：共享原型"><a href="#模式4：共享原型" class="headerlink" title="模式4：共享原型"></a>模式4：共享原型</h2><p>共享原型是指 Child 和 Parent 使用同样的原型，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function inherit(C, P) &#123;</div><div class="line">    C.prototype = P.prototype;</div><div class="line">&#125;</div><div class="line">// 父构造函数</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child(&apos;Patrick&apos;);</div><div class="line">console.log(kid.name); // undefined</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">kid.name = &apos;Patrick&apos;;</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">console.dir(kid);</div></pre></td></tr></table></figure>
<p>确定还是一样，Child 的参数没有正确接收到。</p>
<h2 id="模式-5：临时构造函数"><a href="#模式-5：临时构造函数" class="headerlink" title="模式 5：临时构造函数"></a>模式 5：临时构造函数</h2><p>首先借用构造函数，然后将 Child 的原型设置为该借用构造函数的实例，最后恢复 Child 原型的构造函数。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">/* 闭包 */</div><div class="line">var inherit = (function () &#123;</div><div class="line">    var F = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    return function (C, P) &#123;</div><div class="line">        F.prototype = P.prototype;</div><div class="line">        C.prototype = new F();</div><div class="line">        C.uber = P.prototype;</div><div class="line">        C.prototype.constructor = C;</div><div class="line">    &#125;</div><div class="line">&#125; ());</div><div class="line">function Parent(name) &#123;</div><div class="line">    this.name = name || &apos;Adam&apos;;</div><div class="line">&#125;</div><div class="line">// 给原型添加say功能</div><div class="line">Parent.prototype.say = function () &#123;</div><div class="line">    return this.name;</div><div class="line">&#125;;</div><div class="line">// Child构造函数</div><div class="line">function Child(name) &#123;</div><div class="line">&#125;</div><div class="line">inherit(Child, Parent);</div><div class="line">var kid = new Child();</div><div class="line">console.log(kid.name); // undefined</div><div class="line">console.log(typeof kid.say); // function</div><div class="line">kid.name = &apos;Patrick&apos;;</div><div class="line">console.log(kid.say()); // Patrick</div><div class="line">var kid2 = new Child(&quot;Tom&quot;);</div><div class="line">console.log(kid.say()); </div><div class="line">console.log(kid.constructor.name); // Child</div><div class="line">console.log(kid.constructor === Parent); // false</div></pre></td></tr></table></figure>
<p>问题照旧，Child 不能正常接收参数。</p>
<h2 id="模式-6：klass"><a href="#模式-6：klass" class="headerlink" title="模式 6：klass"></a>模式 6：klass</h2><p>这个模式，先上代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">var klass = function (Parent, props) &#123;</div><div class="line">    var Child, F, i;  </div><div class="line">    // 1.</div><div class="line">    // 新构造函数</div><div class="line">    Child = function () &#123;</div><div class="line">        if (Child.uber &amp;&amp; Child.uber.hasOwnProperty(&quot;__construct&quot;)) &#123;</div><div class="line">            Child.uber.__construct.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">        if (Child.prototype.hasOwnProperty(&quot;__construct&quot;)) &#123;</div><div class="line">            Child.prototype.__construct.apply(this, arguments);</div><div class="line">        &#125;</div><div class="line">    &#125;;  </div><div class="line">    // 2.</div><div class="line">    // 继承</div><div class="line">    Parent = Parent || Object;</div><div class="line">    F = function () &#123;</div><div class="line">    &#125;;</div><div class="line">    F.prototype = Parent.prototype;</div><div class="line">    Child.prototype = new F();</div><div class="line">    Child.uber = Parent.prototype;</div><div class="line">    Child.prototype.constructor = Child;  </div><div class="line">    // 3.</div><div class="line">    // 添加实现方法</div><div class="line">    for (i in props) &#123;</div><div class="line">        if (props.hasOwnProperty(i)) &#123;</div><div class="line">            Child.prototype[i] = props[i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // return the &quot;class&quot;</div><div class="line">    return Child;</div><div class="line">&#125;;  </div><div class="line">var Man = klass(null, &#123;</div><div class="line">    __construct: function (what) &#123;</div><div class="line">        console.log(&quot;Man&apos;s constructor&quot;);</div><div class="line">        this.name = what;</div><div class="line">    &#125;,</div><div class="line">    getName: function () &#123;</div><div class="line">        return this.name;</div><div class="line">    &#125;</div><div class="line">&#125;);  </div><div class="line">var first = new Man(&apos;Adam&apos;); // logs &quot;Man&apos;s constructor&quot;</div><div class="line">first.getName(); // &quot;Adam&quot;</div><div class="line">var SuperMan = klass(Man, &#123;</div><div class="line">    __construct: function (what) &#123;</div><div class="line">        console.log(&quot;SuperMan&apos;s constructor&quot;);</div><div class="line">    &#125;,</div><div class="line">    getName: function () &#123;</div><div class="line">        var name = SuperMan.uber.getName.call(this);</div><div class="line">        return &quot;I am &quot; + name;</div><div class="line">    &#125;</div><div class="line">&#125;);  </div><div class="line">var clark = new SuperMan(&apos;Clark Kent&apos;);</div><div class="line">clark.getName(); // &quot;I am Clark Kent&quot;  </div><div class="line">console.log(clark instanceof Man); // true</div><div class="line">console.log(clark instanceof SuperMan); // true</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上六个模式虽然在某种特殊情况下实现了某些功能，但是都存在各自的缺点，所以一般情况，大家要避免使用。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/02/13/深入理解javascript/5强大的原型和原型链/"><span>强大的原型和原型链</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/13/深入理解javascript/5强大的原型和原型链/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-13T09:02:02.000Z">
          2016-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>JavaScript 不包含传统的类继承模型，而是使用 prototypal 原型模型。</p>
<p>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。</p>
<p>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链。</p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>10 年前，我刚学习 JavaScript 的时候，一般都是用如下方式来写代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var decimalDigits = 2,</div><div class="line">    tax = 5;</div><div class="line">function add(x, y) &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;</div><div class="line">function subtract(x, y) &#123;</div><div class="line">    return x - y;</div><div class="line">&#125;</div><div class="line">//alert(add(1, 3));</div></pre></td></tr></table></figure>
<p>通过执行各个 function 来得到结果，学习了原型之后，我们可以使用如下方式来<code>美化</code>一下代码。</p>
<h2 id="原型使用方式-1"><a href="#原型使用方式-1" class="headerlink" title="原型使用方式 1"></a>原型使用方式 1</h2><p>在使用原型之前，我们需要先将代码做一下小修改：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Calculator = function (decimalDigits, tax) &#123;</div><div class="line">    this.decimalDigits = decimalDigits;</div><div class="line">    this.tax = tax;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>然后，通过给 Calculator 对象的 <code>prototype</code> 属性赋值<code>对象字面量</code>来设定 Calculator 对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Calculator.prototype = &#123;</div><div class="line">    add: function (x, y) &#123;</div><div class="line">        return x + y;</div><div class="line">    &#125;,</div><div class="line">    subtract: function (x, y) &#123;</div><div class="line">        return x - y;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">//alert((new Calculator()).add(1, 3));</div></pre></td></tr></table></figure>
<p>这样，我们就可以 new Calculator 对象以后，就可以调用 add 方法来计算结果了。</p>
<h2 id="原型使用方式-2"><a href="#原型使用方式-2" class="headerlink" title="原型使用方式 2"></a>原型使用方式 2</h2><p>第二种方式是，在赋值原型 prototype 的时候使用 function 立即执行的表达式来赋值，即如下格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Calculator.prototype = function () &#123; &#125; ();</div></pre></td></tr></table></figure>
<p>它的好处在前面的帖子里已经知道了，就是可以封装私有的 function，通过 return 的形式暴露出简单的使用名称，以达到 public/private 的效果，修改后的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Calculator.prototype = function () &#123;</div><div class="line">           add = function (x, y) &#123;</div><div class="line">               return x + y;</div><div class="line">           &#125;,</div><div class="line">           subtract = function (x, y) &#123;</div><div class="line">               return x - y;</div><div class="line">           &#125;</div><div class="line">           return &#123;</div><div class="line">               add: add,</div><div class="line">               subtract: subtract</div><div class="line">           &#125;</div><div class="line">       &#125; ();</div><div class="line">       //alert((new Calculator()).add(11, 3));</div></pre></td></tr></table></figure>
<p>同样的方式，我们可以 new Calculator 对象以后调用 add 方法来计算结果了。</p>
<h2 id="再来一点"><a href="#再来一点" class="headerlink" title="再来一点"></a>再来一点</h2><h3 id="分步声明"><a href="#分步声明" class="headerlink" title="分步声明"></a>分步声明</h3><p>上述使用原型的时候，有一个限制就是一次性设置了原型对象，我们再来说一下如何分来设置原型的每个属性吧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var BaseCalculator = function () &#123;</div><div class="line">    //为每个实例都声明一个小数位数</div><div class="line">    this.decimalDigits = 2;</div><div class="line">&#125;;      </div><div class="line">//使用原型给BaseCalculator扩展2个对象方法</div><div class="line">BaseCalculator.prototype.add = function (x, y) &#123;</div><div class="line">    return x + y;</div><div class="line">&#125;;</div><div class="line">BaseCalculator.prototype.subtract = function (x, y) &#123;</div><div class="line">    return x - y;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>首先，声明了一个 BaseCalculator 对象，构造函数里会初始化一个小数位数的属性 decimalDigits，然后通过原型属性设置 2 个 function，分别是 add(x,y)和 subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将 BaseCalculator 对象设置到真正的 Calculator 的原型上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var BaseCalculator = function() &#123;</div><div class="line">    this.decimalDigits = 2;</div><div class="line">&#125;;</div><div class="line">BaseCalculator.prototype = &#123;</div><div class="line">    add: function(x, y) &#123;</div><div class="line">        return x + y;</div><div class="line">    &#125;,</div><div class="line">    subtract: function(x, y) &#123;</div><div class="line">        return x - y;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>创建完上述代码以后，我们来开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var Calculator = function () &#123;</div><div class="line">    //为每个实例都声明一个税收数字</div><div class="line">    this.tax = 5;</div><div class="line">&#125;;       </div><div class="line">Calculator.prototype = new BaseCalculator();</div></pre></td></tr></table></figure>
<p>我们可以看到 Calculator 的原型是指向到 BaseCalculator 的一个实例上，目的是让 Calculator 集成它的 add(x,y)和 subtract(x,y)这 2 个 function，还有一点要说的是，由于它的原型是 BaseCalculator 的一个实例，所以不管你创建多少个 Calculator 对象实例，他们的原型指向的都是同一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var calc = new Calculator();</div><div class="line">alert(calc.add(1, 1));</div><div class="line">//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的</div><div class="line">alert(calc.decimalDigits);</div></pre></td></tr></table></figure>
<p>上面的代码，运行以后，我们可以看到因为 Calculato r的原型是指向 BaseCalculator 的实例上的，所以可以访问他的 decimalDigits 属性值，那如果我不想让 Calculator 访问 BaseCalculator 的构造函数里声明的属性值，那怎么办呢？这么办：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var Calculator = function () &#123;</div><div class="line">    this.tax= 5;</div><div class="line">&#125;;</div><div class="line">Calculator.prototype = BaseCalculator.prototype;</div></pre></td></tr></table></figure>
<p>通过将 BaseCalculator 的原型赋给 Calculator 的原型，这样你在 Calculator 的实例上就访问不到那个 decimalDigits 值了，如果你访问如下代码，那将会提升出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var calc = new Calculator();</div><div class="line">alert(calc.add(1, 1));</div><div class="line">alert(calc.decimalDigits);</div></pre></td></tr></table></figure>
<h2 id="重写原型"><a href="#重写原型" class="headerlink" title="重写原型"></a>重写原型</h2><p>在使用第三方 JS 类库的时候，往往有时候他们定义的原型方法是不能满足我们的需要，但是又离不开这个类库，所以这时候我们就需要重写他们的原型中的一个或者多个属性或 function，我们可以通过继续声明的同样的 add 代码的形式来达到覆盖重写前面的 add 功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//覆盖前面Calculator的add() function </div><div class="line">Calculator.prototype.add = function (x, y) &#123;</div><div class="line">    return x + y + this.tax;</div><div class="line">&#125;;</div><div class="line">var calc = new Calculator();</div><div class="line">alert(calc.add(1, 1));</div></pre></td></tr></table></figure>
<p>这样，我们计算得出的结果就比原来多出了一个 tax 的值，但是有一点需要注意：那就是重写的代码需要放在最后，这样才能覆盖前面的代码。</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>在将原型链之前，我们先上一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;</div><div class="line">    this.value = 42;</div><div class="line">&#125;</div><div class="line">Foo.prototype = &#123;</div><div class="line">    method: function() &#123;&#125;</div><div class="line">&#125;;</div><div class="line">function Bar() &#123;&#125;</div><div class="line">// 设置Bar的prototype属性为Foo的实例对象</div><div class="line">Bar.prototype = new Foo();</div><div class="line">Bar.prototype.foo = &apos;Hello World&apos;;</div><div class="line">// 修正Bar.prototype.constructor为Bar本身</div><div class="line">Bar.prototype.constructor = Bar;</div><div class="line">var test = new Bar() // 创建Bar的一个新实例</div><div class="line">// 原型链</div><div class="line">test [Bar的实例]</div><div class="line">    Bar.prototype [Foo的实例] </div><div class="line">        &#123; foo: &apos;Hello World&apos; &#125;</div><div class="line">        Foo.prototype</div><div class="line">            &#123;method: ...&#125;;</div><div class="line">            Object.prototype</div><div class="line">                &#123;toString: ... /* etc. */&#125;;</div></pre></td></tr></table></figure>
<p>上面的例子中，test 对象从 Bar.prototype 和 Foo.prototype 继承下来；因此，它能访问 Foo 的原型方法 method。同时，它也能够访问那个定义在原型上的 Foo 实例属性 value。需要注意的是 new Bar() 不会创造出一个新的 Foo 实例，而是重复使用它原型上的那个实例；因此，所有的 Bar 实例都会共享相同的 value 属性。</p>
<h2 id="属性查找"><a href="#属性查找" class="headerlink" title="属性查找"></a>属性查找</h2><p>当查找一个对象的属性时，JavaScript 会向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined，我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function foo() &#123;</div><div class="line">    this.add = function (x, y) &#123;</div><div class="line">        return x + y;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">foo.prototype.add = function (x, y) &#123;</div><div class="line">    return x + y + 10;</div><div class="line">&#125;</div><div class="line">Object.prototype.subtract = function (x, y) &#123;</div><div class="line">    return x - y;</div><div class="line">&#125;</div><div class="line">var f = new foo();</div><div class="line">alert(f.add(1, 2)); //结果是3，而不是13</div><div class="line">alert(f.subtract(1, 2)); //结果是-1</div></pre></td></tr></table></figure>
<p>通过代码运行，我们发现 subtract 是安装我们所说的向上查找来得到结果的，但是 add 方式有点小不同，这也是我想强调的，就是属性在查找的时候是先查找自身的属性，如果没有再查找原型，再没有，再往上走，一直插到 Object 的原型上，所以在某种层面上说，用 for in 语句遍历属性的时候，效率也是个问题。</p>
<p>还有一点我们需要注意的是，我们可以赋值任何类型的对象到原型上，但是不能赋值原子类型的值，比如如下代码是无效的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function Foo() &#123;&#125;</div><div class="line">Foo.prototype = 1; // 无效</div></pre></td></tr></table></figure>
<h2 id="hasOwnProperty-函数"><a href="#hasOwnProperty-函数" class="headerlink" title="hasOwnProperty 函数"></a>hasOwnProperty 函数</h2><p>hasOwnProperty 是 Object.prototype 的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为 hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 修改Object.prototype</div><div class="line">Object.prototype.bar = 1; </div><div class="line">var foo = &#123;goo: undefined&#125;;</div><div class="line">foo.bar; // 1</div><div class="line">&apos;bar&apos; in foo; // true</div><div class="line">foo.hasOwnProperty(&apos;bar&apos;); // false</div><div class="line">foo.hasOwnProperty(&apos;goo&apos;); // true</div></pre></td></tr></table></figure>
<p>只有 hasOwnProperty 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。 没有其它方法可以用来排除原型链上的属性，而不是定义在对象自身上的属性。</p>
<p>但有个恶心的地方是：JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;</div><div class="line">    hasOwnProperty: function() &#123;</div><div class="line">        return false;</div><div class="line">    &#125;,</div><div class="line">    bar: &apos;Here be dragons&apos;</div><div class="line">&#125;;</div><div class="line">foo.hasOwnProperty(&apos;bar&apos;); // 总是返回 false</div><div class="line">// 使用&#123;&#125;对象的 hasOwnProperty，并将其上下为设置为foo</div><div class="line">&#123;&#125;.hasOwnProperty.call(foo, &apos;bar&apos;); // true</div></pre></td></tr></table></figure>
<p>当检查对象上某个属性是否存在时，hasOwnProperty 是唯一可用的方法。同时在使用 for in loop 遍历对象时，推荐总是使用 hasOwnProperty 方法，这将会避免原型对象扩展带来的干扰，我们来看一下例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 修改 Object.prototype</div><div class="line">Object.prototype.bar = 1;</div><div class="line">var foo = &#123;moo: 2&#125;;</div><div class="line">for(var i in foo) &#123;</div><div class="line">    console.log(i); // 输出两个属性：bar 和 moo</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们没办法改变 for in 语句的行为，所以想过滤结果就只能使用 hasOwnProperty 方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// foo 变量是上例中的</div><div class="line">for(var i in foo) &#123;</div><div class="line">    if (foo.hasOwnProperty(i)) &#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个版本的代码是唯一正确的写法。由于我们使用了 hasOwnProperty，所以这次只输出 moo。如果不使用 hasOwnProperty，则这段代码在原生对象原型（比如 Object.prototype）被扩展时可能会出错。</p>
<p>总结：推荐使用 hasOwnProperty，不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原型极大地丰富了我们的开发代码，但是在平时使用的过程中一定要注意上述提到的一些注意事项。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2016/02/13/深入理解javascript/19求值策略/"><span>求值策略</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2016/02/13/深入理解javascript/19求值策略/" rel="bookmark">
        <time class="entry-date published" datetime="2016-02-13T07:02:02.000Z">
          2016-02-13
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>本章，我们将讲解在 ECMAScript 向函数 function 传递参数的策略。</p>
<p>计算机科学里对这种策略一般称为“evaluation strategy”（大叔注：有的人说翻译成求值策略，有的人翻译成赋值策略，通看下面的内容，我觉得称为赋值策略更为恰当，anyway，标题还是写成大家容易理解的求值策略吧），例如在编程语言为求值或者计算表达式设置规则。向函数传递参数的策略是一个特殊的 case。</p>
<p>写这篇文章的原因是因为论坛上有人要求准确解释一些传参的策略，我们这里给出了相应的定义，希望对大家有所帮助。</p>
<p>很多程序员都确信在 JavaScript 中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参，此外，很多文章都说到这个“事实”，但有多人真正理解这个术语，而且又有多少是正确的?我们本篇讲逐一讲解。</p>
<h2 id="一般理论"><a href="#一般理论" class="headerlink" title="一般理论"></a>一般理论</h2><p>需要注意到，在赋值理论里一般有 2 中赋值策略：严格——意思是说参数在进入程序之前是经过计算过的；非严格——意思是参数的计算是根据计算要求才去计算（也就是相当于延迟计算）。</p>
<p>然后，这里我们考虑基本的函数传参策略，从 ECMAScript 出发点来说是非常重要的。首先需要注意的是，在 ECMAScript 中（甚至其他的语如C，JAVA，Python 和 Ruby 中）都使用了严格的参数传递策略。</p>
<p>另外传递参数的计算顺序也是很重要的——在 ECMAScript 是左到右，而且其它语言实现的反省顺序（从右向做）也是可以用的。</p>
<p>严格的传参策略也分为几种子策略，其中最重要的一些策略我们在本章详细讨论。</p>
<p>下面讨论的策略不是全部都用在 ECMAScript 中，所以在讨论这些策略的具体行为的时候，我们使用了伪代码来展示。</p>
<h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bar = 10</div><div class="line">procedure foo(barArg):</div><div class="line">  barArg = 20;</div><div class="line">end</div><div class="line">foo(bar)</div><div class="line">// foo内部改变值不会影响内部的bar的值</div><div class="line">print(bar) // 10</div></pre></td></tr></table></figure>
<p>但是，如果该函数的参数不是原始值而是复杂的结构对象是时候，将带来很大的性能问题，C++就有这个问题，将结构作为值传进函数的时候——就是完整的拷贝。</p>
<p>我们来给一个一般的例子，用下面的赋值策略来检验一下，想想一下一个函数接受 2 个参数，第 1 个参数是对象的值，第 2 个是个布尔型的标记，用来标记是否完全修改传入的对象（给对象重新赋值），还是只修改该对象的一些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 注：以下都是伪代码，不是JS实现</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">foo(bar)</div><div class="line">// 按值传递，外部的对象不被改变</div><div class="line">print(bar) // &#123;x: 10, y: 20&#125;</div><div class="line">// 完全改变对象（赋新值）</div><div class="line">foo(bar, true)</div><div class="line">//也没有改变</div><div class="line">print(bar) // &#123;x: 10, y: 20&#125;, 而不是&#123;z: 1, q: 2&#125;</div></pre></td></tr></table></figure>
<h3 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h3><p>另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">// 使用和上例相同的对象</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">// 按引用调用的结果如下： </div><div class="line">foo(bar)</div><div class="line">// 对象的属性值已经被改变了</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div><div class="line">// 重新赋新值也影响到了该对象</div><div class="line">foo(bar, true)</div><div class="line">// 此刻该对象已经是一个新对象了</div><div class="line">print(bar) // &#123;z: 1, q: 2&#125;</div></pre></td></tr></table></figure>
<p>该策略可以更有效地传递复杂对象，例如带有大批量属性的大结构对象。</p>
<h3 id="按共享传递（Call-by-sharing）"><a href="#按共享传递（Call-by-sharing）" class="headerlink" title="按共享传递（Call by sharing）"></a>按共享传递（Call by sharing）</h3><p>上面 2 个策略大家都是知道的，但这里要讲的一个策略可能大家不太了解（其实是学术上的策略)。但是，我们很快就会看到这正是它在 ECMAScript 中的参数传递战略中起着关键作用的策略。</p>
<p>这个策略还有一些代名词：“按对象传递”或“按对象共享传递”。</p>
<p>该策略是 1974 年由 Barbara Liskov 为 CLU 编程语言提出的。</p>
<p>该策略的要点是：函数接收的是对象对于的拷贝（副本），该引用拷贝和形参以及其值相关联。</p>
<p>这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。</p>
<p>最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的 case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">//还是使用这个对象结构</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">// 按贡献传递会影响对象 </div><div class="line">foo(bar)</div><div class="line">// 对象的属性被修改了</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div><div class="line">// 重新赋值没有起作用</div><div class="line">foo(bar, true)</div><div class="line">// 依然是上面的值</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div></pre></td></tr></table></figure>
<p>这个处理的假设前提是大多数语言里用到的对象，而不是原始值。</p>
<h3 id="按共享传递是按值传递的特例"><a href="#按共享传递是按值传递的特例" class="headerlink" title="按共享传递是按值传递的特例"></a>按共享传递是按值传递的特例</h3><p>按共享传递这个策略很很多语言里都使用了：Java，ECMAScript，Python，Ruby，Visual Basic 等。此外，Python 社区已经使用了这个术语，至于其他语言也可以用这个术语，因为其他的名称往往会让大家感觉到混乱。大多数情况下，例如在 Java，ECMAScript 或 Visual Basic 中，这一策略也称之为按值传递——意味着：特殊值——引用拷贝（副本）。</p>
<p>一方面，它是这样的——传递给函数内部用的参数仅仅是绑定值（引用地址）的一个名称，并不会影响外部的对象。</p>
<p>另一方面，如果不深入研究，这些术语真的被认为吃错误的，因为很多论坛都在说如何将对象传递给 JavaScript 函数）。</p>
<p>一般理论确实有按值传递的说法：但这时候这个值就是我们所说的地址拷贝（副本），因此并没哟破坏规则。</p>
<p>在 Ruby 中，这个策略称为按引用传递。再说一下：它不是按照大结构的拷贝来传递（例如，不是按值传递),而另一方面，我们没有处理原始对象的引用，并且不能修改它；因此，这个跨术语的概念可能更会造成混乱。</p>
<p>理论里没有像按值传递的特殊 case 一样来面试按引用传递的特殊 case。</p>
<p>但依然有必要了解这些策略在上述提到的技术中（Java，ECMAScript，Python，Ruby，other），实际上——他们用的策略就是按共享传递。</p>
<h3 id="按共享与指针"><a href="#按共享与指针" class="headerlink" title="按共享与指针"></a>按共享与指针</h3><p>对于 С/С++，这个策略在思想上和按指针值传递是一样的，但有一个重要的区别——该策略可以取消引用指针以及完全改变对象。但在一般情况下，分配一个值（地址）指针到新的内存块（即之前引用的内存块保持不变）；通过指针改变对象属性的话会影响阿东外部对象。</p>
<p>因此，和指针类别，我们可以明显看到，这是按地址值传递。 在这种情况下，按共享传递只是“语法糖”，像指针赋值行为一样（但不能取消引用），或者像引用一样修改属性（不需要取消引用操作），有时候，它可以被命名为“安全指针”。</p>
<p>然而，С/С++如果在没有明显指针的解引用的情况下，引用对象属性的时候，还具有特殊的语法糖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-&gt;x instead of (*obj).x</div></pre></td></tr></table></figure>
<p>和 C++关系最为紧密的这种意识形态可以从“智能指针”的实现中看到，例如，在 boost :: shared_ptr 里，重载了赋值操作符以及拷贝构造函数，而且还使用了对象的引用计数器，通过GC删除对象。 这种数据类型，甚至有类似的名字共享_ptr。</p>
<h2 id="ECMAScript-实现"><a href="#ECMAScript-实现" class="headerlink" title="ECMAScript 实现"></a>ECMAScript 实现</h2><p>现在我们知道了 ECMAScript 中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象。但是，正如我们上面提到的，其中的 ECMAScript 开发人员一般都称之为是：按值传递，只不过该值是引用地址的拷贝。</p>
<p>JavaScript 发明人布伦丹·艾希也写到了：传递的是引用的拷贝（地址副本）。所以论坛里大家曾说的按值传递，在这种解释下，也是对的。</p>
<p>更确切地说，这种行为可以理解为简单的赋值，我们可以看到，内部是完全不同的对象，只不过引用的是相同的值——也就是地址副本。</p>
<p>ECMAScript 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10, y: 20&#125;;</div><div class="line">var bar = foo;</div><div class="line">alert(bar === foo); // true</div><div class="line">bar.x = 100;</div><div class="line">bar.y = 200;</div><div class="line">alert([foo.x, foo.y]); // [100, 200]</div></pre></td></tr></table></figure>
<p>即两个标识符（名称绑定）绑定到内存中的同一个对象， 共享这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo value: addr(0xFF) =&gt; &#123;x: 100, y: 200&#125; (address 0xFF) &lt;= bar value: addr(0xFF)</div></pre></td></tr></table></figure>
<p>而重新赋值分配，绑定是新的对象标识符（新地址），而不影响已经先前绑定的对象 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bar = &#123;z: 1, q: 2&#125;;</div><div class="line">alert([foo.x, foo.y]); // [100, 200] – 没改变</div><div class="line">alert([bar.z, bar.q]); // [1, 2] – 但现在引用的是新对象</div></pre></td></tr></table></figure>
<p>即现在 foo 和 bar，有不同的值和不同的地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo value: addr(0xFF) =&gt; &#123;x: 100, y: 200&#125; (address 0xFF)</div><div class="line">bar value: addr(0xFA) =&gt; &#123;z: 1, q: 2&#125; (address 0xFA)</div></pre></td></tr></table></figure>
<p>再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。</p>
<p>此外，如果只考虑 ECMA-262 标准所提供的抽象层次，我们在算法里看到的只有“值”这个概念，实现传递的“值”（可以是原始值，也可以是对象），但是按照我们上面的定义，也可以完全称之为“按值传递”，因为引用地址也是值。</p>
<p>然而，为了避免误解（为什么外部对象的属性可以在函数内部改变），这里依然需要考虑实现层面的细节——我们看到的按共享传递，或者换句话讲——按安全指针传递，而安全指针不可能去解除引用和改变对象的，但可以去修改该对象的属性值。</p>
<h2 id="术语版本"><a href="#术语版本" class="headerlink" title="术语版本"></a>术语版本</h2><p>让我们来定义 ECMAScript 中该策略的术语版本。</p>
<p>可以称之为“按值传递”——这里所说的值是一个特殊的 case，也就是该值是地址副本（address copy）。从这个层面我们可以说：ECMAScript 中除了异常之外的对象都是按值传递的，这实际上是 ECMAScript 抽象的层面。</p>
<p>或针对这种情况下，专门称之为“按共享传递”，通过这个正好可以看到传统的按值传递和按引用传递的区别，这种情况，可以分成 2 种情况：1、原始值按值传递；2、对象按共享传递。</p>
<p>“通过引用类型将对象到函数”这句话和 ECMAScript 无关，而且它是错误的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望这篇文章有助于宏观上了解更多细节，以及在 ECMAScript 中的实现。一如既往，如果有任何问题，欢迎讨论。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="external">Evaluation strategy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="external">Call by value</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="external">Call by reference</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">Call by sharing</a></li>
</ul>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/2/" class="pagination-prev">上一页</a>
  
  
  <a href="/page/4/" class="pagination-next">下一页</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/xuhongbo" target="_blank">Xuhongbo</a>
    </br>
    
    &copy; 2017 John Doe
    
  </p>
</footer>
    
  </div>
</div>
</body>
</html>