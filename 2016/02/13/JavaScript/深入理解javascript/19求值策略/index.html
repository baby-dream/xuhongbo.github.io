<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>求值策略 | xuhongbo</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="poetries,前端,设计,Hexo主题,前端开发,用户体验,设计,frontend,design,nodejs,JavaScript" />
  

  <meta name="description" content="本章，我们将讲解在 ECMAScript 向函数 function 传递参数的策略。
计算机科学里对这种策略一般称为“evaluation strategy”（大叔注：有的人说翻译成求值策略，有的人翻译成赋值策略，通看下面的内容，我觉得称为赋值策略更为恰当，anyway，标题还是写成大家容易理解的求值策略吧），例如在编程语言为求值或者计算表达式设置规则。向函数传递参数的策略是一个特殊的 case。">
<meta property="og:type" content="article">
<meta property="og:title" content="求值策略">
<meta property="og:url" content="http://xuhongbo.com/2016/02/13/JavaScript/深入理解javascript/19求值策略/index.html">
<meta property="og:site_name" content="xuhongbo">
<meta property="og:description" content="本章，我们将讲解在 ECMAScript 向函数 function 传递参数的策略。
计算机科学里对这种策略一般称为“evaluation strategy”（大叔注：有的人说翻译成求值策略，有的人翻译成赋值策略，通看下面的内容，我觉得称为赋值策略更为恰当，anyway，标题还是写成大家容易理解的求值策略吧），例如在编程语言为求值或者计算表达式设置规则。向函数传递参数的策略是一个特殊的 case。">
<meta property="og:updated_time" content="2017-03-02T14:09:37.989Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="求值策略">
<meta name="twitter:description" content="本章，我们将讲解在 ECMAScript 向函数 function 传递参数的策略。
计算机科学里对这种策略一般称为“evaluation strategy”（大叔注：有的人说翻译成求值策略，有的人翻译成赋值策略，通看下面的内容，我觉得称为赋值策略更为恰当，anyway，标题还是写成大家容易理解的求值策略吧），例如在编程语言为求值或者计算表达式设置规则。向函数传递参数的策略是一个特殊的 case。">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=d671a41f" rel="stylesheet">


  

  

  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/search/"
            rel="noopener noreferrer"
            target="_self"
            >
            搜索
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录<i class="iconfont toc-title" style="display:inline-block;color:#87998d;width:20px;height:20px;">&#xf004b;</i></strong>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#一般理论"><span class="toc-text">一般理论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#按值传递"><span class="toc-text">按值传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按引用传递"><span class="toc-text">按引用传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按共享传递（Call-by-sharing）"><span class="toc-text">按共享传递（Call by sharing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按共享传递是按值传递的特例"><span class="toc-text">按共享传递是按值传递的特例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#按共享与指针"><span class="toc-text">按共享与指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ECMAScript-实现"><span class="toc-text">ECMAScript 实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#术语版本"><span class="toc-text">术语版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其它参考"><span class="toc-text">其它参考</span></a></li></ol>
  </div>
  <i class="iconfont" id="toc-eye" style="display:inline-block;color:#b36619;position:absolute;top:72px;right:233px;cursor:pointer;
    font-size: 24px;">&#xe61c;</i>
  <script src="//cdn.bootcss.com/jquery/3.1.0/jquery.min.js"></script>
  <script>
	$("#toc-eye").click(function(){
	
			$("#toc.toc-article").toggle(1000);
			$(this).css({
				"right":"265px"
			});
		
	});
  </script>



<div class="content content-post CENTER">
   <canvas id="evanyou" width="1302" height="678" style="position: fixed;width: 100%;height: 100%;top: 0;left:0;z-index:-1;"></canvas>
<article id="post-JavaScript/深入理解javascript/19求值策略" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">求值策略</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2016.02.13</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>xuhongbo</span>
        </span>
      

      


      

    </div>
  </header>

  <div class="article-content">
    
      <p>本章，我们将讲解在 ECMAScript 向函数 function 传递参数的策略。</p>
<p>计算机科学里对这种策略一般称为“evaluation strategy”（大叔注：有的人说翻译成求值策略，有的人翻译成赋值策略，通看下面的内容，我觉得称为赋值策略更为恰当，anyway，标题还是写成大家容易理解的求值策略吧），例如在编程语言为求值或者计算表达式设置规则。向函数传递参数的策略是一个特殊的 case。<br><a id="more"></a><br>写这篇文章的原因是因为论坛上有人要求准确解释一些传参的策略，我们这里给出了相应的定义，希望对大家有所帮助。</p>
<p>很多程序员都确信在 JavaScript 中（甚至其它一些语言)，对象是按引用传参，而原始值类型按值传参，此外，很多文章都说到这个“事实”，但有多人真正理解这个术语，而且又有多少是正确的?我们本篇讲逐一讲解。</p>
<h2 id="一般理论"><a href="#一般理论" class="headerlink" title="一般理论"></a>一般理论</h2><p>需要注意到，在赋值理论里一般有 2 中赋值策略：严格——意思是说参数在进入程序之前是经过计算过的；非严格——意思是参数的计算是根据计算要求才去计算（也就是相当于延迟计算）。</p>
<p>然后，这里我们考虑基本的函数传参策略，从 ECMAScript 出发点来说是非常重要的。首先需要注意的是，在 ECMAScript 中（甚至其他的语如C，JAVA，Python 和 Ruby 中）都使用了严格的参数传递策略。</p>
<p>另外传递参数的计算顺序也是很重要的——在 ECMAScript 是左到右，而且其它语言实现的反省顺序（从右向做）也是可以用的。</p>
<p>严格的传参策略也分为几种子策略，其中最重要的一些策略我们在本章详细讨论。</p>
<p>下面讨论的策略不是全部都用在 ECMAScript 中，所以在讨论这些策略的具体行为的时候，我们使用了伪代码来展示。</p>
<h3 id="按值传递"><a href="#按值传递" class="headerlink" title="按值传递"></a>按值传递</h3><p>按值传递，很多开发人员都很了解了，参数的值是调用者传递的对象值的拷贝(copy of value），函数内部改变参数的值不会影响到外面的对象（该参数在外面的值），一般来说，是重新分配了新内存(我们不关注分配内存是怎么实现的——也是是栈也许是动态内存分配），该新内存块的值是外部对象的拷贝，并且它的值是用到函数内部的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bar = 10</div><div class="line">procedure foo(barArg):</div><div class="line">  barArg = 20;</div><div class="line">end</div><div class="line">foo(bar)</div><div class="line">// foo内部改变值不会影响内部的bar的值</div><div class="line">print(bar) // 10</div></pre></td></tr></table></figure>
<p>但是，如果该函数的参数不是原始值而是复杂的结构对象是时候，将带来很大的性能问题，C++就有这个问题，将结构作为值传进函数的时候——就是完整的拷贝。</p>
<p>我们来给一个一般的例子，用下面的赋值策略来检验一下，想想一下一个函数接受 2 个参数，第 1 个参数是对象的值，第 2 个是个布尔型的标记，用来标记是否完全修改传入的对象（给对象重新赋值），还是只修改该对象的一些属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// 注：以下都是伪代码，不是JS实现</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">foo(bar)</div><div class="line">// 按值传递，外部的对象不被改变</div><div class="line">print(bar) // &#123;x: 10, y: 20&#125;</div><div class="line">// 完全改变对象（赋新值）</div><div class="line">foo(bar, true)</div><div class="line">//也没有改变</div><div class="line">print(bar) // &#123;x: 10, y: 20&#125;, 而不是&#123;z: 1, q: 2&#125;</div></pre></td></tr></table></figure>
<h3 id="按引用传递"><a href="#按引用传递" class="headerlink" title="按引用传递"></a>按引用传递</h3><p>另外一个众所周知的按引用传递接收的不是值拷贝，而是对象的隐式引用，如该对象在外部的直接引用地址。函数内部对参数的任何改变都是影响该对象在函数外部的值，因为两者引用的是同一个对象，也就是说：这时候参数就相当于外部对象的一个别名。</p>
<p>伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">// 使用和上例相同的对象</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">// 按引用调用的结果如下： </div><div class="line">foo(bar)</div><div class="line">// 对象的属性值已经被改变了</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div><div class="line">// 重新赋新值也影响到了该对象</div><div class="line">foo(bar, true)</div><div class="line">// 此刻该对象已经是一个新对象了</div><div class="line">print(bar) // &#123;z: 1, q: 2&#125;</div></pre></td></tr></table></figure>
<p>该策略可以更有效地传递复杂对象，例如带有大批量属性的大结构对象。</p>
<h3 id="按共享传递（Call-by-sharing）"><a href="#按共享传递（Call-by-sharing）" class="headerlink" title="按共享传递（Call by sharing）"></a>按共享传递（Call by sharing）</h3><p>上面 2 个策略大家都是知道的，但这里要讲的一个策略可能大家不太了解（其实是学术上的策略)。但是，我们很快就会看到这正是它在 ECMAScript 中的参数传递战略中起着关键作用的策略。</p>
<p>这个策略还有一些代名词：“按对象传递”或“按对象共享传递”。</p>
<p>该策略是 1974 年由 Barbara Liskov 为 CLU 编程语言提出的。</p>
<p>该策略的要点是：函数接收的是对象对于的拷贝（副本），该引用拷贝和形参以及其值相关联。</p>
<p>这里出现的引用，我们不能称之为“按引用传递”，因为函数接收的参数不是直接的对象别名，而是该引用地址的拷贝。</p>
<p>最重要的区别就是：函数内部给参数重新赋新值不会影响到外部的对象（和上例按引用传递的 case），但是因为该参数是一个地址拷贝，所以在外面访问和里面访问的都是同一个对象（例如外部的该对象不是想按值传递一样完全的拷贝),改变该参数对象的属性值将会影响到外部的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">procedure foo(barArg, isFullChange):</div><div class="line">  if isFullChange:</div><div class="line">    barArg = &#123;z: 1, q: 2&#125;</div><div class="line">    exit</div><div class="line">  end</div><div class="line">  barArg.x = 100</div><div class="line">  barArg.y = 200</div><div class="line">end</div><div class="line">//还是使用这个对象结构</div><div class="line">bar = &#123;</div><div class="line">  x: 10,</div><div class="line">  y: 20</div><div class="line">&#125;</div><div class="line">// 按贡献传递会影响对象 </div><div class="line">foo(bar)</div><div class="line">// 对象的属性被修改了</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div><div class="line">// 重新赋值没有起作用</div><div class="line">foo(bar, true)</div><div class="line">// 依然是上面的值</div><div class="line">print(bar) // &#123;x: 100, y: 200&#125;</div></pre></td></tr></table></figure>
<p>这个处理的假设前提是大多数语言里用到的对象，而不是原始值。</p>
<h3 id="按共享传递是按值传递的特例"><a href="#按共享传递是按值传递的特例" class="headerlink" title="按共享传递是按值传递的特例"></a>按共享传递是按值传递的特例</h3><p>按共享传递这个策略很很多语言里都使用了：Java，ECMAScript，Python，Ruby，Visual Basic 等。此外，Python 社区已经使用了这个术语，至于其他语言也可以用这个术语，因为其他的名称往往会让大家感觉到混乱。大多数情况下，例如在 Java，ECMAScript 或 Visual Basic 中，这一策略也称之为按值传递——意味着：特殊值——引用拷贝（副本）。</p>
<p>一方面，它是这样的——传递给函数内部用的参数仅仅是绑定值（引用地址）的一个名称，并不会影响外部的对象。</p>
<p>另一方面，如果不深入研究，这些术语真的被认为吃错误的，因为很多论坛都在说如何将对象传递给 JavaScript 函数）。</p>
<p>一般理论确实有按值传递的说法：但这时候这个值就是我们所说的地址拷贝（副本），因此并没哟破坏规则。</p>
<p>在 Ruby 中，这个策略称为按引用传递。再说一下：它不是按照大结构的拷贝来传递（例如，不是按值传递),而另一方面，我们没有处理原始对象的引用，并且不能修改它；因此，这个跨术语的概念可能更会造成混乱。</p>
<p>理论里没有像按值传递的特殊 case 一样来面试按引用传递的特殊 case。</p>
<p>但依然有必要了解这些策略在上述提到的技术中（Java，ECMAScript，Python，Ruby，other），实际上——他们用的策略就是按共享传递。</p>
<h3 id="按共享与指针"><a href="#按共享与指针" class="headerlink" title="按共享与指针"></a>按共享与指针</h3><p>对于 С/С++，这个策略在思想上和按指针值传递是一样的，但有一个重要的区别——该策略可以取消引用指针以及完全改变对象。但在一般情况下，分配一个值（地址）指针到新的内存块（即之前引用的内存块保持不变）；通过指针改变对象属性的话会影响阿东外部对象。</p>
<p>因此，和指针类别，我们可以明显看到，这是按地址值传递。 在这种情况下，按共享传递只是“语法糖”，像指针赋值行为一样（但不能取消引用），或者像引用一样修改属性（不需要取消引用操作），有时候，它可以被命名为“安全指针”。</p>
<p>然而，С/С++如果在没有明显指针的解引用的情况下，引用对象属性的时候，还具有特殊的语法糖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj-&gt;x instead of (*obj).x</div></pre></td></tr></table></figure>
<p>和 C++关系最为紧密的这种意识形态可以从“智能指针”的实现中看到，例如，在 boost :: shared_ptr 里，重载了赋值操作符以及拷贝构造函数，而且还使用了对象的引用计数器，通过GC删除对象。 这种数据类型，甚至有类似的名字共享_ptr。</p>
<h2 id="ECMAScript-实现"><a href="#ECMAScript-实现" class="headerlink" title="ECMAScript 实现"></a>ECMAScript 实现</h2><p>现在我们知道了 ECMAScript 中将对象作为参数传递的策略了——按共享传递：修改参数的属性将会影响到外部，而重新赋值将不会影响到外部对象。但是，正如我们上面提到的，其中的 ECMAScript 开发人员一般都称之为是：按值传递，只不过该值是引用地址的拷贝。</p>
<p>JavaScript 发明人布伦丹·艾希也写到了：传递的是引用的拷贝（地址副本）。所以论坛里大家曾说的按值传递，在这种解释下，也是对的。</p>
<p>更确切地说，这种行为可以理解为简单的赋值，我们可以看到，内部是完全不同的对象，只不过引用的是相同的值——也就是地址副本。</p>
<p>ECMAScript 代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var foo = &#123;x: 10, y: 20&#125;;</div><div class="line">var bar = foo;</div><div class="line">alert(bar === foo); // true</div><div class="line">bar.x = 100;</div><div class="line">bar.y = 200;</div><div class="line">alert([foo.x, foo.y]); // [100, 200]</div></pre></td></tr></table></figure>
<p>即两个标识符（名称绑定）绑定到内存中的同一个对象， 共享这个对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo value: addr(0xFF) =&gt; &#123;x: 100, y: 200&#125; (address 0xFF) &lt;= bar value: addr(0xFF)</div></pre></td></tr></table></figure>
<p>而重新赋值分配，绑定是新的对象标识符（新地址），而不影响已经先前绑定的对象 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">bar = &#123;z: 1, q: 2&#125;;</div><div class="line">alert([foo.x, foo.y]); // [100, 200] – 没改变</div><div class="line">alert([bar.z, bar.q]); // [1, 2] – 但现在引用的是新对象</div></pre></td></tr></table></figure>
<p>即现在 foo 和 bar，有不同的值和不同的地址:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo value: addr(0xFF) =&gt; &#123;x: 100, y: 200&#125; (address 0xFF)</div><div class="line">bar value: addr(0xFA) =&gt; &#123;z: 1, q: 2&#125; (address 0xFA)</div></pre></td></tr></table></figure>
<p>再强调一下，这里所说对象的值是地址（address），而不是对象结构本身，将变量赋值给另外一个变量——是赋值值的引用。因此两个变量引用的是同一个内存地址。下一个赋值却是新地址，是解析与旧对象的地址绑定，然后绑定到新对象的地址上，这就是和按引用传递的最重要区别。</p>
<p>此外，如果只考虑 ECMA-262 标准所提供的抽象层次，我们在算法里看到的只有“值”这个概念，实现传递的“值”（可以是原始值，也可以是对象），但是按照我们上面的定义，也可以完全称之为“按值传递”，因为引用地址也是值。</p>
<p>然而，为了避免误解（为什么外部对象的属性可以在函数内部改变），这里依然需要考虑实现层面的细节——我们看到的按共享传递，或者换句话讲——按安全指针传递，而安全指针不可能去解除引用和改变对象的，但可以去修改该对象的属性值。</p>
<h2 id="术语版本"><a href="#术语版本" class="headerlink" title="术语版本"></a>术语版本</h2><p>让我们来定义 ECMAScript 中该策略的术语版本。</p>
<p>可以称之为“按值传递”——这里所说的值是一个特殊的 case，也就是该值是地址副本（address copy）。从这个层面我们可以说：ECMAScript 中除了异常之外的对象都是按值传递的，这实际上是 ECMAScript 抽象的层面。</p>
<p>或针对这种情况下，专门称之为“按共享传递”，通过这个正好可以看到传统的按值传递和按引用传递的区别，这种情况，可以分成 2 种情况：1、原始值按值传递；2、对象按共享传递。</p>
<p>“通过引用类型将对象到函数”这句话和 ECMAScript 无关，而且它是错误的。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我希望这篇文章有助于宏观上了解更多细节，以及在 ECMAScript 中的实现。一如既往，如果有任何问题，欢迎讨论。</p>
<h2 id="其它参考"><a href="#其它参考" class="headerlink" title="其它参考"></a>其它参考</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="external">Evaluation strategy</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_value" target="_blank" rel="external">Call by value</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_reference" target="_blank" rel="external">Call by reference</a></li>
<li><a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="external">Call by sharing</a></li>
</ul>

    
  </div>
</article>

<button class="assist-btn2 circle" id="assist_btn2" title="点亮屏幕" style="left: 27px; top: 152px;">
         <i class="iconfont" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
    </button>
<button class="assist-btn1 circle" id="assist_btn1" title="关闭屏幕亮度" style="left: 27px; top: 152px;">
         <i class="iconfont toc-title" style="display:inline-block;color:red;width:20px;height:20px;">&#xe61d;</i>
    </button>
	

<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>	
<script type="text/javascript">


    // white theme
    var body = {color: "#555", background: "#000"};
    var a_tag = {color: "#222"};
    var header = { background: "#222"};
    var logo_line_i = {background: "#222"};
    // var post_code = {background: "#eee", color: "#222"};

    function switch_theme() {
        $("body").css(body);
        $("a:not('.links-of-author-item a, .site-state-item a, .site-state-posts a, .feed-link a, .motion-element a, .post-tags a, .show-commit-cls a, #donate_board a')").css(a_tag);
        $(".header, .footer").css(header);
        $(".logo-line-before i, .logo-line-after i").css(logo_line_i);
        //$(".post code").css(post_code);
        $("#idhyt-surprise-ball #idhyt-surprise-ball-animation .drag").css(a_tag);
        $(".post-title-link, .posts-expand .post-meta, .post-comments-count, .disqus-comment-count, .post-category a, .post-nav-next a, .post-nav-item a").css(a_tag);
        
        // $("code").css({color: '#c5c8c6', background: '#1d1f21'});
        //$("#assist_btn1").hide(1500);
    }

    $(function () {
		$("#assist_btn2").css("display","none");
        $("#assist_btn1").click(function() {
            switch_theme();
			$("div#toc.toc-article").css({
				"background":"#eaeaea",
				"opacity":1
			});
			$(".toc-article ol").show();
			$("#toc.toc-article .toc-title").css("color","#a98602");
			$("#assist_btn1").css("display","none");
			$("#assist_btn2").css("display","block");
        });
		$("#assist_btn2").click(function() {
			$("#assist_btn2").css("display","none");
			$("#assist_btn1").css("display","block");
			 $("body").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
            $(".header, .footer").css("background","url(http://www.miaov.com/static/ie/images/news/bg.png)")
			$(".toc-article ol").toggle(1000);
        });
    });

	
	//背景随机

	var Y, O, E, L, B, C, T, z, N, S, A, I;
	!function() {
	var e = function() {
		for (O.clearRect(0, 0, L, B), T = [{
			x: 0,
			y: .7 * B + C
		}, {
			x: 0,
			y: .7 * B - C
		}]; T[1].x < L + C;) t(T[0], T[1])
	}, t = function(e, t) {
			O.beginPath(), O.moveTo(e.x, e.y), O.lineTo(t.x, t.y);
			var n = t.x + (2 * I() - .25) * C,
				r = a(t.y);
			O.lineTo(n, r), O.closePath(), N -= S / -50, O.fillStyle = "#" + (127 * A(N) + 128 << 16 | 127 * A(N + S / 3) + 128 << 8 | 127 * A(N + S / 3 * 2) + 128).toString(16), O.fill(), T[0] = T[1], T[1] = {
				x: n,
				y: r
			}
		}, a = function n(e) {
			var t = e + (2 * I() - 1.1) * C;
			return t > B || t < 0 ? n(e) : t
		};
	Y = document.getElementById("evanyou"), O = Y.getContext("2d"), E = window.devicePixelRatio || 1, L = window.innerWidth, B = window.innerHeight, C = 90, z = Math, N = 0, S = 2 * z.PI, A = z.cos, I = z.random, Y.width = L * E, Y.height = B * E, O.scale(E, E), O.globalAlpha = .6, document.onclick = e, document.ontouchstart = e, e()
	}()

          



</script>

</div>


  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持poetries</div>
        <ul class="theme.donation.items.length">
        
          <li class="item">
            <img src="/images/weixin.jpg" alt="">
          </li>
        
          <li class="item">
            <img src="/images/zhifubao.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>




  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/search/"
              rel="noopener noreferrer"
              target="_self"
              >
              搜索
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    
  <section class="duoshuo-comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="http://xuhongbo.com/2016/02/13/JavaScript/深入理解javascript/19求值策略/index.html" data-title="求值策略" data-url="http://xuhongbo.com/2016/02/13/JavaScript/深入理解javascript/19求值策略/index.html"></div>
    <!-- 多说评论框 end -->
  </section>




  <script type="text/javascript">
  var duoshuoQuery = {short_name:"poetry"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>


  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
